<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <script type="text/javascript">
      window.___gcfg = {
        lang: 'en-US'
      };

      (function() {
        var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
        po.src = 'https://apis.google.com/js/plusone.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
      })();
    </script>
    
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <link rel="shortcut icon" href="../images/favicon.ico"/>

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <title>Java developer's Scala cheatsheet by mbonaci</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Java developer's Scala cheatsheet</h1>
        <h2>One huge Scala reference card</h2>
        <a href="https://github.com/mbonaci/scala" class="button"><small>Code examples on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
        
        <!-- Tweet -->
        <a href="https://twitter.com/share" class="twitter-share-button" data-via="markobonaci" data-count="yes" data-hashtags="scala">Tweet</a>
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
        
        <!-- Plus one -->        
        <div class="g-plusone" data-size="medium"></div>
                        
        
          <p>Shamelessly ripped off from <a href="http://www.artima.com/shop/programming_in_scala_2ed">Programming in Scala, second edition</a>. I did ask for permission, though.<br>
Basically, while I'm going through the book, I'm taking notes and pushing them here, so I can later use this page as a Scala quick reference.
If you, by some incredible chance, find any of this useful, please do buy the book. No, I don't get the kick back. As you can see, the book link is clean :)  </p>

    <blockquote>
      Before you start flipping out:
        <ul>
          <li>this is not a tutorial, nor is it pleasant to read</li>
          <li>It's just a quick reference card</li>
        </ul>
    </blockquote>
    
<h3>
<a name="scala-type-hierarchy" class="anchor" href="#scala-type-hierarchy"><span class="octicon octicon-link"></span></a>Scala type hierarchy</h3>

<p><img src="https://github.com/mbonaci/scala/blob/master/resources/Scala-class-hierarchy.gif?raw=true" alt="Scala class hierarchy image"></p>

<h3>
<a name="basic-types-and-operations" class="anchor" href="#basic-types-and-operations"><span class="octicon octicon-link"></span></a>Basic Types and Operations</h3>

<p><strong>127 -</strong> The convention is to include empty parentheses when invoking a method only if that method has side effects</p>

<blockquote>
<ul>
<li>
<strong>Pure methods</strong> are methods that don't have any side effects and don't depend on mutable state (226) </li>
<li>if the function you're calling performs an operation, use the parentheses, but if it merely provides access to a property, leave out the parentheses</li>
</ul>
</blockquote>

<p><strong>127 - Postfix operator:</strong> A method that takes no arguments can be called like this: <code>"some String" toLowerCase</code><br><strong>127 - Integral types:</strong> <code>Int</code>, <code>Long</code>, <code>Byte</code>, <code>Short</code>, <code>Char</code><br><strong>135 - Operator precedence:</strong></p>

<blockquote>
<p><code>(all other special characters)</code><br><code>*</code> <code>/</code> <code>%</code><br><code>+</code> <code>-</code><br><code>:</code><br><code>=</code> <code>!</code><br><code>&lt;</code> <code>&gt;</code><br><code>&amp;</code><br><code>ˆ</code>   - binary xor<br><code>|</code><br><code>(all letters)</code><br><code>(all assignment operators)</code>  </p>
</blockquote>

<p><strong>136 - Operator precedence</strong> is based on the first character of the method used in operator notation, with one exception: If an operator ends with a <code>=</code>, and the operator is not one of the comparison operators <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, or <code>!=</code>, then the precedence of the operator is the same as that of simple assignment <code>=</code>, which is last in the list. E.g. <code>+=</code><br><strong>136 - Associativity</strong>: any method that ends in a <code>:</code> character is invoked on its right operand, passing in the left operand. Methods that end in any other character are invoked on their left operand, passing in the right operand. So <code>a * b</code> yields <code>a.*(b)</code>, but <code>a ::: b</code> yields <code>b.:::(a)</code><br><strong>137 -</strong> <code>a ::: b ::: c</code> is treated as <code>a ::: (b ::: c)</code> (list concatenation)</p>

<h3>
<a name="functional-objects" class="anchor" href="#functional-objects"><span class="octicon octicon-link"></span></a>Functional Objects</h3>

<p><strong>141 - Class parameters</strong>: Any code placed in the class body (outside methods) will be placed in the <em>primary constructor</em>. When declaring a class you can drop empty <code>{}</code><br><strong>143 - Precondition</strong> is a constraint on values passed into a method or constructor (E.g. <code>require(d != 0)</code> in the class body will throw <code>IllegalArgumentException: requirement failed</code> when <code>0</code> is passed as <code>d</code>)<br><strong>144 -</strong> If <strong>Class parameters</strong> are only used inside constructors, the Scala compiler will not create corresponding fields for them<br><strong>146 - Auxiliary constructors</strong> - constructors other than the primary constructor</p>

<blockquote>
<ul>
<li>every <em>auxiliary constructor</em> must invoke another constructor <strong>of the same class</strong> (like Java, only Java can also call superclass's constructor instead) as its first action. That other constructor must textually come before the calling constructor</li>
</ul>
</blockquote>

<p><strong>152 -</strong> The convention is to use camel case for constants, such as <code>XOffset</code><br><strong>153 -</strong> The Scala compiler will internally “mangle” operator identifiers to turn them into legal Java identifiers with embedded <code>$</code> characters. For instance, the identifier <code>:-&gt;</code> would be represented internally as <code>$colon$minus$greater</code>. If you ever wanted to access this identifier from Java code, you'd need to use this internal representation<br><strong>153 - Mixed identifier</strong> consists of an alphanumeric identifier, which is followed by an underscore and an operator identifier, e.g. <code>unary_+</code> (used to support <em>properties</em>)<br><strong>153 - Literal identifier</strong> is an arbitrary string enclosed in back ticks. Used to tell Scala to treat a keyword as an ordinary identifier, e.g., writing <code>Thread.'yield'()</code> treats <code>yield</code> as an identifier rather than a keyword<br><strong>156 - Implicit conversion</strong> definition:</p>

<div class="highlight"><pre><span class="k">implicit</span> <span class="k">def</span> <span class="n">intToRational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
</pre></div>

<blockquote>
<ul>
<li>for an implicit conversion to work, it needs to be in scope. If you place the implicit method definition inside the class <code>Rational</code>, it won't be in scope</li>
</ul>
</blockquote>

<h3>
<a name="built-in-control-structures" class="anchor" href="#built-in-control-structures"><span class="octicon octicon-link"></span></a>Built-in Control Structures</h3>

<p><strong>163 - Assignment</strong> always results with the <strong>unit value</strong>, <code>()</code><br><strong>164 -</strong> In <code>for (file &lt;- files)</code> the <code>&lt;-</code> is called a <strong>generator</strong>. In each iteration, a new <code>val</code> named <code>file</code> is initialized with an element value<br><strong>164 -</strong> The <code>Range</code> type: <code>4 to 8</code>. If you don't want upper bound: <code>4 until 8</code><br><strong>166 - Filter:</strong> <code>for (file &lt;- files if file.getName.endsWith(".scala"))</code></p>

<div class="highlight"><pre><span class="c1">// multiple filters example:</span>
<span class="k">for</span> <span class="o">(</span>
  <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">files</span>  <span class="c1">// files is a previously defined method that returns array of files</span>
  <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">isFile</span>
  <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">".scala"</span><span class="o">)</span>
<span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
</pre></div>

<p><strong>167 - Nested loops</strong> and <strong>mid-stream variable binding</strong> example with <em>generators</em> and <em>filters</em></p>

<div class="highlight"><pre><span class="c1">// curly braces may be used instead of parentheses</span>
<span class="c1">// the compiler does not infer semicolons inside regular parentheses</span>
<span class="k">def</span> <span class="n">grep</span><span class="o">(</span><span class="n">pattern</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">{</span>
    <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">files</span> <span class="k">if</span> <span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="s">".scala"</span><span class="o">)</span>  <span class="c1">// semicolons inferred</span>
    <span class="n">line</span> <span class="k">&lt;-</span> <span class="n">fileLines</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
    <span class="n">trimmed</span> <span class="k">=</span> <span class="n">line</span><span class="o">.</span><span class="n">trim</span>  <span class="c1">// mid-stream variable</span>
    <span class="k">if</span> <span class="n">trimmed</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">pattern</span><span class="o">)</span>
  <span class="o">}</span> <span class="n">println</span><span class="o">(</span><span class="n">file</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">trimmed</span><span class="o">)</span>
</pre></div>

<p><strong>168 - <code>yield</code></strong> keyword makes <code>for</code> clauses produce a value (of the same type as the expression iterated over). Syntax: <code>for clauses yield body</code><br><strong>174 - <code>match case</code></strong></p>

<blockquote>
<ul>
<li>unlike Java's <code>select case</code>, there is no fall through, <code>break</code> is implicit and <code>case</code> expression can contain any type of value</li>
<li>
<code>_</code> is a placeholder for <em>completely unknown value</em>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">target</span> <span class="k">=</span> <span class="n">firstArg</span> <span class="k">match</span> <span class="o">{</span>  <span class="c1">// firstArg is a previously initialized val</span>
  <span class="k">case</span> <span class="s">"salt"</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"pepper"</span><span class="o">)</span>
  <span class="k">case</span> <span class="s">"chips"</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"salsa"</span><span class="o">)</span>
  <span class="k">case</span> <span class="s">"eggs"</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"bacon"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"waat?"</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>

<p><strong>175 -</strong> Scala doesn't have <code>break</code>, nor does it have <code>continue</code> statement<br><strong>180 -</strong> Unlike Java, Scala supports <em>inner scope variable shadowing</em></p>

<h3>
<a name="functions-and-closures" class="anchor" href="#functions-and-closures"><span class="octicon octicon-link"></span></a>Functions and Closures</h3>

<p><strong>186 - Local functions</strong> are functions inside other functions. They are visible only in their enclosing block<br><strong>188 - Function literal</strong> example: <code>(x: Int) =&gt; x + 1</code><br><strong>188 -</strong> Every function value is an instance of some class that extends one of <code>FunctionN</code> traits that has an <code>apply</code> method used to invoke the function (<code>Function0</code> for functions with no params, <code>Function1</code> for functions with 1 param, ...)<br><strong>189 - <code>foreach</code></strong> is a method of <code>Traversable</code> trait (supertrait of <code>List</code>, <code>Set</code>, <code>Array</code> and <code>Map</code>) which takes a function as an argument and applies it to all elements<br><strong>190 - <code>filter</code></strong> method takes a function that maps each element to true or false, e.g. <code>someNums.filter((x: Int) =&gt; x &gt; 0)</code><br><strong>190 - Target typing</strong> - Scala infers type by examining the way the expression is used, e.g. <code>filter</code> example can be written: <code>someNums.filter(x =&gt; x &gt; 0)</code><br><strong>191 - Placeholder</strong> allows you to write: <code>someNums.filter(_ &gt; 0)</code></p>

<blockquote>
<ul>
<li>only if each function parameter appears in function literal only once (one placeholder for each param, sequentially)</li>
<li>sometimes the compiler might not have enough info to infer missing param types:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="k">_</span> <span class="o">+</span> <span class="k">_</span>  <span class="c1">// error: missing parameter type for expanded function...</span>
<span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="k">_:</span> <span class="kt">Int</span><span class="o">)</span>  <span class="c1">// OK: f(5, 10) = 15</span>
</pre></div>

<p><strong>192 - Partially applied function (PAF)</strong> is an expression in which you don't supply all of the arguments needed by the function. Instead, you supply some, or none:</p>

<div class="highlight"><pre><span class="n">someNums</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span> <span class="k">_</span><span class="o">)</span>  
<span class="c1">// is equivalent to:</span>
<span class="n">someNums</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="c1">// if a function value is required in that place you can omit the placeholder:</span>
<span class="n">someNums</span><span class="o">.</span><span class="n">foreach</span><span class="o">(</span><span class="n">println</span><span class="o">)</span>
</pre></div>

<div class="highlight"><pre><span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">c</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>

<span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">sum</span> <span class="k">_</span>  <span class="c1">// '_' is a placeholder for the entire param list</span>
<span class="n">a</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">,</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">function3</span><span class="o">&gt;</span>

<span class="c1">// they are called partially applied functions because you can do this:</span>
<span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="k">_:</span> <span class="kt">Int</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">b</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>  <span class="c1">// Int = 6</span>
</pre></div>

<p><strong>197 - Closures</strong> see the changes to <strong>free variables</strong> and <em>vice versa</em>, changes to <em>free variables</em> made by <em>closure</em> are seen outside of <em>closure</em><br><strong>199 - Repeated parameters</strong> Scala allows you to indicate that the last param to a function may be repeated:</p>

<div class="highlight"><pre><span class="k">def</span> <span class="n">echo</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span> <span class="k">=</span> <span class="k">for</span><span class="o">(</span><span class="n">arg</span> <span class="k">&lt;-</span> <span class="n">args</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
<span class="c1">// Now `echo` may be called with zero or more params</span>

<span class="c1">// to pass in an `Array[String]` instead, you need to</span>
<span class="c1">// append the arg with a colon and an `_*` symbol:</span>
<span class="n">echo</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">"arr"</span><span class="o">,</span> <span class="s">"of"</span><span class="o">,</span> <span class="s">"strings"</span><span class="o">)</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>
</pre></div>

<p><strong>200 - Named arguments</strong> allow you to pass args to a function in a different order:</p>

<div class="highlight"><pre><span class="c1">// The syntax is to precede each argument with a param name and an equals sign:</span>
<span class="n">speed</span><span class="o">(</span><span class="n">distance</span> <span class="k">=</span> <span class="mi">100</span><span class="o">,</span> <span class="n">time</span> <span class="k">=</span> <span class="mi">10</span><span class="o">)</span>

<span class="c1">// it is also possible to mix positional and named args</span>
<span class="c1">// in which case the positional arguments, understandably, must come first</span>
</pre></div>

<p><strong>201 - Default parameter values</strong> allows you to omit such a param when calling a function, in which case the param will be filled with its default value:</p>

<div class="highlight"><pre><span class="k">def</span> <span class="n">printTime</span><span class="o">(</span><span class="n">out</span><span class="k">:</span> <span class="kt">java.io.PrintStream</span> <span class="o">=</span> <span class="nc">Console</span><span class="o">.</span><span class="n">out</span><span class="o">)</span> <span class="k">=</span> 
  <span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="s">"time = "</span> <span class="o">+</span>  <span class="nc">System</span><span class="o">.</span><span class="n">currentTimeMillis</span><span class="o">())</span>

<span class="c1">// now, you can call the function like this: </span>
<span class="n">printTime</span><span class="o">()</span>
<span class="c1">// or like this: </span>
<span class="n">printTime</span><span class="o">(</span><span class="nc">Console</span><span class="o">.</span><span class="n">err</span><span class="o">)</span>
</pre></div>

<p><strong>202 - Tail recursion (Tail call optimization)</strong></p>

<blockquote>
<ul>
<li>if the recursive call is the last action in the function body, compiler is able to replace the call with a jump back to the beginning of the function, after updating param values</li>
<li>because of the JVM instruction set, tail call optimization cannot be applied for two mutually recursive functions nor if the final call goes to a function value (function wraps the recursive call):</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">funValue</span> <span class="k">=</span> <span class="n">nestedFun</span> <span class="k">_</span>
<span class="k">def</span> <span class="n">nestedFun</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span><span class="n">println</span><span class="o">(</span><span class="n">x</span><span class="o">);</span> <span class="n">funValue</span><span class="o">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)}</span>  <span class="c1">// won't be optimized</span>
<span class="o">}</span>
</pre></div>

<h3>
<a name="control-abstractions" class="anchor" href="#control-abstractions"><span class="octicon octicon-link"></span></a>Control Abstractions</h3>

<p><strong>207 - Higher order functions</strong> - functions that take other functions as parameters:</p>

<div class="highlight"><pre><span class="cm">/** </span>
<span class="cm"> * refactoring imperative code:</span>
<span class="cm"> * demonstrates control abstraction (higher order function)</span>
<span class="cm"> * that reduces code duplication and significantly simplifies the code</span>
<span class="cm">*/</span>
<span class="c1">// function receives a String and a function that maps (String, String) =&gt; Boolean</span>
<span class="k">def</span> <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">matcher</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span>
    <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span>  <span class="c1">// filesHere is a function that returns an Array of files</span>
    <span class="k">if</span> <span class="n">matcher</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">,</span> <span class="n">query</span><span class="o">)</span>
  <span class="o">)</span> <span class="k">yield</span> <span class="n">file</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">filesEnding</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">fileName</span><span class="o">.</span><span class="n">endsWith</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>

<span class="k">def</span> <span class="n">filesContaining</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="o">(</span><span class="n">fileName</span><span class="o">,</span> <span class="n">query</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">fileName</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">query</span><span class="o">))</span> <span class="c1">// OK to omit types</span>

<span class="k">def</span> <span class="n">filesRegex</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">filesMatching</span><span class="o">(</span><span class="n">query</span><span class="o">,</span> <span class="k">_</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="k">_</span><span class="o">))</span>  <span class="c1">// since each 'matcher' param is used only once</span>


<span class="c1">// since the query is unnecessarily passed around,</span>
<span class="c1">// we can further simplify the code by introducing a closure</span>
<span class="k">def</span> <span class="n">filesMatching</span><span class="o">(</span><span class="n">matcher</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">for</span><span class="o">(</span>
    <span class="n">file</span> <span class="k">&lt;-</span> <span class="n">filesHere</span><span class="o">;</span>
    <span class="k">if</span> <span class="n">matcher</span><span class="o">(</span><span class="n">file</span><span class="o">.</span><span class="n">getName</span><span class="o">)</span>
  <span class="o">)</span> <span class="k">yield</span> <span class="n">file</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">filesRegex</span><span class="o">(</span><span class="n">query</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
  <span class="n">filesMatching</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">matches</span><span class="o">(</span><span class="n">query</span><span class="o">))</span>  <span class="c1">// 'matches' closes over free variable 'query'</span>
</pre></div>

<p><strong>213 - Currying</strong>: A curried function is applied to multiple argument lists, instead of just one:</p>

<div class="highlight"><pre><span class="k">def</span> <span class="n">curriedSum</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)(</span><span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="c1">// curriedSum: (x: Int)(y: Int)Int</span>

<span class="n">curriedSum</span><span class="o">(</span><span class="mi">1</span><span class="o">)(</span><span class="mi">2</span><span class="o">)</span>
<span class="c1">// Int = 3</span>

<span class="cm">/*</span>
<span class="cm"> * Curried f produces two traditional function invocations. The first function invocation</span>
<span class="cm"> * takes a single 'Int' parameter named 'x', and returns a function value for the second</span>
<span class="cm"> * function, which takes the 'Int' parameter 'y'</span>
<span class="cm">*/</span>

<span class="c1">// This is what the first function actually does:</span>
<span class="k">def</span> <span class="n">first</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>  <span class="c1">// returns function value</span>
<span class="c1">// (x: Int)Int =&gt; Int</span>

<span class="k">val</span> <span class="n">second</span> <span class="k">=</span> <span class="n">first</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>  <span class="c1">// applying 1 to the first fn yields the second fn</span>
<span class="c1">// (x: Int)Int =&gt; Int</span>

<span class="n">second</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>  <span class="c1">// applying 2 to the second fn yields the final result</span>
<span class="c1">// Int = 3</span>

<span class="cm">/*</span>
<span class="cm"> * You can use the placeholder notation to use curriedSum in a partially applied function</span>
<span class="cm"> * expression which returns the second function:</span>
<span class="cm">*/</span>
<span class="k">val</span> <span class="n">onePlus</span> <span class="k">=</span> <span class="n">curriedSum</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="k">_</span>  <span class="c1">// '_' is a placeholder for the second param list</span>
<span class="c1">// onePlus: (Int) =&gt; Int = &lt;function1&gt;  // 'onePlus' does the same thing as 'second'</span>

<span class="cm">/*</span>
<span class="cm">when using placeholder notation with Scala identifiers you need to put a space between</span>
<span class="cm">identifier and underscore, which is why we didn't need space in 'curriedSum(1)_' and we</span>
<span class="cm">did need space for 'println _'</span>
<span class="cm">*/</span>

<span class="c1">// another example of higher order function, that repeats an operation two times</span>
<span class="c1">// and returns the result:</span>
<span class="k">def</span> <span class="n">twice</span><span class="o">(</span><span class="n">op</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=&gt;</span> <span class="nc">Double</span><span class="o">,</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">op</span><span class="o">(</span><span class="n">op</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>
<span class="n">twice</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>  <span class="c1">// f(f(x)) = x + 1 + 1, where x = 5</span>
<span class="c1">// Double = 7.0</span>
</pre></div>

<p><strong>216 - Loan pattern</strong></p>

<blockquote>
<ul>
<li>some control abstraction function opens a resource and <em>loans</em> it to a function:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// opening a resource and loaning it to 'op'</span>
<span class="k">def</span> <span class="n">withPrintWriter</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">,</span> <span class="n">op</span><span class="k">:</span> <span class="kt">PrintWriter</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">writer</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrintWriter</span><span class="o">(</span><span class="n">file</span><span class="o">)</span>
  <span class="k">try</span> <span class="o">{</span>
    <span class="n">op</span><span class="o">(</span><span class="n">writer</span><span class="o">)</span>  <span class="c1">// loan the resource to the 'op' function</span>
  <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>   <span class="c1">// this way we're sure that the resource is closed in the end</span>
    <span class="n">writer</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// to call the method:</span>
<span class="n">withPrintWriter</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"date.txt"</span><span class="o">),</span>
  <span class="n">writer</span> <span class="k">=&gt;</span> <span class="n">writer</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Date</span><span class="o">)</span>
<span class="o">)</span>

<span class="cm">/*</span>
<span class="cm"> * In any method invocation in which you're passing in 'exactly one argument'</span>
<span class="cm"> * you can opt to use curly braces instead of parentheses to surround the argument</span>
<span class="cm"> */</span>

<span class="c1">// using 'currying', you can redefine 'withPrintWriter' signature like this:</span>
<span class="k">def</span> <span class="n">withPrintWriter</span><span class="o">(</span><span class="n">file</span><span class="k">:</span> <span class="kt">File</span><span class="o">)(</span><span class="n">op</span><span class="k">:</span> <span class="kt">PrintWriter</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span>

<span class="c1">// which now enables you to call the function with a more pleasing syntax:</span>
<span class="k">val</span> <span class="n">file</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">File</span><span class="o">(</span><span class="s">"date.txt"</span><span class="o">)</span>
<span class="n">withPrintWriter</span><span class="o">(</span><span class="n">file</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// this curly brace is the second parameter</span>
    <span class="n">writer</span> <span class="k">=&gt;</span> <span class="n">writer</span><span class="o">.</span><span class="n">println</span><span class="o">(</span><span class="k">new</span> <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Date</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>

<p><strong>218 - By-name parameters</strong></p>

<blockquote>
<ul>
<li>typically, parameters to functions are <em>by-value</em> parameters, meaning, the value of the parameter is determined before it is passed to the function</li>
<li>to write a function that accepts an expression that is not evaluated until it's called within a function, you use <em>call-by-name</em> mechanism, which passes a code block to the callee and each time the callee accesses the parameter, the code block is executed and the value is calculated:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">var</span> <span class="n">assertionsEnabled</span> <span class="k">=</span> <span class="kc">true</span>
<span class="k">def</span> <span class="n">myAssert</span><span class="o">(</span><span class="n">predicate</span><span class="k">:</span> <span class="o">()</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span>  <span class="c1">// without by-name parameter</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">assertionsEnabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">predicate</span><span class="o">())</span>  <span class="c1">// call it like this: myAssert(() =&gt; 5 &gt; 3)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">AssertionError</span>

<span class="c1">// to make a by-name parameter, you give the parameter a type</span>
<span class="c1">// starting with '=&gt;' instead of '() =&gt;'</span>
<span class="k">def</span> <span class="n">myAssert</span><span class="o">(</span><span class="n">predicate</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span> <span class="k">=</span>     <span class="c1">// with by-name parameter</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">assertionsEnabled</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">predicate</span><span class="o">())</span>  <span class="c1">// call it like this: myAssert(5 &gt; 3)</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nc">AssertionError</span>              <span class="c1">// which looks exactly like built-in structure</span>

<span class="c1">// we could've used a plain-old Boolean, but then the passed expression</span>
<span class="c1">// would get executed before the call to 'boolAssert'</span>
</pre></div>

<h3>
<a name="composition-and-inheritance" class="anchor" href="#composition-and-inheritance"><span class="octicon octicon-link"></span></a>Composition and Inheritance</h3>

<p><strong>222 - Composition</strong> means one class holds a reference to another<br><strong>224 - <code>abstract</code> method</strong> does not have an implementation (i.e., no equals sign or body)</p>

<blockquote>
<ul>
<li>unlike Java, no abstract modifier is allowed on method declarations</li>
<li>methods that do have an implementation are called <strong>concrete</strong>
</li>
</ul>
</blockquote>

<p><strong>224 -</strong> Class is said to <strong>declare an abstract method</strong> and that it <strong>defines a concrete method</strong> (i.e. <em>declaration</em> is <em>abstract</em>, <em>definition</em> is <em>concrete</em>)<br><strong>225 -</strong> Methods with empty parentheses are called <strong>empty-paren methods</strong></p>

<blockquote>
<ul>
<li>this convention (see <em>bullet 127</em> on top) supports the <strong>uniform access principle</strong>, which says that the client code should not be affected by a decision to implement an attribute as a field or as a method</li>
<li>from the client's code perspective, it should be irrelevant whether <code>val</code> or <code>def</code> is accessed</li>
<li>the only difference is speed, since fields are precomputed when the class is initialized</li>
<li>but, on the other hand, fields are carried around with the parent object</li>
</ul>
</blockquote>

<p><strong>229 -</strong> Fields and methods belong to the same <em>namespace</em>, which makes possible for a
field to override a parameterless method, but it forbids defining a field and a method with the same name<br><strong>230 -</strong> <em>Java</em> has four namespaces: fields, methods, types and packages<br><em>Scala</em> has two namespaces:<br><strong>values</strong> (fields, methods, packages and singleton objects)<br><strong>types</strong> (classes and traits)<br><strong>231 - Parametric field</strong> is a shorthand definition for <em>parameter</em> and <em>field</em>, where <em>field</em> gets assigned a <em>parameter's</em> value (the parametric field's name mustn't clash with an existing element in the same namespace, like field or method):</p>

<div class="highlight"><pre><span class="k">class</span> <span class="nc">ArrayElement</span><span class="o">(</span>
  <span class="k">val</span> <span class="n">contents</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>  <span class="c1">// could be: 'var', 'private', 'protected', 'override'</span>
<span class="o">)</span>
</pre></div>

<p><strong>232 -</strong> You pass an argument to the superconstructor by placing it in parentheses following the name of the superclass:</p>

<div class="highlight"><pre><span class="k">class</span> <span class="nc">LineElement</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ArrayElement</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">width</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>  <span class="c1">// 'override' mandatory for overrides of concrete members</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">height</span> <span class="k">=</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div>

<p><strong>238 -</strong> If you want to disallow for a method to be overridden or for a class to be subclassed, use the keyword <strong>final</strong> (e.g. <code>final class ...</code> or <code>final def ...</code>)<br><strong>240 - <code>++</code></strong> operator is used to concatenate two arrays<br><strong>241 - <code>zip</code></strong> is used to pair two arrays (make <code>Tuple2</code>s), dropping the elements from the longer array that don't have corresponding elements in the shorter array, so:</p>

<div class="highlight"><pre><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">zip</span> <span class="nc">Array</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">)</span> <span class="c1">// will evaluate to</span>
<span class="nc">Array</span><span class="o">((</span><span class="mi">1</span><span class="o">,</span> <span class="s">"a"</span><span class="o">),</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="s">"b"</span><span class="o">))</span>

<span class="c1">// 'zip' usage example</span>
<span class="k">def</span> <span class="n">beside</span><span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Element</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">ArrayElement</span><span class="o">(</span>
    <span class="k">for</span><span class="o">(</span>
      <span class="o">(</span><span class="n">line1</span><span class="o">,</span> <span class="n">line2</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="k">this</span><span class="o">.</span><span class="n">contents</span> <span class="n">zip</span> <span class="n">that</span><span class="o">.</span><span class="n">contents</span>  <span class="c1">// new Tuple2 for each iteration</span>
    <span class="o">)</span> <span class="k">yield</span> <span class="n">line1</span> <span class="o">+</span> <span class="n">line2</span>
  <span class="o">)</span>
</pre></div>

<p><strong>242 - <code>mkString</code></strong> is defined for all sequences (including arrays). <code>toString</code> is called on each element of the sequence. Separator is inserted between every two elems:</p>

<div class="highlight"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">contents</span> <span class="n">mkString</span> <span class="s">"\n"</span>
</pre></div>

<h3>
<a name="scalas-hierarchy" class="anchor" href="#scalas-hierarchy"><span class="octicon octicon-link"></span></a>Scala's Hierarchy</h3>

<p><strong>250 -</strong> In Scala hierarchy, <strong>scala.Null</strong> and <strong>scala.Nothing</strong> are the subclasses of every class (thus the name <strong>bottom classes</strong>), just as <strong>Any</strong> is the superclass of every other class<br><strong>250 -</strong> <code>Any</code> contains methods:</p>

<blockquote>
<p><code>==</code>...............<code>final</code>, same as <code>equals</code> (except for Java boxed numeric types)<br><code>!=</code>...............<code>final</code>, same as <code>!equals</code><br><code>equals</code>.........used by the subclasses to override equality<br><code>##</code>................same as <code>hashCode</code><br><code>hashCode</code><br><code>toString</code>  </p>
</blockquote>

<p><strong>251 -</strong> Class <code>Any</code> has two subclasses:</p>

<blockquote>
<p><code>AnyVal</code>      the parent class of every built-in <strong>value class</strong> in Scala<br><code>AnyRef</code>      the base class of all <strong>reference classes</strong> in Scala</p>

<p>Built-in <strong>value classes</strong>: <code>Byte</code>, <code>Short</code>, <code>Char</code>, <code>Int</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Boolean</code> and <code>Unit</code></p>

<ul>
<li>represented (except <code>Unit</code>) as Java primitives at runtime</li>
<li>both <code>abstract</code> and <code>final</code>, so you cannot instantiate them with <code>new</code>
</li>
<li>the instances of these classes are all written as literals (e.g. <code>5</code> is <code>Int</code>) </li>
<li>
<code>Unit</code> corresponds to Java's <code>void</code> and has a single instance value, <code>()</code>
</li>
<li>Implicit conversion from <code>Int</code> to <code>RichInt</code> happens when a method that only exists in <code>RichInt</code> is called on <code>Int</code>. Similar <strong>Booster classes</strong> exist for other value types</li>
</ul>
<p>All <strong>reference classes</strong> inherit from a special marker trait called <code>ScalaObject</code></p>
</blockquote>

<p><strong>254 -</strong> Scala stores integers the same way as Java, as 32-bit words, but it uses the <em>backup</em> class <code>java.lang.Integer</code> to be used whenever an int has to be seen as object<br><strong>256 -</strong> For <strong>reference equality</strong>, <code>AnyRef</code> class has <code>eq</code> method, which cannot be overridden (behaves like <code>==</code> in Java for reference types). Opposite of <code>eq</code> is <code>ne</code><br><strong>256 - <code>Null</code></strong> is a subclass of every reference class (i.e. class that inherits from <code>AnyRef</code>). It's not compatible with <em>value types</em> (<code>val i: Int = Null // type mismatch</code>)<br><strong>257 - <code>Nothing</code></strong> is a subtype of every other type (of <em>Null</em> also). There are no values of this type, it's used primarily to signal abnormal termination:</p>

<div class="highlight"><pre><span class="k">def</span> <span class="n">error</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span><span class="o">(</span><span class="n">message</span><span class="o">)</span>

<span class="c1">// because of its position in type hierarchy, you can use it like this:</span>
<span class="k">def</span> <span class="n">divide</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>     <span class="c1">// must return 'Int'</span>
  <span class="k">if</span><span class="o">(</span><span class="n">y</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span> <span class="n">x</span> <span class="o">/</span> <span class="n">y</span>                    <span class="c1">// Returns 'Int'</span>
  <span class="k">else</span> <span class="n">error</span><span class="o">(</span><span class="s">"can't divide by zero"</span><span class="o">)</span>  <span class="c1">// 'Nothing' is a subtype of 'Int'</span>
</pre></div>

<h3>
<a name="traits" class="anchor" href="#traits"><span class="octicon octicon-link"></span></a>Traits</h3>

<p><strong>258 - Trait</strong> encapsulates method and field definitions, which can then be reused by mixing them into classes</p>

<blockquote>
<ul>
<li>
<em>trait</em> can be mixed in using keywords <code>extends</code> or <code>with</code>. The difference is that, by using <code>extends</code>, you implicitly inherit the trait's superclass (<code>AnyRef</code> if a trait has no explicit superclass)</li>
<li>
<em>trait</em> also defines a type which can be used as a regular class</li>
<li>if you want to mix a trait into a class that explicitly extends a superclass, use <code>extends</code> to indicate the superclass and <code>with</code> to mix in the trait:</li>
<li>to mix in multiple traits using <code>with</code>:</li>
<li>a class can override trait's members (polymorphism works the same way as with regular classes):</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">class</span> <span class="nc">Animal</span>
<span class="k">class</span> <span class="nc">Frog</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="k">with</span> <span class="nc">Philosophical</span> <span class="k">with</span> <span class="nc">HasLegs</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="s">"green"</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">philosophize</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"It ain't easy being "</span> <span class="o">+</span> <span class="n">toString</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p><strong>261 -</strong> <em>Traits</em> can declare fields and maintain state (unlike Java interfaces). You can do anything in a trait definition that you can do with a class definition, with two exceptions:</p>

<blockquote>
<ul>
<li>traits cannot have <em>class parameters</em>
</li>
<li>traits have dynamically bound <code>super</code> (unlike statically bound <code>super</code> in classes)

<ul>
<li>the implementation to invoke is determined each time the trait is mixed into class</li>
<li>key to allowing traits to work as <em>stackable modifications</em>
</li>
</ul>
</li>
</ul>
</blockquote>

<p><strong>266 - Ordered trait</strong> allows you to implement all comparison operations on a class</p>

<blockquote>
<ul>
<li>requires you to specify a <em>type parameter</em> when you mix it in (<code>extends Ordered[TypeYouCompare]</code>)</li>
<li>requires you to implement the <code>compare</code> method, which should return <code>Int</code>, <code>0</code> if the object are the same, negative if receiver is less than the argument and positive if the receiver is greater than the argument</li>
<li>does not provide <code>equals</code> (because of "type erasure")</li>
</ul>
</blockquote>

<p><strong>267 - Stackable modifications</strong></p>

<blockquote>
<ul>
<li>traits let you modify the methods of a class in a way that allows you to stack those modifications together, by mixing in multiple traits</li>
<li>when a trait extends a superclass, it means that the trait can only be mixed in in classes that also extend the same superclass</li>
<li>traits can have <code>abstract override</code> methods because of dynamically bound <code>super</code> (the call works if the trait is mixed in after another trait or class has already given a concrete definition to that method)</li>
<li>when you instantiate a class with <code>new</code> Scala takes the class and all of its inherited classes and traits and puts them in a single, <em>linear</em> order, thus the name <strong>linearization</strong>. Then, when you call <code>super</code> inside one of those classes, the invoked method is the first implementation up the chain (right in the image bellow)</li>
<li>the <strong>order of mixins</strong> is significant. Traits further to the right take effect first</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// mixing in a trait when instantiating with 'new' (no need to create a new class)</span>
<span class="k">val</span> <span class="n">queue</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BasicIntQueue</span> <span class="k">with</span> <span class="nc">Doubling</span> <span class="k">with</span> <span class="nc">Filtering</span>  <span class="c1">// filtering is applied first</span>
<span class="c1">// queue: BasicIntQueue with Doubling with Filtering = $anon$1@5fa12d</span>

<span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>  <span class="c1">// passes the Filtering and then gets doubled with Doubling trait</span>
<span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="o">(-</span><span class="mi">1</span><span class="o">)</span>  <span class="c1">// not placed in the queue (negative number filter trait applied)</span>
<span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="o">()</span>  <span class="c1">// Int = 20</span>
</pre></div>

<p><img src="https://github.com/mbonaci/scala/blob/master/resources/Scala-linearization-example.png?raw=true" alt="Scala Linearization"><img src="https://github.com/mbonaci/scala/blob/master/resources/Scala-linearization.png?raw=true" alt="Linearization order"></p>

<p><strong>275 - When to use a <em>trait</em> and when an <em>abstract class</em></strong></p>

<blockquote>
<ul>
<li>if the behavior will not be reused make a concrete class</li>
<li>if it might be used in multiple, unrelated classes, use a trait</li>
<li>if you want to inherit from it in Java code, use an abstract class

<ul>
<li>a trait with only abstract members translates to Java <code>interface</code>
</li>
</ul>
</li>
<li>if you plan to distribute it in compiled form and you expect others to write classes that inherit from your code, use an abstract class (when a trait gains or loses a member, any class that inherit from it must be recompiled)</li>
<li>if efficiency is very, very important, use a class (in Java, a virtual method invocation of a class member is faster than an interface method invocation)</li>
<li>if none of the above fits your case, use trait</li>
</ul>
</blockquote>

<h3>
<a name="packages-and-imports" class="anchor" href="#packages-and-imports"><span class="octicon octicon-link"></span></a>Packages and Imports</h3>

<p><strong>278 - Packages</strong> can be used like in C#: <code>package pkg_name { // source... }</code>, with more packages in a single source file. Also, they can be nested in one another</p>

<blockquote>
<ul>
<li>a package represents a scope, whose contents is accessed relative to current location</li>
<li>a top level package that's outside all packages any user can write is called <code>_root_</code>
</li>
<li>all names accessible outside packages can be access from inside the package in the same way</li>
<li>if you stick with one package per file then Java package rules apply</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// this</span>
<span class="k">package</span> <span class="nn">one</span>
<span class="k">package</span> <span class="nn">two</span>
<span class="c1">// is just syntactic sugar for this</span>
<span class="k">package</span> <span class="nn">one</span> <span class="o">{</span>
  <span class="k">package</span> <span class="nn">two</span> <span class="o">{</span>

<span class="c1">// to import the package (not a specific package member)</span>
<span class="k">import</span> <span class="nn">one.two</span>  <span class="c1">// and then use objects like this: `two.Two.method`</span>

<span class="c1">// which is a shorthand for 'Import selector' syntax:</span>
<span class="k">import</span> <span class="nn">one.</span><span class="o">{</span><span class="n">two</span><span class="o">}</span>

<span class="c1">// to access all members of a package (underscore instead of Java's star)</span>
<span class="k">import</span> <span class="nn">one.two.three._</span>  <span class="c1">// could also be written as `import one.two.three.{_}`</span>

<span class="c1">// to use import with objects and classes</span>
<span class="k">def</span> <span class="n">showOne</span><span class="o">(</span><span class="n">one</span><span class="k">:</span> <span class="kt">One</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// imports all members of its parameter `one`, of class `One`</span>
  <span class="k">import</span> <span class="nn">one._</span>  <span class="c1">// use imports wherever you like</span>
  <span class="n">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">"s are the best"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// to import more than one specific package member use 'Import selectors'</span>
<span class="k">import</span> <span class="nn">one.</span><span class="o">{</span><span class="nc">One1</span><span class="o">,</span> <span class="nc">One2</span><span class="o">}</span>

<span class="c1">// to rename import</span>
<span class="k">import</span> <span class="nn">one.</span><span class="o">{</span><span class="nc">One1</span> <span class="k">=&gt;</span> <span class="nc">First</span><span class="o">,</span> <span class="nc">One2</span><span class="o">}</span>  <span class="c1">// `One1` is accessed as `First` (or `one.One1`)</span>

<span class="c1">// to import all members and rename one of them</span>
<span class="k">import</span> <span class="nn">one.two.</span><span class="o">{</span><span class="nc">Two</span> <span class="k">=&gt;</span> <span class="nc">Second</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>  <span class="c1">// catch-all must come last in the list</span>

<span class="c1">// to import all members except one (useful for ambiguities)</span>
<span class="k">import</span> <span class="nn">one.two.</span><span class="o">{</span><span class="nc">Two</span> <span class="k">=&gt;</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">}</span>  <span class="c1">// excludes `Two`</span>

<span class="c1">// implicit imports (later imports overshadow earlier ones)</span>
<span class="k">import</span> <span class="nn">java.lang._</span>
<span class="k">import</span> <span class="nn">scala._</span>
<span class="k">import</span> <span class="nn">Predef._</span>
</pre></div>

<p><strong>288 - Access modifiers</strong> available in Scala: <code>Private</code> and <code>Protected</code></p>

<blockquote>
<ul>
<li>outer class's access to <code>private</code> members of its inner class is forbidden</li>
<li>Java allows access to <code>protected</code> members to classes in the same package even if they don't inherit from the class that declares protected members. Scala don't</li>
</ul>
</blockquote>

<p><strong>289 - Access qualifiers</strong></p>

<blockquote>
<ul>
<li>a modifier in the form <code>private[X]</code> or <code>protected[X]</code> means that access is applied "up to X", where <code>X</code> designates some enclosing package, class or a singleton</li>
<li>
<strong>object-private</strong> <code>private[this]</code> means that access is allowed only from within the the object that contains definition itself, not its instances (<code>ObjName.privMember</code> will fail in this case)</li>
</ul>
</blockquote>

<p><strong>291 - Companion objects</strong> or <strong>Singletons</strong></p>

<blockquote>
<ul>
<li>a class shares all its access rights with its companion object and vice versa</li>
<li>
<code>protected</code> modifier makes no sense since <em>Companion objects</em> cannot be subclassed</li>
</ul>
</blockquote>

<p><strong>292 - Package objects</strong></p>

<blockquote>
<ul>
<li>any kind of definition you can put in a class can go in a <em>package object</em>
</li>
<li>each package is allowed to have one <em>package object</em>
</li>
<li>frequently used to hold package-wide <em>type aliases</em> and <em>implicit conversions</em>
</li>
<li>the top level <code>scala</code> package has a package object, which is available to all Scala code</li>
<li>they are compiled to <code>package.class</code> file in that package's directory</li>
<li>access is the same as for any other package element:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// in file 'one/package.scala'</span>
<span class="k">package</span> <span class="nn">object</span> <span class="n">one</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">showSomeone</span><span class="o">(</span><span class="n">someone</span><span class="k">:</span> <span class="kt">Someone</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">import</span> <span class="nn">someone._</span>
    <span class="n">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">", I am"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// in file View.scala</span>
<span class="k">package</span> <span class="nn">view</span>
<span class="k">import</span> <span class="nn">one.Someone</span>  <span class="c1">// class defined in package 'one'</span>
<span class="k">import</span> <span class="nn">one.showSomeone</span>
<span class="k">object</span> <span class="nc">ViewDialog</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">for</span><span class="o">(</span><span class="n">someone</span> <span class="k">&lt;-</span> <span class="nc">Someone</span><span class="o">.</span><span class="n">dialog</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">showSomeone</span><span class="o">(</span><span class="n">someone</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h3>
<a name="assertions-and-unit-testing" class="anchor" href="#assertions-and-unit-testing"><span class="octicon octicon-link"></span></a>Assertions and Unit Testing</h3>

<p><strong>295 - Assertions</strong></p>

<blockquote>
<ul>
<li>written as calls of a predefined method <code>assert</code> (defined in the <code>Predef</code> singleton)</li>
<li>assertions and ensuring checks can be enabled/disabled with JVM's <code>-ea</code>/<code>-da</code> flags</li>
<li>
<code>assert</code> methods and <code>ensuring</code> convenience methods:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="n">assert</span><span class="o">(</span><span class="n">condition</span><span class="o">)</span> <span class="c1">// throws AssertionError</span>
<span class="n">assert</span><span class="o">(</span><span class="n">condition</span><span class="o">,</span> <span class="n">explanation</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="c1">// AssertionError contains explanation.toString</span>

<span class="c1">// 'ensuring' example</span>
<span class="k">def</span> <span class="n">widen</span><span class="o">(</span><span class="n">w</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Element</span> <span class="o">=</span>
  <span class="k">if</span><span class="o">(</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">width</span><span class="o">)</span> <span class="k">this</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">left</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">' '</span><span class="o">,</span> <span class="o">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">width</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">right</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="sc">' '</span><span class="o">,</span> <span class="n">w</span> <span class="o">-</span> <span class="n">width</span> <span class="o">-</span> <span class="n">left</span><span class="o">.</span><span class="n">width</span><span class="o">,</span> <span class="n">height</span><span class="o">)</span>
    <span class="n">left</span> <span class="n">beside</span> <span class="k">this</span> <span class="n">beside</span> <span class="n">right</span>
  <span class="o">}</span> <span class="n">ensuring</span><span class="o">(</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="k">_</span><span class="o">.</span><span class="n">width</span><span class="o">)</span>  <span class="c1">// takes a predicate function</span>
                            <span class="c1">// when invoked, it passes return type ('Element') to the </span>
                            <span class="c1">// predicate function that returns 'Boolean'</span>
<span class="c1">// if predicate evaluates to 'true', 'ensuring' results with 'Element' on which it was invoked</span>
<span class="c1">// since this is the last expression of the method, 'widen' returns the 'Element'</span>
<span class="c1">// throws AssertionError if predicate returns 'false'</span>
</pre></div>

<p><strong>297 - Unit testing</strong></p>

<blockquote>
<ul>
<li><p>there are many options for unit testing in Scala, e.g. Java <code>JUnit</code> and <code>TestNG</code> tools or tools written in Scala, e.g. <code>ScalaTest</code>, <code>specs</code> and <code>ScalaCheck</code>  </p></li>
<li>
<p><a href="http://www.scalatest.org">ScalaTest</a></p>

<ul>
<li>the simplest way to test with <em>ScalaTest</em> is to extend <code>org.scalatest.Suite</code> and define test methods in those classes. Methods start with <code>test</code>:</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">import</span> <span class="nn">org.scalatest.Suite</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">class</span> <span class="nc">ElementSuite</span> <span class="k">extends</span> <span class="nc">Suite</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">testUniformElement</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">e</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="-Symbol">'x</span><span class="err">'</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// ScalaTest offers a trait 'FunSuite', which overrides 'execute'</span>
<span class="c1">// so you can define tests as function values, rather than methods</span>
<span class="k">class</span> <span class="nc">ElementSuite</span> <span class="k">extends</span> <span class="nc">FunSuite</span> <span class="o">{</span>
  <span class="c1">// test is a method in FunSuite which is invoked by ElementSuite's primary constructor</span>
  <span class="n">test</span><span class="o">(</span><span class="s">"elem result should have passed width"</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// name of test</span>
    <span class="c1">// curly - function passed as by-name param to 'test', which registers it for later execution</span>
    <span class="k">val</span> <span class="n">e</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="-Symbol">'x</span><span class="err">'</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">width</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>  <span class="c1">// if fails you see error message with line number</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// triple equals, if assert fails, returns nice error msg. e.g. "3 did not equal 2":</span>
<span class="n">assert</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">width</span> <span class="o">===</span> <span class="mi">2</span><span class="o">)</span>

<span class="c1">// alternatively, 'expect' can be used:</span>
<span class="n">expect</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// yields "expected 2, but got 3" in the test failure report</span>
  <span class="n">e</span><span class="o">.</span><span class="n">width</span>
<span class="o">}</span>

<span class="c1">// if you want to check whether a method throws expected exception use 'intercept'</span>
<span class="c1">// if the code does not throw expected exception or doesn't throw at all</span>
<span class="c1">// 'TestFailedException' is thrown, along with a helpful error msg</span>
<span class="n">intercept</span><span class="o">[</span><span class="kt">IllegalArgumentException</span><span class="o">]</span> <span class="o">{</span>  <span class="c1">// returns caught exception</span>
  <span class="n">elem</span><span class="o">(</span><span class="-Symbol">'x</span><span class="err">'</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>although ScalaTest includes Runner application, you can also run Suite directly from the Scala interpreter by invoking <code>execute</code> on it (trait Suite's <code>execute</code> method uses reflection to discover its test methods and invoke them):</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="o">(</span><span class="k">new</span> <span class="nc">ElementSuite</span><span class="o">).</span><span class="n">execute</span><span class="o">()</span>
<span class="nc">Test</span> <span class="nc">Starting</span> <span class="o">-</span> <span class="nc">ElementSuite</span><span class="o">.</span><span class="n">testUniformElement</span>
<span class="nc">Test</span> <span class="nc">Succeeded</span> <span class="o">-</span> <span class="nc">ElementSuite</span><span class="o">.</span><span class="n">testUniformElement</span>
</pre></div>

<blockquote>
<ul>
<li>in <strong>BDD</strong>, the emphasis is on writing human-readable specifications of the expected code behavior, along with the accompanying tests that verify that behavior</li>
<li>for that purpose, ScalaTest includes several traits: Spec, WordSpec, FlatSpec and FeatureSpec</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">import</span> <span class="nn">org.scalatest.FlatSpec</span>
<span class="k">import</span> <span class="nn">org.scalatest.matchers.ShouldMatchers</span>
<span class="k">import</span> <span class="nn">Element.elem</span>

<span class="k">class</span> <span class="nc">ElementSpec</span> <span class="k">extends</span> <span class="nc">FlatSpec</span> <span class="k">with</span> <span class="nc">ShouldMatchers</span> <span class="o">{</span>
  <span class="s">"A UniformElement"</span> <span class="n">should</span> <span class="s">"have a width equal to the passed value"</span> <span class="n">in</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">e</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="-Symbol">'x</span><span class="err">'</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">e</span><span class="o">.</span><span class="n">width</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="mi">2</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">it</span> <span class="n">should</span> <span class="s">"have a height equal to the passed value"</span> <span class="n">in</span> <span class="o">{</span>  <span class="c1">// 'specifier clause'</span>
    <span class="k">val</span> <span class="n">e</span> <span class="k">=</span> <span class="n">elem</span><span class="o">(</span><span class="-Symbol">'x</span><span class="err">'</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="n">e</span><span class="o">.</span><span class="n">height</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="mi">3</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="n">it</span> <span class="n">should</span> <span class="s">"throw an IAE if passed a negative width"</span> <span class="n">in</span> <span class="o">{</span>  <span class="c1">// or 'must' or 'can'</span>
    <span class="n">evaluating</span> <span class="o">{</span>
      <span class="n">elem</span><span class="o">(</span><span class="-Symbol">'x</span><span class="err">'</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
    <span class="o">}</span> <span class="n">should</span> <span class="n">produce</span> <span class="o">[</span><span class="kt">IllegalArgumentException</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h3>
<a name="case-classes-and-pattern-matching" class="anchor" href="#case-classes-and-pattern-matching"><span class="octicon octicon-link"></span></a>Case Classes and Pattern Matching</h3>

<p><strong>310 - Case classes</strong></p>

<blockquote>
<ul>
<li>for classes with <code>case</code> modifier, Scala compiler adds some syntactic sugar:

<ul>
<li>a factory method with the same name as the class, which allows you to create new object without keyword <code>new</code> (<code>val m = MyCls("x")</code>)</li>
<li>all class parameters implicitly get a <code>val</code> prefix, so they are made into fields</li>
<li>compiler adds "natural" implementations of methods <code>toString</code>, <code>hashCode</code> and <code>equals</code>, which will print, hash and compare a whole tree of the class and its arguments</li>
<li>
<code>copy</code> method is added to the class (used to create modified copies). To use it, you specify the changes by using <em>named parameters</em> and for any param you don't specify, the original value is used:</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Var</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Number</span><span class="o">(</span><span class="n">num</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">arg</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">operator</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Expr</span>
<span class="k">val</span> <span class="n">op</span> <span class="k">=</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"+"</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="nc">Var</span><span class="o">(</span><span class="s">"x"</span><span class="o">))</span>
<span class="n">op</span><span class="k">:</span> <span class="kt">BinOp</span> <span class="o">=</span> <span class="nc">BinOp</span><span class="o">(+,</span><span class="nc">Number</span><span class="o">(</span><span class="mf">1.0</span><span class="o">),</span><span class="nc">Var</span><span class="o">(</span><span class="n">x</span><span class="o">))</span>

<span class="c1">// copy method example</span>
<span class="n">op</span><span class="o">.</span><span class="n">copy</span><span class="o">(</span><span class="n">operator</span> <span class="k">=</span> <span class="s">"-"</span><span class="o">)</span>
<span class="c1">// BinOp = BinOp(-,Number(1.0),Var(x))</span>
</pre></div>

<p><strong>312 - Pattern matching</strong></p>

<blockquote>
<ul>
<li>the biggest advantage of <em>case classes</em> is that they support <em>pattern matching</em>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// written in the form of 'selector match {alternatives}'</span>
<span class="k">def</span> <span class="n">simplifyTop</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span>  <span class="k">=&gt;</span> <span class="n">e</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"+"</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"*"</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">expr</span>
<span class="o">}</span>

<span class="c1">// the right hand side can be empty (the result is 'Unit'):</span>
<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
</pre></div>

<blockquote>
<ul>
<li>
<code>match</code> expression is evaluated by trying each of the patterns in the order they are written. The first pattern that matches is selected and the part following the fat arrow is executed</li>
<li>
<code>match</code> <em>is an expression</em> in Scala (always results in a value)</li>
<li>there is <em>no <em>fall through</em></em> behavior into the next case</li>
<li>if <em>none of the patterns match</em>, an exception <code>MatchError</code> is thrown</li>
</ul>
</blockquote>

<p><strong>315 - Constant patterns</strong></p>

<blockquote>
<ul>
<li>matches only itself (comparison is done using <code>==</code>)</li>
<li>any literal, <code>val</code> or singleton object can be used as a constant</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">def</span> <span class="n">describe</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="mi">5</span> <span class="k">=&gt;</span> <span class="s">"five"</span>
  <span class="k">case</span> <span class="kc">true</span> <span class="k">=&gt;</span> <span class="s">"truth"</span>
  <span class="k">case</span> <span class="s">"hello"</span> <span class="k">=&gt;</span> <span class="s">"hi"</span>
  <span class="k">case</span> <span class="nc">Nil</span> <span class="k">=&gt;</span> <span class="s">"the empty list"</span>  <span class="c1">// built-in singleton</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"something unexpected"</span>
<span class="o">}</span>
</pre></div>

<p><strong>316 - Variable patterns</strong></p>

<blockquote>
<ul>
<li>matches any object, like wildcard</li>
<li>unlike the wildcard, Scala binds the variable to whatever the object is and then a variable refers to that value in the right hand side of the <code>case</code> clause</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">import</span> <span class="nn">math.</span><span class="o">{</span><span class="n">E</span><span class="o">,</span> <span class="nc">Pi</span><span class="o">}</span>

<span class="k">val</span> <span class="n">pi</span> <span class="k">=</span> <span class="n">math</span><span class="o">.</span><span class="nc">Pi</span>

<span class="n">E</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="mi">0</span> <span class="k">=&gt;</span> <span class="s">"zero"</span>
  <span class="k">case</span> <span class="nc">Pi</span> <span class="k">=&gt;</span> <span class="s">"strange! "</span> <span class="o">+</span> <span class="n">E</span> <span class="o">+</span> <span class="s">" cannot be "</span> <span class="o">+</span> <span class="nc">Pi</span>
  <span class="k">case</span> <span class="n">`pi`</span> <span class="k">=&gt;</span> <span class="s">"strange? Pi = "</span> <span class="o">+</span> <span class="n">pi</span>  <span class="c1">// will be treated as constant ('val pi')</span>
  <span class="k">case</span> <span class="n">pi</span> <span class="k">=&gt;</span> <span class="s">"That could be anything: "</span> <span class="o">+</span> <span class="n">pi</span>  <span class="c1">// not constant pattern ('val pi'). Variable pattern!</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"What?"</span>  <span class="c1">// Compiler reports "Unreachable code" error</span>
<span class="o">}</span>
<span class="cm">/*</span>
<span class="cm"> * How does Scala know whether 'Pi' is a constant from 'scala.math' and not a variable?</span>
<span class="cm"> * A simple lexical rule is applied:</span>
<span class="cm"> *   - If a name starts with a lowercase letter Scala treats it as a variable pattern.</span>
<span class="cm"> *   - All other references are treated as constants</span>
<span class="cm"> *   - With exception of fields: 'this.pi' and 'obj.pi', and lowercase names in back ticks</span>
<span class="cm"> */</span>
</pre></div>

<p><strong>314 - Wildcard patterns</strong></p>

<blockquote>
<ul>
<li>
<code>_</code> matches every value, but it doesn't result with a variable</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// in this example, since we don't care about elements of a binary operation</span>
<span class="c1">// only whether it's a binary operation or not, we can use wildcard pattern:</span>
<span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">expr</span> <span class="o">+</span> <span class="s">"is a binary operation"</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"It's something entirely different"</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>

<p><strong>318 - Constructor patterns</strong></p>

<blockquote>
<ul>
<li>Scala first checks whether the object is a member of the named <em>case class</em> and then checks that the constructor params of the object match the patterns in parentheses</li>
<li>
<strong>Deep matching</strong> means that it looks for patterns arbitrarily deep</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// first checks that the top level object is a 'BinOp', then whether the third</span>
<span class="c1">// constructor param is a 'Number' and finally that the value of that number is '0'</span>
<span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"+"</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"a deep match"</span><span class="o">)</span>  <span class="c1">// checks 3 levels deep</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
<span class="o">}</span>
</pre></div>

<p><strong>318 - Sequence patterns</strong></p>

<blockquote>
<ul>
<li>
<code>List</code> and <code>Array</code> can be matched against, just like <em>case classes</em>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// checks for 3 element list that starts with zero:</span>
<span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"zero starting list of three elements"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// to check against the sequence without specifying how long it must be:</span>
<span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"zero starting list"</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"any list"</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>

<p><strong>319 - Tuple patterns</strong></p>

<div class="highlight"><pre><span class="o">(</span><span class="s">"a "</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="s">"-tuple"</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"matched "</span> <span class="o">+</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span><span class="o">)</span>  <span class="c1">// matched a 3-tuple</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
  <span class="o">}</span>
</pre></div>

<p><strong>319 - Typed patterns</strong></p>

<blockquote>
<ul>
<li>used for convenient type checks and type casts</li>
</ul>
</blockquote>

<div class="highlight"><pre>  <span class="k">def</span> <span class="n">generalSize</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span>  <span class="c1">// type check + type cast - 's' can only be a 'String'</span>
    <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="k">_</span>, <span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">size</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="mi">1</span>
  <span class="o">}</span>                                               <span class="c1">//&gt; generalSize: (x: Any)Int</span>

  <span class="n">generalSize</span><span class="o">(</span><span class="s">"aeiou"</span><span class="o">)</span>                            <span class="c1">//&gt; Int = 5</span>
  <span class="n">generalSize</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="-Symbol">'a</span><span class="err">'</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="-Symbol">'b</span><span class="err">'</span><span class="o">))</span>            <span class="c1">//&gt; Int = 2</span>
  <span class="n">generalSize</span><span class="o">(</span><span class="n">math</span><span class="o">.</span><span class="nc">Pi</span><span class="o">)</span>                            <span class="c1">//&gt; Int = -1</span>

<span class="c1">// generally, to test whether expression is an instance of a type:</span>
<span class="n">expr</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>  <span class="c1">// member of class 'Any'</span>
<span class="c1">// to cast</span>
<span class="n">expr</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>  <span class="c1">// member of class 'Any'</span>

<span class="k">def</span> <span class="n">isIntToIntMap</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="c1">// non-variable type Int is unchecked since it's eliminated by erasure</span>
  <span class="k">case</span> <span class="n">m</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="n">isIntToIntMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">))</span>              <span class="c1">//&gt; Boolean = true</span>
<span class="n">isIntToIntMap</span><span class="o">(</span><span class="nc">Map</span><span class="o">(</span><span class="s">"aei"</span> <span class="o">-&gt;</span> <span class="s">"aei"</span><span class="o">))</span>              <span class="c1">//&gt; Boolean = true !!!</span>

<span class="c1">// the same thing works fine with arrays since their type is preserved with their value</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Type erasure</strong>

<ul>
<li>erasure model of generics, like in Java, means that no information about type arguments is maintained at runtime. Consequently, there is no way to determine at runtime whether a given Map object has been created with two Int arguments, rather than with arguments of any other type. All the system can do is determine that a value is a Map of some arbitrary type parameters</li>
</ul>
</li>
</ul>
</blockquote>

<p><strong>323 - Variable binding</strong></p>

<blockquote>
<ul>
<li>allows you to, if the pattern matches, assign a variable to a matched object</li>
<li>the syntax is `var_name @ some_pattern'</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">"abs"</span><span class="o">,</span> <span class="n">e</span> <span class="k">@</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">"abs"</span><span class="o">,</span> <span class="k">_</span><span class="o">))</span> <span class="k">=&gt;</span> <span class="n">e</span>  <span class="c1">// if matched, 'e' will be 'UnOp("abs", _)'</span>
</pre></div>

<p><strong>324 - Pattern guards</strong></p>

<blockquote>
<ul>
<li>in some circumstances, syntactic pattern matching is not precise enough</li>
<li>a pattern guard comes after a pattern and starts with an <code>if</code>
</li>
<li>can be arbitrary boolean expression and typically refers to pattern variables</li>
<li>the pattern matches only if the guard evaluates to <code>true</code>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// match only positive integers</span>
<span class="k">case</span> <span class="n">n</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">if</span> <span class="err">0</span> <span class="kt">&lt;</span> <span class="kt">n</span> <span class="o">=&gt;</span> <span class="n">n</span> <span class="o">+</span> <span class="s">" is positive"</span>
<span class="c1">// match only strings starting with the letter ‘a’</span>
<span class="k">case</span> <span class="n">s</span><span class="k">:</span> <span class="kt">String</span> <span class="kt">if</span> <span class="kt">s</span><span class="o">(</span><span class="err">0</span><span class="o">)</span> <span class="o">=</span><span class="k">=</span> <span class="-Symbol">'a</span><span class="err">'</span> <span class="k">=&gt;</span> <span class="n">s</span> <span class="o">+</span> <span class="s">" starts with letter 'a'"</span>
</pre></div>

<blockquote>
<ul>
<li>e.g. if you'd like to transform <code>x + x</code> to <code>2 * x</code> with patterns:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// this won't work, since a pattern variable may only appear once in a pattern:</span>
<span class="k">def</span> <span class="n">simplifyAdd</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"+"</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"*"</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>  <span class="c1">// x is already defined as value x</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">e</span>
<span class="o">}</span>

<span class="c1">// so instead:</span>
  <span class="k">def</span> <span class="n">simplifyAdd</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span> <span class="k">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
    <span class="c1">// matches only a binary expression with two equal operands</span>
    <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"+"</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">=&gt;</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"*"</span><span class="o">,</span> <span class="n">x</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">2</span><span class="o">))</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">e</span>
  <span class="o">}</span>                     <span class="c1">//&gt; simplifyAdd: (e: Expr)Expr</span>

  <span class="k">val</span> <span class="n">add</span> <span class="k">=</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"+"</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">24</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">24</span><span class="o">))</span>
                        <span class="c1">//&gt; add  : BinOp = BinOp(+,Number(24.0),Number(24.0))</span>
  <span class="k">val</span> <span class="n">timesTwo</span> <span class="k">=</span> <span class="n">simplifyAdd</span><span class="o">(</span><span class="n">add</span><span class="o">)</span>
                        <span class="c1">//&gt; timesTwo  : Expr = BinOp(*,Number(24.0),Number(2.0))</span>
</pre></div>

<p><strong>325 - Pattern overlaps</strong></p>

<blockquote>
<ul>
<li>patterns are tried in the order in which they are written</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// recursively call itself until no more simplifications are possible</span>
<span class="k">def</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">expr</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">Expr</span> <span class="o">=</span> <span class="n">expr</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="n">e</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="c1">// '-' is its own inverse</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"+"</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="c1">// '0' is a neutral element for '+'</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"*"</span><span class="o">,</span> <span class="n">e</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">=&gt;</span>
    <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">)</span> <span class="c1">// '1' is a neutral element for '*'</span>
  <span class="k">case</span> <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">e</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">UnOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">e</span><span class="o">))</span>
  <span class="k">case</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">l</span><span class="o">),</span> <span class="n">simplifyAll</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">expr</span>
<span class="o">}</span>

<span class="k">implicit</span> <span class="k">def</span> <span class="n">intToNumber</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Number</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">numberToInt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Number</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">num</span><span class="o">.</span><span class="n">toInt</span>

<span class="k">val</span> <span class="n">allMin</span> <span class="k">=</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="nc">UnOp</span><span class="o">(</span><span class="s">"-"</span><span class="o">,</span> <span class="mi">4</span><span class="o">))</span>
<span class="k">val</span> <span class="n">allAdd</span> <span class="k">=</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"+"</span><span class="o">,</span> <span class="mi">244</span><span class="o">,</span> <span class="mi">0</span> <span class="o">+</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span>
<span class="k">val</span> <span class="n">allMul</span> <span class="k">=</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"*"</span><span class="o">,</span> <span class="mi">24</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="n">simplifyAll</span><span class="o">(</span><span class="n">allMin</span><span class="o">)</span>   <span class="c1">//&gt; Expr = Number(4.0)</span>
<span class="n">simplifyAll</span><span class="o">(</span><span class="n">allAdd</span><span class="o">)</span>   <span class="c1">//&gt; Expr = Number(244.0)</span>
<span class="n">simplifyAll</span><span class="o">(</span><span class="n">allMul</span><span class="o">)</span>   <span class="c1">//&gt; Expr = Number(24.0)</span>
</pre></div>

<p><strong>326 - Sealed classes</strong></p>

<blockquote>
<ul>
<li>how can you be sure you covered all the cases when using pattern matching, since a new <code>case class</code> may be created in any time, in another compilation unit?</li>
<li>you make the <em>superclass</em> of your <em>case class</em> <code>sealed</code>, which then means that a class cannot have any new subclasses added except the ones in the same file</li>
<li>this way, when using pattern matching, you only need to worry about the subclasses you know of</li>
<li>also, when you match against subclasses of a sealed class, you get the compiler support, which will flag missing combinations of patterns with a warning message:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// if you make 'Expr' class sealed</span>
<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Expr</span>

<span class="c1">// and leave out some patterns when matching</span>
<span class="k">def</span> <span class="n">describe</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">e</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"a num"</span>
  <span class="k">case</span> <span class="nc">Var</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"a var"</span>
<span class="o">}</span>

<span class="cm">/* you'll get a compiler warning:</span>
<span class="cm"> * warning: match is not exhaustive</span>
<span class="cm"> * missing combination  UnOp</span>
<span class="cm"> * missing combination  BinOp</span>
<span class="cm"> *</span>
<span class="cm"> * which is telling you that you might get 'MatchError'</span>
<span class="cm"> * because some possible patterns are not handled</span>
<span class="cm"> */</span>
<span class="c1">// </span>
<span class="c1">// </span>

<span class="c1">// to get rid of the warning, in situations where you're sure that no such pattern</span>
<span class="c1">// will ever appear, throw in the last catch-all case:</span>
<span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">RuntimeException</span>  <span class="c1">// should never happen</span>

<span class="c1">// the same problem can be solved with more elegant solution, without any dead code</span>
<span class="c1">// using 'unchecked' annotation:</span>
<span class="k">def</span> <span class="n">describe</span><span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">Expr</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">@unchecked</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Number</span><span class="o">(</span><span class="k">_</span><span class="o">)</span> <span class="o">...</span>
<span class="o">}</span>
</pre></div>

<p><strong>328 - The Option type</strong></p>

<blockquote>
<ul>
<li>
<code>Option</code> is type for optional values, which can be of two forms:

<ul>
<li>
<code>Some(x)</code>, where <code>x</code> is the actual value</li>
<li>
<code>None</code> object, which represents non-existent value</li>
</ul>
</li>
<li>optional values are produced by some of the standard operations on collections, e.g. the <code>Map</code>'s <code>get</code> method produces <code>Some(value)</code> or <code>None</code> if there was no given key</li>
<li>the common way to distinguish between optional objects is through pattern matching:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">def</span> <span class="n">show</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="n">x</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">s</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="s">"?"</span>
<span class="o">}</span>
</pre></div>

<p><strong>330 - Patterns in variable definitions</strong></p>

<blockquote>
<ul>
<li>patterns could be used for <code>Tuple</code> destructuring:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">myTuple</span> <span class="k">=</span> <span class="o">(</span><span class="mi">123</span><span class="o">,</span> <span class="s">"abc"</span><span class="o">)</span>
<span class="k">val</span> <span class="o">(</span><span class="n">number</span><span class="o">,</span> <span class="n">string</span><span class="o">)</span> <span class="k">=</span> <span class="n">myTuple</span>  <span class="c1">// multiple variables in one assignment</span>
</pre></div>

<blockquote>
<ul>
<li>you can deconstruct a <em>case class</em> with a pattern:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">exp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BinOp</span><span class="o">(</span><span class="s">"*"</span><span class="o">,</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">5</span><span class="o">),</span> <span class="nc">Number</span><span class="o">(</span><span class="mi">10</span><span class="o">))</span>
<span class="k">val</span> <span class="nc">BinOp</span><span class="o">(</span><span class="n">op</span><span class="o">,</span> <span class="n">left</span><span class="o">,</span> <span class="n">right</span><span class="o">)</span> <span class="k">=</span> <span class="n">exp</span>
<span class="cm">/*</span>
<span class="cm"> * op: String = *</span>
<span class="cm"> * left: Expr = Number(5.0)</span>
<span class="cm"> * right: Expr = Number(10.0)</span>
<span class="cm">*/</span>
</pre></div>

<p><strong>331 - Case sequences as partial functions</strong></p>

<blockquote>
<ul>
<li>a sequence of cases can be used anywhere a function literal can</li>
<li>essentially, a case sequence is a function literal, only more general</li>
<li>instead of having a single entry point and list of params, a case sequence has multiple entry points, each with their own list of params</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">withDefault</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="mi">0</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>a sequence of cases gives you a <em>partial function</em>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// this will work for list of 3 elements, but not for empty list</span>
<span class="k">val</span> <span class="n">second</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">y</span>
<span class="o">}</span>  <span class="c1">// warning: match is not exhaustive! missing combination     Nil</span>

<span class="n">second</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>  <span class="c1">// returns 2</span>
<span class="n">second</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>         <span class="c1">// throws MatchError</span>

<span class="cm">/*</span>
<span class="cm"> * type 'List[Int] =&gt; Int' includes all functions from list of integers to integers</span>
<span class="cm"> * type 'PartialFunction[List[Int], Int]' includes only partial functions</span>
<span class="cm"> */</span>

<span class="c1">// to tell the compiler that you know you're working with partial functions:</span>
<span class="k">val</span> <span class="n">second</span><span class="k">:</span> <span class="kt">PartialFunction</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">y</span>
<span class="o">}</span>

<span class="c1">// partial functions have a method 'isDefinedAt':</span>
<span class="n">second</span><span class="o">.</span><span class="n">isDefinedAt</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">))</span>  <span class="c1">// true</span>
<span class="n">second</span><span class="o">.</span><span class="n">isDefinedAt</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>  <span class="c1">// false</span>

<span class="cm">/* </span>
<span class="cm"> * these expressions above get translated by the compiler to a partial function</span>
<span class="cm"> * by translating the patterns twice, once for the implementation of the real function</span>
<span class="cm"> * and once to test whether the function is defined or not</span>
<span class="cm"> */</span>

<span class="c1">// e.g. the function literal</span>
<span class="o">{</span> <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="o">}</span>

<span class="c1">// gets translated to the following partial function value:</span>
<span class="k">new</span> <span class="nc">PartialFunction</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>, <span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">y</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">isDefinedAt</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">y</span> <span class="o">::</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">true</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// the translation takes place whenever the declared type of a function literal is 'PartialFunction'</span>
<span class="c1">// if the declared type is just 'Function1', or is missing, the function literal gets </span>
<span class="c1">// translated to a complete function</span>

<span class="c1">// if you can, use a complete function, because partial functions allow for runtime errors</span>
<span class="c1">// that the compiler cannot spot</span>

<span class="c1">// if you happen to e.g. use a framework that expects partial function, you should</span>
<span class="c1">// always check 'isDefinedAt' before calling the function</span>
</pre></div>

<p><strong>334 - Patterns in <code>for</code> expressions</strong></p>

<div class="highlight"><pre><span class="k">for</span><span class="o">((</span><span class="n">country</span><span class="o">,</span> <span class="n">city</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">capitals</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"The capital of "</span> <span class="o">+</span> <span class="n">country</span> <span class="o">+</span> <span class="s">" is "</span> <span class="o">+</span> <span class="n">city</span><span class="o">)</span>

<span class="c1">// in the above example, 'for' retrieves all key/value pairs from the map</span>
<span class="c1">// each pair is then matched against the '(country, city)' pattern</span>

<span class="c1">// to pick elements from a list that match a pattern:</span>
<span class="k">val</span> <span class="n">results</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="s">"apple"</span><span class="o">),</span> <span class="nc">None</span><span class="o">,</span> <span class="nc">Some</span><span class="o">(</span><span class="s">"orange"</span><span class="o">))</span>
<span class="k">for</span><span class="o">(</span><span class="nc">Some</span><span class="o">(</span><span class="n">fruit</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">results</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">fruit</span><span class="o">)</span>
<span class="c1">// apple</span>
<span class="c1">// orange</span>

<span class="c1">// 'None' does not match pattern 'Some(fruit)'</span>
</pre></div>

<h3>
<a name="working-with-lists" class="anchor" href="#working-with-lists"><span class="octicon octicon-link"></span></a>Working with Lists</h3>

<p><strong>344 - List literals</strong></p>

<blockquote>
<ul>
<li>lists are <em>immutable</em> (list elements cannot be changed by assignment)</li>
<li>lists are <em>homogeneous</em> (all list elements have the same type)</li>
<li>list type is <em>covariant</em> (if <code>S</code> is subtype of <code>T</code>, then <code>List[S]</code> is a subtype of <code>List[T]</code>)

<ul>
<li>
<code>List[Nothing]</code> is a subtype of any other <code>List[T]</code>
</li>
<li>that is why it's possible to write <code>val xs: List[String] = List()</code>
</li>
</ul>
</li>
<li>they have two fundamental building blocks, <code>Nil</code> and <code>::</code> (cons), where <code>Nil</code> represents an empty list<br><code>val nums = 1 :: 2 :: 3 :: 4 :: Nil</code>
</li>
</ul>
</blockquote>

<p><strong>346 - Basic operations on lists</strong></p>

<blockquote>
<ul>
<li>all operations on lists can be expressed in terms of the following three methods:

<ul>
<li>
<code>head</code>    - returns the first list element (defined for non-empty lists)</li>
<li>
<code>tail</code>    - returns all elements except the first one (defined for non-empty lists)</li>
<li>
<code>isEmpty</code> - returns <code>true</code> if the list is empty</li>
</ul>
</li>
<li>these operations take constant time, <code>O(1)</code>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// insertion sort implementation:</span>
<span class="k">def</span> <span class="n">isort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">Nil</span>
  <span class="k">else</span> <span class="n">insert</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">,</span> <span class="n">isort</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">tail</span><span class="o">))</span>

<span class="k">def</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">isEmpty</span> <span class="o">||</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">xs</span><span class="o">.</span><span class="n">tail</span><span class="o">)</span>
</pre></div>

<p><strong>347 - List patterns</strong></p>

<blockquote>
<ul>
<li>lists can be deconstructed with pattern matching, instead of with <code>head</code>, <code>tail</code> and <code>isEmpty</code>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">fruit</span> <span class="k">=</span> <span class="s">"apples"</span> <span class="o">::</span> <span class="s">"oranges"</span> <span class="o">::</span> <span class="s">"pears"</span>
<span class="k">val</span> <span class="nc">List</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="k">=</span> <span class="n">fruit</span>  <span class="c1">// matches any list of 3, and binds them to pattern elements</span>
<span class="c1">// a: String = apples</span>
<span class="c1">// b: String = oranges</span>
<span class="c1">// c: String = pears</span>

<span class="c1">// if you don't know the number of list elements:</span>
<span class="k">val</span> <span class="n">a</span> <span class="o">::</span> <span class="n">b</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=</span> <span class="n">fruit</span>  <span class="c1">// matches list with 2 or more elements</span>
<span class="c1">// a: String = apples</span>
<span class="c1">// b: String = oranges</span>
<span class="c1">// rest: List[String] = List(pears)</span>

<span class="c1">// pattern that matches any list:</span>
<span class="nc">List</span><span class="o">(...)</span>  <span class="c1">// instance of library-defined 'extractor' pattern</span>
</pre></div>

<blockquote>
<ul>
<li>normally, infix notation (e.g. <code>x :: y</code>) is equivalent to a method call, but with patterns, rules are different. When seen as a pattern, an infix operator is treated as a constructor:

<ul>
<li>
<code>x :: y</code> is equivalent to <code>::(x, y)</code> (not <code>x.::(y)</code>)</li>
<li>there is a class named <code>::</code>, <code>scala.::</code> (builds non-empty lists)</li>
<li>there is also a method <code>::</code> in class <code>List</code> (instantiates class <code>scala.::</code>)</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// insertion sort implementation, written using pattern matching:</span>
<span class="k">def</span> <span class="n">isort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">()</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">isort</span><span class="o">(</span><span class="n">xs1</span><span class="o">))</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="k">case</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span> <span class="k">=&gt;</span>
    <span class="k">if</span><span class="o">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs</span>
    <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">insert</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>

<p><strong>349 - First-order methods on class List</strong></p>

<blockquote>
<ul>
<li>a method is <em>first order</em> if it doesn't take any functions as arguments</li>
<li>
<strong>Concatenating two lists</strong>

<ul>
<li>
<code>xs ::: ys</code> returns a new list that contains all the elements of <code>xs</code>, followed by all the elements of <code>ys</code>
</li>
<li>
<code>:::</code> is implemented as a method in class <code>List</code>
</li>
<li>like <code>cons</code>, list concatenation associates to the right:</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// expression like this:</span>
<span class="n">xs</span> <span class="o">:::</span> <span class="n">ys</span> <span class="o">:::</span> <span class="n">zs</span>
<span class="c1">// is interpreted as:</span>
<span class="n">xs</span> <span class="o">:::</span> <span class="o">(</span><span class="n">ys</span> <span class="o">:::</span> <span class="n">zs</span><span class="o">)</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Divide and Conquer principle</strong>

<ul>
<li>design recursive list manipulation algorithms by pattern matching and deconstruction:</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// my implementation of list concatenation</span>
<span class="k">def</span> <span class="n">append</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">ys</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">::</span> <span class="n">append</span><span class="o">(</span><span class="n">rest</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>
<p><strong>List length</strong></p>

<ul>
<li>
<code>length</code> on lists is a relatively expensive operation, when compared to arrays (<code>O(n)</code>)</li>
</ul>
</li>
<li>
<p><strong>Accessing the end: <code>init</code> and <code>last</code></strong></p>

<ul>
<li>
<code>last</code> returns the last element of a list</li>
<li>
<code>init</code> returns a list consisting of all elements but the last one</li>
<li>same as <code>head</code> and <code>tail</code>, they throw an exception when invoked on an empty list</li>
<li>slow when compared to <code>head</code> and <code>tail</code> since they take linear time, <code>O(n)</code>
</li>
</ul>
</li>
<li>
<p><strong>Reversing lists: <code>reverse</code></strong></p>

<ul>
<li>it's better to organize your data structure so that most accesses are at the head of a list</li>
<li>if an algorithm demands frequent access to the end of a list, it's better to reverse the list first</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// 'reverse' implemented using concatenation</span>
<span class="k">def</span> <span class="n">rev</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="n">xs</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span> <span class="n">rev</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span> <span class="o">:::</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>  <span class="c1">// slow: n-1 recursive calls to concatenation </span>
  <span class="c1">// alt. with my concatenation</span>
  <span class="c1">// case x :: rest =&gt; append(rev(rest), List(x))</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>
<p><strong>Prefixes and suffixes: <code>drop</code>, <code>take</code> and <code>splitAt</code></strong></p>

<ul>
<li>
<code>xs take n</code> returns the first <code>n</code> elements of the list <code>xs</code> (if <code>n &gt; xs.length</code> the whole <code>xs</code> is returned)</li>
<li>
<code>xs drop n</code> returns all elements of the list <code>xs</code> except the first <code>n</code> ones (if <code>n &gt; xs.length</code> the empty list is returned)</li>
<li>
<code>xs splitAt n</code> will return two lists, the same as <code>(xs take n, xs drop n)</code>, only it traverses the list just once</li>
</ul>
</li>
<li>
<p><strong>Element selection: <code>apply</code> and <code>indices</code></strong></p>

<ul>
<li>
<code>xs apply n</code> returns <em>n-th</em> element</li>
<li>as for all other types, <code>apply</code> is implicitly inserted when an object appears in the function position in a method call, so the example from the line above can be written as <code>xs(n)</code>
</li>
<li>
<code>apply</code> is implemented as <code>(xs drop n).head</code>, thus it's slow (<code>O(n)</code>) and rarely used on lists, unlike with arrays</li>
<li>
<code>List(1, 2, 3).indices</code> returns <code>scala.collection.immutable.Range(0, 1, 2)</code>
</li>
</ul>
</li>
<li>
<p><strong>Flattening a list of lists: <code>flatten</code></strong></p>

<ul>
<li>takes a list of lists and flattens it out to a single list</li>
<li>it can only be used on lists whose elements are all lists (compilation error otherwise)</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="n">fruit</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toCharArray</span><span class="o">).</span><span class="n">flatten</span>
<span class="c1">// List(a, p, p, l, e, s, o, r, a, n, g, e, s, p, e, a, r, s)</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Zipping lists: <code>zip</code> and <code>unzip</code></strong>

<ul>
<li>
<code>zip</code> takes two lists and pairs the elements together, dropping any unmatched elements</li>
<li>a useful method is also <code>zipWithIndex</code>, which pairs every element with its index</li>
<li>
<code>unzip</code> converts list of tuples to tuple of lists</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="nc">List</span><span class="o">(</span><span class="-Symbol">'a</span><span class="err">'</span><span class="o">,</span> <span class="-Symbol">'b</span><span class="err">'</span><span class="o">)</span> <span class="n">zip</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="c1">// List[(Char, Int)] = List((a,1), (b,2))</span>

<span class="k">val</span> <span class="n">zipped</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="-Symbol">'a</span><span class="err">'</span><span class="o">,</span> <span class="-Symbol">'b</span><span class="err">'</span><span class="o">).</span><span class="n">zipWithIndex</span>
<span class="c1">// zipped: List[(Char, Int)] = List((a,0), (b,1))</span>

<span class="n">zipped</span><span class="o">.</span><span class="n">unzip</span>
<span class="c1">// (List[Char], List[Int]) = (List(a, b), List(1, 2))</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Displaying lists: <code>toString</code> and <code>mkString</code></strong>

<ul>
<li>members of the <code>Traversable</code> trait, which makes them applicable to all other collections</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// 'toString' returns canonical representation of a list:</span>
<span class="k">val</span> <span class="n">abc</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">)</span>
<span class="n">abc</span><span class="o">.</span><span class="n">toString</span>  <span class="c1">// List(a, b, c)</span>

<span class="c1">// 'mkString' is more suitable for human consumption:</span>
<span class="n">mkString</span><span class="o">(</span><span class="n">pre</span><span class="o">,</span> <span class="n">sep</span><span class="o">,</span> <span class="n">post</span><span class="o">)</span>  <span class="c1">// returns:</span>
<span class="n">pre</span> <span class="o">+</span> <span class="n">xs</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+</span> <span class="n">sep</span> <span class="o">+</span> <span class="n">xs</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">sep</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">sep</span> <span class="o">+</span> <span class="n">xs</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">post</span>

<span class="c1">// also:</span>
<span class="n">xs</span> <span class="n">mkString</span> <span class="n">sep</span>  <span class="c1">// equals</span>
<span class="n">xs</span> <span class="n">mkString</span><span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="n">sep</span><span class="o">,</span> <span class="s">""</span><span class="o">)</span>  <span class="c1">// also, you can omit all arguments (default to empty string)</span>

<span class="c1">// a variant of 'mkString' which appends string to a 'scala.StringBuilder' object:</span>
<span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span>
<span class="n">abc</span> <span class="n">addString</span><span class="o">(</span><span class="n">buf</span><span class="o">,</span> <span class="s">"("</span><span class="o">,</span> <span class="s">"; "</span><span class="o">,</span> <span class="s">")"</span><span class="o">)</span>  <span class="c1">// StringBuilder = (a; b; c)</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Converting lists: <code>iterator</code>, <code>toArray</code> and <code>copyToArray</code></strong>

<ul>
<li>
<code>toArray</code> converts a list to an array and <code>toList</code> does the opposite</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">toArray</span>  <span class="c1">// Array(a, b, c)</span>
<span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">toList</span>  <span class="c1">// List(a, b, c)</span>

<span class="c1">// to copy all elements of the list to an array, beginning with position 'start':</span>
<span class="n">xs</span> <span class="n">copyToArray</span> <span class="o">(</span><span class="n">arr</span><span class="o">,</span> <span class="n">start</span><span class="o">)</span>

<span class="c1">// before copying, you must ensure that the array is large enough:</span>
<span class="k">val</span> <span class="n">arr2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="mi">7</span><span class="o">)</span>
<span class="n">xs</span> <span class="n">copyToArray</span> <span class="o">(</span><span class="n">arr2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// produces 'Array(null, null, null, a, b, c, null)'</span>

<span class="c1">// to use an iterator to access list elements:</span>
<span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="n">abc</span><span class="o">.</span><span class="n">iterator</span>  <span class="c1">// it: Iterator[String] = non-empty iterator</span>
<span class="n">it</span><span class="o">.</span><span class="n">next</span>  <span class="c1">// String = "a"</span>
<span class="n">it</span><span class="o">.</span><span class="n">next</span>  <span class="c1">// String = "b"</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Merge sort example</strong>

<ul>
<li>faster than <em>insertion sort</em> for lists - <code>O(n log(n))</code>
</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre>  <span class="k">def</span> <span class="n">msort</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">less</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xs</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">if</span><span class="o">(</span><span class="n">less</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">))</span> <span class="n">x</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
        <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">val</span> <span class="n">n</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">if</span><span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="o">(</span><span class="n">ys</span><span class="o">,</span> <span class="n">zs</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
      <span class="n">merge</span><span class="o">(</span><span class="n">msort</span><span class="o">(</span><span class="n">less</span><span class="o">)(</span><span class="n">ys</span><span class="o">),</span> <span class="n">msort</span><span class="o">(</span><span class="n">less</span><span class="o">)(</span><span class="n">zs</span><span class="o">))</span>
    <span class="o">}</span>
  <span class="o">}</span>

<span class="c1">// call it like this:</span>
<span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="n">msort</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)(</span><span class="mi">9</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">8</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span>
</pre></div>

<blockquote>
<ul>
<li>
<em>currying</em> helps us to create specialized functions, predetermined for a particular comparison operation:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// reverse sort (underscore stands for missing arguments list, in this case, a list that should be sorted)</span>
<span class="k">val</span> <span class="n">reverseIntSort</span> <span class="k">=</span> <span class="n">msort</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="o">)</span> <span class="k">_</span>
<span class="c1">// reverseIntSort: (List[Int]) =&gt; List[Int] = &lt;function&gt;</span>

<span class="n">reverseIntSort</span><span class="o">(</span><span class="mi">9</span> <span class="o">::</span> <span class="mi">1</span> <span class="o">::</span> <span class="mi">8</span> <span class="o">::</span> <span class="mi">3</span> <span class="o">::</span> <span class="mi">2</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span>
</pre></div>

<p><strong>361 - Higher-order methods on class List</strong></p>

<blockquote>
<ul>
<li><p>allow you to express useful list operation patterns in a more concise way</p></li>
<li>
<p><strong>Mapping over lists: <code>map</code>, <code>flatMap</code> and <code>foreach</code></strong></p>

<ul>
<li>
<code>xs map f</code>, where <code>xs</code> is some <code>List[T]</code> and <code>f</code> is a function of type <code>T =&gt; U</code>, applies the function <code>f</code> to each list element and returns the resulting list</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>  <span class="c1">// returns 'List(2, 3, 4)'</span>

<span class="k">val</span> <span class="n">words</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"the"</span><span class="o">,</span> <span class="s">"quick"</span><span class="o">,</span> <span class="s">"brown"</span><span class="o">,</span> <span class="s">"fox"</span><span class="o">)</span>
<span class="n">words</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>  <span class="c1">// 'List(3, 5, 5, 3)'</span>
<span class="n">words</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toList</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">mkString</span><span class="o">)</span> <span class="c1">// 'List(eht, kciuq, nworb, xof)'</span>

<span class="c1">// 'flatMap' takes a function returning a list of elements as its right operand,</span>
<span class="c1">// which it then applies to each list element and flattens the function results</span>
<span class="n">words</span> <span class="n">flatMap</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toList</span><span class="o">)</span>  <span class="c1">// 'List(t, h, e, q, u, i, c, k, b, r, o, w, n, f, o, x)'</span>

<span class="c1">// 'map' and 'flatMap' together:</span>
<span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">i</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="n">j</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)))</span>
<span class="c1">// List[(Int, Int)] = List((2,1), (3,1), (3,2), (4,1), (4,2), (4,3))</span>
<span class="c1">// 'range' creates a list of all integers in some range, excluding second operand</span>

<span class="c1">// equivalent to:</span>
<span class="k">for</span><span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
    <span class="n">j</span> <span class="k">&lt;-</span> <span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">i</span><span class="o">))</span> <span class="k">yield</span> <span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>

<span class="c1">// difference between 'map' and 'flatMap':</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">::</span> <span class="mi">8</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span>  <span class="c1">// List(List(1,8), List(2,8), List(3,8), List(4,8))</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="k">_</span> <span class="o">::</span> <span class="mi">8</span> <span class="o">::</span> <span class="nc">Nil</span><span class="o">)</span>  <span class="c1">// List(1, 8, 2, 8, 3, 8, 4, 8)</span>

<span class="c1">// 'foreach' takes a procedure (a function resulting with Unit) as its right operand,</span>
<span class="c1">// and applies the procedure to each list element. The result is Unit, not a new list</span>
<span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">sum</span> <span class="o">+=</span> <span class="k">_</span><span class="o">)</span> <span class="c1">// sum: Int = 15</span>
</pre></div>

<blockquote>
<ul>
<li><strong>Filtering lists: <code>filter</code>, <code>partition</code>, <code>find</code>, <code>takeWhile</code>, <code>dropWhile</code> and <code>span</code></strong></li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// 'filter' takes a list and a predicate function and returns the new list containing </span>
<span class="c1">// the elements that satisfy the predicate</span>
<span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="n">xs</span> <span class="n">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="c1">// List(2, 4)</span>

<span class="c1">// 'partition' returns a pair of lists, one with elements that satisfy the predicate</span>
<span class="c1">// and the other with ones that don't: '(xs filter p, xs filter (!p(_)))'</span>
<span class="n">xs</span> <span class="n">partition</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="c1">// (List(2, 4), List(1, 3, 5))</span>

<span class="c1">// 'find' is similar to 'filter', but returns only the first element, or 'None'</span>
<span class="n">xs</span> <span class="n">find</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>  <span class="c1">// Some(2)</span>
<span class="n">xs</span> <span class="n">find</span> <span class="o">(</span><span class="k">_</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span>  <span class="c1">// None</span>

<span class="c1">// 'takeWhile' returns the longest prefix that satisfy the predicate</span>
<span class="k">val</span> <span class="n">ys</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">ys</span> <span class="n">takeWhile</span> <span class="o">(</span><span class="k">_</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// List(1, 2, 3)</span>

<span class="c1">// 'dropWhile' is similar to 'takeWhile', but it drops the elements and returns the rest</span>
<span class="n">ys</span> <span class="n">dropWhile</span> <span class="o">(</span><span class="k">_</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// List(4, 3, 2)</span>

<span class="c1">// 'span' returns a pair of lists, the first 'takeWhile' and the second 'dropWhile'</span>
<span class="c1">// like 'splitAt', 'span' traverses the list only once</span>
<span class="n">ys</span> <span class="n">span</span> <span class="o">(</span><span class="k">_</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// (List(1, 2, 3), List(4, 3, 2))</span>
</pre></div>

<blockquote>
<ul>
<li><strong>Predicates over lists: <code>forall</code> and <code>exists</code></strong></li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// 'forall' takes a list and a predicate and returns 'true' if all elements satisfy the predicate</span>
<span class="c1">// 'exists' is similar to 'forall', but it returns 'true' if there's at least one element</span>
<span class="c1">// that satisfies the predicate</span>
<span class="k">def</span> <span class="n">hasZeroRow</span><span class="o">(</span><span class="n">m</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]])</span> <span class="k">=</span>
  <span class="n">m</span> <span class="n">exists</span> <span class="o">(</span><span class="n">row</span> <span class="k">=&gt;</span> <span class="n">row</span> <span class="n">forall</span> <span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="mi">0</span><span class="o">))</span>

<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">z</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">)</span>
<span class="k">val</span> <span class="n">zz</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span>  <span class="c1">//&gt; List(List(0, -1), List(0, -1), List(0, 0, 0))</span>

<span class="n">hasZeroRow</span><span class="o">(</span><span class="n">zz</span><span class="o">)</span>          <span class="c1">//&gt; Boolean = true</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Folding lists: <code>/:</code> and <code>:\</code></strong>

<ul>
<li>
<em>folding</em> combines the elements of a list with some operator</li>
<li>there are equivalent methods named <code>foldLeft</code> and <code>foldRight</code> defined in class <code>List</code>
</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="n">sum</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>  <span class="c1">// equals 0 + 1 + 2 + 3</span>
<span class="c1">// which is a special instance of a fold operation:</span>
<span class="k">def</span> <span class="n">sum</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="mi">0</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>  <span class="c1">// equals 0 + el1 + el2 + ...</span>

<span class="k">def</span> <span class="n">product</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>  <span class="c1">// equals 1 * el1 * el2 * ...</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>fold left</strong> operation <code>(z /: xs)(op)</code> involves 3 objects:

<ul>
<li>start value <code>z</code>
</li>
<li>list <code>xs</code>
</li>
<li>binary operation <code>op</code>
</li>
</ul>
</li>
<li>
<code>(z /: List(a, b, c))(op)</code> equals <code>op(op(op(z, a), b), c)</code>
</li>
</ul>
</blockquote>

<p><img src="https://github.com/mbonaci/scala/blob/master/resources/Scala-fold-left.png?raw=true" alt="List fold left image"></p>

<blockquote>
<ul>
<li>
<strong>fold right</strong> operation <code>(z \: xs)(op)</code> is the reflection of <em>fold left</em>
</li>
<li>consists of the same 3 operands, but the first two are reversed, list comes first</li>
<li>
<code>(List(a, b, c) :\ z)(op)</code> equals <code>op(a, op(b, op(c, z)))</code>
</li>
</ul>
</blockquote>

<p><img src="https://github.com/mbonaci/scala/blob/master/resources/Scala-fold-right.png?raw=true" alt="List fold right image"></p>

<div class="highlight"><pre><span class="c1">// implementation of the 'flatten' methods with folding:</span>
<span class="k">def</span> <span class="n">flattenLeft</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span> <span class="k">=</span>
  <span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span> <span class="o">/:</span> <span class="n">xss</span><span class="o">)</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span>  <span class="c1">// less efficient, since it copies 'xss' 'n - 1' times</span>

<span class="k">def</span> <span class="n">flattenRight</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xss</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]])</span> <span class="k">=</span>
  <span class="o">(</span><span class="n">xss</span> <span class="o">:\</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]())</span> <span class="o">(</span><span class="k">_</span> <span class="o">:::</span> <span class="k">_</span><span class="o">)</span>

<span class="c1">// '(xs ::: ys)' takes linear time 'xs.length'</span>
<span class="c1">// '[T]' is required due to a limitation in type inferencer</span>

<span class="c1">// list reversal implemented using fold left (takes linear time):</span>
<span class="k">def</span> <span class="n">reverseLeft</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">=</span>
  <span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]()</span> <span class="o">/:</span> <span class="n">xs</span><span class="o">)</span> <span class="o">{(</span><span class="n">ys</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys</span><span class="o">}</span>  <span class="c1">// "snoc" ("cons" reversed)</span>

<span class="c1">// how we implemented the function:</span>

<span class="cm">/* First we took smallest possible list, 'List()':</span>
<span class="cm">  equals (by the properties of reverseLeft)</span>
<span class="cm">    reverseLeft(List())</span>
<span class="cm">  equals (by the template for reverseLeft)</span>
<span class="cm">    (startvalue /: List())(operation)</span>
<span class="cm">  equals (by the definition of /:)</span>
<span class="cm">    startvalue</span>
<span class="cm">*/</span>

<span class="cm">/* Then we took the next smallest list, 'List(x)':</span>
<span class="cm">  equals (by the properties of reverseLeft)</span>
<span class="cm">    reverseLeft(List(x))</span>
<span class="cm">  equals (by the template for reverseLeft)</span>
<span class="cm">    (List() /: List(x)) (operation)</span>
<span class="cm">  equals (by the definition of /:)</span>
<span class="cm">    operation(List(), x)</span>
<span class="cm">*/</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Sorting lists: <code>sortWith</code></strong>

<ul>
<li>
<code>xs sortWith before</code>, where <code>before</code> is a function that compares two elements</li>
<li>
<code>x before y</code> should return <code>true</code> if <code>x</code> should come before <code>y</code> in a sort order</li>
<li>uses <em>merge sort</em> algorithm</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="n">list</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">2</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span> <span class="n">sortWith</span> <span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="k">_</span><span class="o">)</span>
<span class="c1">// List(-2, 1, 3, 6, 8)</span>

<span class="n">words</span> <span class="n">sortWith</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
<span class="c1">// List(quick, brown, the, fox)</span>
</pre></div>

<p><strong>369 - Methods of the <code>List</code> object</strong></p>

<blockquote>
<ul>
<li><p>all the methods above are implemented in class <code>List</code>, whereas the following ones are defined in globally accessible, <code>List</code> class's companion object <code>scala.List</code></p></li>
<li>
<p><strong>Creating lists from their elements: <code>List.apply</code></strong></p>

<ul>
<li>
<code>List(1, 2)</code> is in fact <code>List.apply(1, 2)</code>
</li>
</ul>
</li>
<li><p><strong>Creating a range of numbers: <code>List.range</code></strong></p></li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// simplest form</span>
<span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>      <span class="c1">// List(1, 2, 3)</span>
<span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>   <span class="c1">// List(1, 3, 5)</span>
<span class="nc">List</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">3</span><span class="o">)</span>  <span class="c1">// List(9, 6, 3)</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Creating uniform lists: <code>List.fill</code></strong>

<ul>
<li>creates a list consisting of zero or more copies of the same element</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// use currying when invoking it:</span>
<span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="mi">3</span><span class="o">)(</span><span class="-Symbol">'a</span><span class="err">'</span><span class="o">)</span>  <span class="c1">// List(a, a, a)</span>
<span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="mi">2</span><span class="o">)(</span><span class="s">"oy"</span><span class="o">)</span>  <span class="c1">// List(oy, oy)</span>

<span class="c1">// with more than one argument in the first arg list, it'll make multi-dimensional list</span>
<span class="nc">List</span><span class="o">.</span><span class="n">fill</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)(</span><span class="-Symbol">'b</span><span class="err">'</span><span class="o">)</span>  <span class="c1">// List(List(b, b, b), List(b, b, b))</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Tabulating a function: <code>List.tabulate</code></strong>

<ul>
<li>similar to <code>fill</code>, only element isn't fixed, but computed using supplied function</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">squares</span> <span class="k">=</span> <span class="nc">List</span><span class="o">.</span><span class="n">tabulate</span><span class="o">(</span><span class="mi">5</span><span class="o">)(</span><span class="n">n</span> <span class="k">=&gt;</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="o">)</span>  <span class="c1">// one list with 5 elements</span>
<span class="c1">// List(0, 1, 4, 9, 16)</span>

<span class="k">val</span> <span class="n">multiplication</span> <span class="k">=</span> <span class="nc">List</span><span class="o">.</span><span class="n">tabulate</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>  <span class="c1">// 3 lists with 4 elements</span>
<span class="c1">// List[List[Int]] = List(List(0, 0, 0, 0), List(0, 1, 2, 3), List(0, 2, 4, 6))</span>
<span class="cm">/*</span>
<span class="cm">    0  1  2  3</span>

<span class="cm">0   0  0  0  0</span>
<span class="cm">1   0  1  2  3</span>
<span class="cm">2   0  2  4  6</span>
<span class="cm">*/</span>
</pre></div>

<blockquote>
<ul>
<li><strong>Concatenating multiple lists: <code>List.concat</code></strong></li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="nc">List</span><span class="o">.</span><span class="n">concat</span><span class="o">(</span><span class="nc">List</span><span class="o">(),</span> <span class="nc">List</span><span class="o">(</span><span class="-Symbol">'b</span><span class="err">'</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="-Symbol">'c</span><span class="err">'</span><span class="o">))</span>  <span class="c1">// List(b, c)</span>
<span class="nc">List</span><span class="o">.</span><span class="n">concat</span><span class="o">()</span>  <span class="c1">// List()</span>
</pre></div>

<p><strong>371 - Processing multiple lists together</strong></p>

<blockquote>
<ul>
<li>
<code>zipped</code>, <code>map</code>, <code>forall</code>, <code>exists</code>
</li>
<li>
<code>zipped</code> method (defined on tuples) combines the tuple elements sequentially, same as <code>zip</code>, first with first, second with second, ...</li>
<li>it is used with other (multiple list) methods to apply an operation to combined elements</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">1</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">8</span><span class="o">)).</span><span class="n">zipped</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="k">_</span><span class="o">)</span>   <span class="c1">// List(20, 48)</span>

<span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">"on"</span><span class="o">,</span> <span class="s">"mali"</span><span class="o">,</span> <span class="s">"debeli"</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)).</span><span class="n">zipped</span>
    <span class="o">.</span><span class="n">forall</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="k">_</span><span class="o">)</span>                      <span class="c1">//&gt; false (two matches)</span>
<span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">"on"</span><span class="o">,</span> <span class="s">"mali"</span><span class="o">,</span> <span class="s">"debeli"</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">9</span><span class="o">)).</span><span class="n">zipped</span>
    <span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="k">_</span><span class="o">)</span>                      <span class="c1">// true (one matches)</span>
<span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">"on"</span><span class="o">,</span> <span class="s">"mali"</span><span class="o">,</span> <span class="s">"debeli"</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">6</span><span class="o">)).</span><span class="n">zipped</span>
    <span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">!=</span> <span class="k">_</span><span class="o">)</span>                      <span class="c1">// false (all matches)</span>
</pre></div>

<p><strong>372 - Understanding Scala's type inference algorithm</strong></p>

<blockquote>
<ul>
<li>the goal of type inference is to enable users of your method to give as less type information possible, so that function literals are written in more concise way</li>
<li>type inference is flow based</li>
<li>
<p>in a method application <code>m(args)</code>, the inferencer:</p>

<ul>
<li>first checks whether the method <code>m</code> has a known type</li>
<li>if it has, that type is used to infer the expected type of arguments</li>
<li>e.g. in <code>abcde.sortWith(_ &gt; _)</code> the type of <code>abcde</code> is <code>List[Char]</code>
</li>
<li>so it knows <code>sortWith</code> takes <code>(Char, Char) =&gt; Boolean</code> and produces <code>List[Char]</code>
</li>
<li>thus, it expands <code>(_ &gt; _)</code> to <code>((x: Char, y: Char) =&gt; x &gt; y)</code>
</li>
<li>if the type is not know</li>
<li>e.g. in <code>msort(_ &gt; _)(abcde)</code>, <code>msort</code> is curried, polymorphic method that takes an argument of type <code>(T, T) =&gt; Boolean</code> to a function from <code>List[T]</code> to <code>List[T]</code> where <code>T</code> is some as-yet unknown type</li>
<li>the <code>msort</code> needs to be instantiated with a specific type parameter before it can be applied to its arguments</li>
<li>inferencer changes its strategy and type-checks method arguments to determine the proper instance type of the method, but it fails, since all it has is <code>(_ &gt; _)</code>
</li>
<li>one way to solve the problem is to supply <code>msort</code> with explicit type parameter

<ul>
<li><code>msort[Char](_ &gt; _)(abcde)  // List(e, d, c, b, a)</code></li>
</ul>
</li>
<li>another solution is to rewrite <code>msort</code> so that its parameters are swapped:</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">def</span> <span class="n">msortSwapped</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="n">less</span><span class="k">:</span> 
  <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// impl</span>
<span class="o">}</span>

<span class="n">msortSwapped</span><span class="o">(</span><span class="n">abcde</span><span class="o">)(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">)</span>  <span class="c1">// succeeds to compile</span>
<span class="c1">// List(e, d, c, b, a)</span>
</pre></div>

<blockquote>
<ul>
<li>generally, when tasked to infer type parameters of a polymorphic method, the inferencer consults the types of all value arguments in the first parameter list, but it doesn't go beyond that</li>
<li>so, when we swapped the arguments, it used the known type of the first parameter <code>abcde</code> to deduce the type parameter of <code>msortSwapped</code>, so it did not need to consult the second argument list in order to determine the type parameter of the method</li>
<li>
<strong>suggested library design principle:</strong>

<ul>
<li>when designing a polymorphic method that takes a non-function and function arguments, place the function argument last in a curried parameter list by its own</li>
<li>that way, the method's correct instance type can be inferred from the non-function arguments, and then that type can be used to type-check the function argument</li>
</ul>
</li>
</ul>
</blockquote>

<h3>
<a name="collections" class="anchor" href="#collections"><span class="octicon octicon-link"></span></a>Collections</h3>

<p><strong>377 - Sequences</strong></p>

<blockquote>
<ul>
<li>groups of data lined up in order, which allows you to get the 'n-th' element</li>
<li>
<strong>Lists</strong> (immutable linked list)

<ul>
<li>support fast addition and removal of items to the beginning of the list</li>
<li>slow in manipulating the end of a sequence (add to front and reverse in the end)</li>
<li>do not provide fast access to arbitrary indexes (must iterate through the list)</li>
</ul>
</li>
<li>
<strong>Arrays</strong>

<ul>
<li>fast access of an item in an arbitrary position (both, get and update)</li>
<li>represented in the same way as Java arrays (use Java methods that return arrays)</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// to create an array whose size you know, but you don't know element values</span>
<span class="k">val</span> <span class="n">fiveInts</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">](</span><span class="mi">5</span><span class="o">)</span>  <span class="c1">// Array(0, 0, 0, 0, 0)</span>

<span class="c1">// to initialize an array when you know the element values:</span>
<span class="k">val</span> <span class="n">fiveToOne</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">2</span> <span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="c1">// read and update:</span>
<span class="n">fiveInts</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="k">=</span> <span class="n">fiveToOne</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
<span class="n">fiveInts</span>  <span class="c1">// Array(1, 0, 0, 0, 0)</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>List buffers</strong> (mutable)

<ul>
<li>used when you need to build a list by appending to the end</li>
<li>constant time append and prepend operations</li>
<li>
<code>+=</code> to append, and <code>+=:</code> to prepend</li>
<li>when you're done, you can obtain a list with the <code>toList</code> method of <code>ListBuffer</code>
</li>
<li>if your <code>List</code> algorithm is not tail recursive, you can use <code>ListBuffer</code> with <code>for</code> or <code>while</code> to avoid the potential stack overflow</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">import</span> <span class="nn">scala.collection.mutable.ListBuffer</span>
<span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>

<span class="n">buf</span> <span class="o">+=</span> <span class="mi">22</span>   <span class="c1">// ListBuffer(22)</span>
<span class="mi">11</span> <span class="o">+=:</span> <span class="n">buf</span>  <span class="c1">// ListBuffer(11, 22)</span>
<span class="n">buf</span><span class="o">.</span><span class="n">toList</span>  <span class="c1">// List(11, 22)</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Array buffers</strong> (mutable)

<ul>
<li>like an array, but you can add and remove elements from the beginning and the end</li>
<li>all <code>Array</code> operations are available, though little slower, due to wrapping layer in the implementation</li>
<li>addition and removal take constant time on average, but require linear time if the array needs to be expanded</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">import</span> <span class="nn">scala.collection.mutable.ArrayBuffer</span>
<span class="k">val</span> <span class="n">abuf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span>

<span class="c1">// append using '+='</span>
<span class="n">abuf</span> <span class="o">+=</span> <span class="mi">8</span>                   <span class="c1">// ArrayBuffer(8)</span>
<span class="n">abuf</span> <span class="o">+=</span> <span class="mi">4</span>                   <span class="c1">// ArrayBuffer(8, 4)</span>

<span class="n">abuf</span><span class="o">.</span><span class="n">length</span>                 <span class="c1">// Int = 2</span>
<span class="n">abuf</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>                     <span class="c1">// Int = 4</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Strings</strong> (via <strong>StringOps</strong>)

<ul>
<li>since <code>Predef</code> has an implicit conversion from <code>String</code> to <code>StringOps</code>, you can use any string like a sequence</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">def</span> <span class="n">hasUpperCaseLetter</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">isUpper</span><span class="o">)</span>  <span class="c1">// String doesn't have 'exists'</span>

<span class="n">hasUpperCaseLetter</span><span class="o">(</span><span class="s">"glupson 1"</span><span class="o">)</span>  <span class="c1">// false</span>
<span class="n">hasUpperCaseLetter</span><span class="o">(</span><span class="s">"glupsoN 1"</span><span class="o">)</span>  <span class="c1">// true</span>
</pre></div>

<p><strong>381 - Sets and maps</strong></p>

<blockquote>
<ul>
<li>by default, when you write <code>Set</code> or <code>Map</code>, you get an immutable object</li>
<li>for mutable objects, you need explicit import</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">object</span> <span class="nc">Predef</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">+B</span><span class="o">]</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span>
  <span class="k">type</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">val</span> <span class="nc">Map</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Map</span>
  <span class="k">val</span> <span class="nc">Set</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Set</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
<span class="c1">// the 'type' keyword is used in 'Predef' to define aliases for fully qualified names</span>
<span class="c1">// the 'vals' are initialized to refer to the singleton objects</span>
<span class="c1">// so 'Map' == 'Predef.Map' == 'scala.collection.immutable.Map'</span>

<span class="c1">// to use the immutable and mutable in the same source file:</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">val</span> <span class="n">mutaSet</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>  <span class="c1">// scala.collection.mutable.Set[Int]</span>
<span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>              <span class="c1">// scala.collection.immutable.Set[Int]</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Using sets</strong>

<ul>
<li>the key characteristic is that they maintain uniqueness of their elements, as defined by <code>==</code>
</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">text</span> <span class="k">=</span> <span class="s">"run Forest, run. That's it Forest! Run!"</span>
<span class="k">val</span> <span class="n">wordsArray</span> <span class="k">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">"[ !,.]+"</span><span class="o">)</span>  <span class="c1">// Array(run, Forest, Run, That's, it, Forest, Run)</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>  <span class="c1">// Set()</span>

<span class="k">for</span><span class="o">(</span><span class="n">word</span> <span class="k">&lt;-</span> <span class="n">wordsArray</span><span class="o">)</span>
  <span class="n">set</span> <span class="o">+=</span> <span class="n">word</span><span class="o">.</span><span class="n">toLowerCase</span>

<span class="n">set</span>  <span class="c1">// Set(it, run, that's, forest)</span>
</pre></div>

<p><img src="https://github.com/mbonaci/scala/blob/master/resources/Scala-sets-hierarchy.png?raw=true" alt="Set hierarchy"></p>

<div class="highlight"><pre><span class="cm">/********************************************************************************/</span>
<span class="cm">/*********************      Common operations for sets      *********************/</span>
<span class="cm">/********************************************************************************/</span>

<span class="k">val</span> <span class="n">nums</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>          <span class="c1">// crates an immutable set</span>
<span class="n">nums</span><span class="o">.</span><span class="n">toString</span>                    <span class="c1">// returns Set(1, 2, 3)</span>
<span class="n">nums</span> <span class="o">+</span> <span class="mi">5</span>                         <span class="c1">// adds an element (returns Set(1, 2, 3, 5))</span>
<span class="n">nums</span> <span class="o">-</span> <span class="mi">3</span>                         <span class="c1">// removes the element (returns Set(1, 2))</span>
<span class="n">nums</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">)</span>               <span class="c1">// adds multiple elements (returns Set(1, 2, 3, 5, 6))</span>
<span class="n">nums</span> <span class="o">--</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>               <span class="c1">// removes multiple elements</span>
<span class="n">nums</span> <span class="o">&amp;</span> <span class="nc">Set</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>           <span class="c1">// returns the intersection of two sets (Set(1, 3))</span>
<span class="n">nums</span><span class="o">.</span><span class="n">size</span>                        <span class="c1">// returns the size of the set</span>
<span class="n">nums</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>                 <span class="c1">// checks for inclusion</span>

<span class="k">import</span> <span class="nn">scala.collection.mutable</span>  <span class="c1">// makes the mutable collections easy to access</span>
<span class="k">val</span> <span class="n">words</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>  <span class="c1">// creates an empty, mutable set (HashSet)</span>
<span class="n">words</span><span class="o">.</span><span class="n">toString</span>                   <span class="c1">// returns Set()</span>
<span class="n">words</span> <span class="o">+=</span> <span class="s">"the"</span>                   <span class="c1">// adds an element (Set(the))</span>
<span class="n">words</span> <span class="o">-=</span> <span class="s">"the"</span>                   <span class="c1">// removes an element (Set())</span>
<span class="n">words</span> <span class="o">++=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"do"</span><span class="o">,</span> <span class="s">"re"</span><span class="o">,</span> <span class="s">"mi"</span><span class="o">)</span> <span class="c1">// adds multiple elements</span>
<span class="n">words</span> <span class="o">--=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"do"</span><span class="o">,</span> <span class="s">"re"</span><span class="o">)</span>       <span class="c1">// removes multiple elements</span>
<span class="n">words</span><span class="o">.</span><span class="n">clear</span>                      <span class="c1">// removes all elements</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Using maps</strong>

<ul>
<li>when creating a map, you must specify two types (key, value)</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// word count using a map</span>
<span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">count</span> <span class="k">=</span> <span class="n">countWords</span><span class="o">(</span><span class="s">"run forest, run fast! run forest!"</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">count</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>  <span class="c1">// Map(fast -&gt; 1, run -&gt; 3, forest -&gt; 2)</span>
<span class="o">}</span>

<span class="k">import</span> <span class="nn">scala.collection.mutable</span>
<span class="k">def</span> <span class="n">countWords</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">mutable.Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">wordsArray</span> <span class="k">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">"[ !,.]+"</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span>

  <span class="k">for</span><span class="o">(</span><span class="n">w</span> <span class="k">&lt;-</span> <span class="n">wordsArray</span><span class="o">)</span>
    <span class="k">if</span><span class="o">(</span><span class="n">map</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">w</span><span class="o">))</span>
      <span class="n">map</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">w</span><span class="o">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span>
      <span class="n">map</span> <span class="o">+=</span> <span class="o">(</span><span class="n">w</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">)</span>

  <span class="n">map</span>
<span class="o">}</span>
</pre></div>

<p><img src="https://github.com/mbonaci/scala/blob/master/resources/Scala-maps-hierarchy.png?raw=true" alt="Map hierarchy"></p>

<div class="highlight"><pre><span class="cm">/********************************************************************************/</span>
<span class="cm">/*********************      Common operations for maps      *********************/</span>
<span class="cm">/********************************************************************************/</span>

<span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="s">"i"</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">"ii"</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>  <span class="c1">// crates an immutable map</span>
<span class="n">m</span><span class="o">.</span><span class="n">toString</span>                        <span class="c1">// returns Map(i-&gt;1, ii-&gt;2)</span>
<span class="n">m</span> <span class="o">+</span> <span class="o">(</span><span class="s">"vi"</span> <span class="o">-&gt;</span> <span class="mi">6</span><span class="o">)</span>                   <span class="c1">// adds an entry (returns Map(i-&gt;1, ii-&gt;2, vi-&gt;6)</span>
<span class="n">m</span> <span class="o">-</span> <span class="s">"ii"</span>                          <span class="c1">// removes the entry (returns Map(i-&gt;1, vi-&gt;6))</span>
<span class="n">m</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"iii"</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">,</span> <span class="s">"v"</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">)</span>   <span class="c1">// adds multiple entries</span>
<span class="n">m</span> <span class="o">--</span> <span class="nc">List</span><span class="o">(</span><span class="s">"i"</span><span class="o">,</span> <span class="s">"ii"</span><span class="o">)</span>              <span class="c1">// removes multiple entries</span>
<span class="n">m</span><span class="o">.</span><span class="n">size</span>                            <span class="c1">// returns the size of the map</span>
<span class="n">m</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">"ii"</span><span class="o">)</span>                  <span class="c1">// checks for inclusion</span>
<span class="n">m</span><span class="o">(</span><span class="s">"ii"</span><span class="o">)</span>                           <span class="c1">// returns 2</span>
<span class="n">m</span><span class="o">.</span><span class="n">keys</span>                            <span class="c1">// returns Iterable over keys ("i" and "ii")</span>
<span class="n">m</span><span class="o">.</span><span class="n">keySet</span>                          <span class="c1">// returns keys as a set (Set(i, ii))</span>
<span class="n">m</span><span class="o">.</span><span class="n">values</span>                          <span class="c1">// returns Iterable over values (1, 2)</span>
<span class="n">m</span><span class="o">.</span><span class="n">isEmpty</span>                         <span class="c1">// indicates whether the map is empty</span>

<span class="k">import</span> <span class="nn">scala.collection.mutable</span>   <span class="c1">// makes the mutable collections easy to access</span>
<span class="k">val</span> <span class="n">w</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span>  <span class="c1">// creates an empty, mutable map (HashMap)</span>
<span class="n">w</span><span class="o">.</span><span class="n">toString</span>                        <span class="c1">// returns Map()</span>
<span class="n">w</span> <span class="o">+=</span> <span class="o">(</span><span class="s">"one"</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">)</span>                 <span class="c1">// adds an entry (Map(one-&gt;1))</span>
<span class="n">w</span> <span class="o">-=</span> <span class="s">"one"</span>                        <span class="c1">// removes an entry (Map())</span>
<span class="n">w</span> <span class="o">++=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"st"</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">"nd"</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="s">"rd"</span> <span class="o">-</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// adds multiple entries</span>
<span class="n">w</span> <span class="o">--=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"st"</span><span class="o">,</span> <span class="s">"nd"</span><span class="o">)</span>            <span class="c1">// removes multiple entries</span>
<span class="n">w</span><span class="o">.</span><span class="n">clear</span>                           <span class="c1">// removes all entries</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Default sets and maps</strong>

<ul>
<li>
<code>mutable.Map()</code> factory method returns <code>mutable.HashMap</code> (analogous for mutable set)</li>
<li>for immutable sets and maps, it depends on how many elements you pass to it:</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// rules for sets (the same applies for maps)</span>
<span class="nc">Number</span> <span class="n">of</span> <span class="n">elements</span>  <span class="nc">Implementation</span> <span class="o">(</span><span class="n">used</span> <span class="n">to</span> <span class="n">maximize</span> <span class="n">performance</span><span class="o">)</span>
<span class="mi">0</span>                   <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">EmptySet</span>
<span class="mi">1</span>                   <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Set1</span>
<span class="mi">2</span>                   <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Set2</span>
<span class="mi">3</span>                   <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Set3</span>
<span class="mi">4</span>                   <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Set4</span>
<span class="mi">5</span> <span class="n">or</span> <span class="n">more</span>           <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">HashSet</span> <span class="o">(</span><span class="n">implemented</span> <span class="n">as</span> <span class="n">trie</span><span class="o">)</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Sorted sets and maps</strong>

<ul>
<li>a set or map whose iterator returns elements in a particular order</li>
<li>for this purpose, <code>collections</code> library provides traits <code>SortedSet</code> and <code>SortedMap</code>, which are implemented using <code>TreeSet</code> and <code>TreeMap</code>, and which use a <strong>red-black tree</strong> to keep <code>TreeSet</code> elements and <code>TreeMap</code> keys in order</li>
<li>the order is determined by the <code>Ordered</code> trait, which the element type of set, or key type of map must either mix in or be implicitly convertible to</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">import</span> <span class="nn">scala.collection.immutable.TreeSet</span>
<span class="k">val</span> <span class="n">ts</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// TreeSet(1, 2, 3, 4, 5, 6, 8, 9)</span>

<span class="k">import</span> <span class="nn">scala.collection.immutable.TreeMap</span>
<span class="k">val</span> <span class="n">tm</span> <span class="k">=</span> <span class="nc">TreeMap</span><span class="o">(</span><span class="mi">8</span> <span class="o">-&gt;</span> <span class="-Symbol">'e</span><span class="err">'</span><span class="o">,</span> <span class="mi">7</span> <span class="o">-&gt;</span> <span class="-Symbol">'a</span><span class="err">'</span><span class="o">,</span> <span class="mi">1</span> <span class="o">-&gt;</span> <span class="-Symbol">'w</span><span class="err">'</span><span class="o">)</span>  <span class="c1">// Map(1 -&gt; w, 7 -&gt; a, 8 -&gt; e)</span>
<span class="k">val</span> <span class="n">otm</span> <span class="k">=</span> <span class="n">tm</span> <span class="o">+</span> <span class="o">(</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="-Symbol">'u</span><span class="err">'</span><span class="o">)</span>  <span class="c1">// Map(1 -&gt; w, 2 -&gt; u, 7 -&gt; a, 8 -&gt; e)</span>
</pre></div>

<p><strong>390 - Selecting mutable versus immutable collections</strong></p>

<blockquote>
<ul>
<li>immutable collections can usually be stored more compactly, especially small maps and sets, e.g. empty mutable map, in its default representation, HashMap, takes around 80 bytes, with 16 bytes for every new element, while immutable Map1 takes only 16 bytes, and Map4 around 40 bytes</li>
<li>immutable map is a single object that's shared between all references, so referring to it costs just a single pointer field</li>
<li>to make the switch between mutable and immutable, Scala provides some syntactic sugar:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// if you declare immutable set or map as 'var':</span>
<span class="k">var</span> <span class="n">toys</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"bear"</span><span class="o">,</span> <span class="s">"car"</span><span class="o">)</span>  <span class="c1">// scala.collection.immutable.Set[String] = Set(bear, car)</span>
<span class="n">toys</span> <span class="o">+=</span> <span class="s">"doll"</span>  <span class="c1">// a new set is created and then 'toys' is reassigned to it</span>
<span class="n">toys</span>  <span class="c1">// scala.collection.immutable.Set[String] = Set(bear, car, doll)</span>

<span class="n">toys</span> <span class="o">-=</span> <span class="s">"bear"</span>  <span class="c1">// works with any other operator method ending with '='</span>
<span class="n">toys</span>  <span class="c1">// scala.collection.immutable.Set[String] = Set(car, doll)</span>

<span class="c1">// then, if you want to switch to mutable the only thing you need is:</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable.Set</span>

<span class="c1">// this works with any type, not just collections</span>
</pre></div>

<p><strong>392 - Initializing collections</strong></p>

<blockquote>
<ul>
<li>the common way to create and initialize a collection is to pass the initial elements to a factory method on the companion object (invokes <code>apply</code>)</li>
<li>when an inferred type is not what you need, explicitly set type of your collection:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">stuff</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">[</span><span class="kt">Any</span><span class="o">](</span><span class="mi">42</span><span class="o">)</span>
<span class="n">stuff</span> <span class="o">+=</span> <span class="s">"green"</span>  <span class="c1">// scala.collection.mutable.Set[Any] = Set(42, green)</span>
</pre></div>

<p><strong>394 - Converting to array or list</strong></p>

<blockquote>
<ul>
<li>to convert a collection to array, simply call <code>toArray</code>
</li>
<li>to convert a collection to list, simply call <code>toList</code>
</li>
<li>there is a speed penalty, since all the elements need to be copied during the conversion process, which may be problematic for large collections</li>
<li>the order of elements in the resulting list or array will be the order produced by an iterator obtained by invoking <code>elements</code> on the source collection</li>
<li>in case of sorted collections, the resulting list or array will also be sorted:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">ts</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="mi">8</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>
<span class="k">val</span> <span class="n">a</span> <span class="k">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">toArray</span>  <span class="c1">// Array(1, 3, 4, 8)</span>
<span class="k">val</span> <span class="n">l</span> <span class="k">=</span> <span class="n">ts</span><span class="o">.</span><span class="n">toList</span>   <span class="c1">// List(1, 3, 4, 8)</span>
</pre></div>

<p><strong>395 - Converting between mutable and immutable sets and maps</strong></p>

<blockquote>
<ul>
<li>create a collection of the new type using the <code>empty</code> method and then add the new elements using method for adding multiple entries (<code>++</code> for mutable and <code>++=</code> for immutable)</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// converting immutable TreeSet to a mutable set and back</span>
<span class="k">val</span> <span class="n">ts</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">(</span><span class="mi">9</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="k">val</span> <span class="n">ms</span> <span class="k">=</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span> <span class="o">++=</span> <span class="n">ts</span>  <span class="c1">// mutable.Set[Int] = Set(9, 1, 5, 2, 6, 3, 4, 8)</span>
<span class="k">val</span> <span class="n">is</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">.</span><span class="n">empty</span> <span class="o">++</span> <span class="n">mts</span>        <span class="c1">// immutable.Set[Int] = Set(5, 1, 6, 9, 2, 3, 8, 4)</span>
</pre></div>

<p><strong>396 - Tuples</strong></p>

<blockquote>
<ul>
<li>a tuple combines a fixed number of items together so they can be passed around as a whole</li>
<li>unlike arrays and lists, tuple can hold objects of different types</li>
<li>tuples save you the effort of defining simplistic, data-heavy (as opposed to logic-heavy) classes</li>
<li>since they can contain objects of different types, they don't inherit from <code>Traversable</code>
</li>
<li>a common usage pattern of tuples is returning multiple values from a method</li>
<li>to access elements of a tuple you can use methods <code>_1</code>, <code>_2</code>, ...</li>
<li>you can deconstruct a tuple like this: <code>val (word, idx) = someTuple2</code> (if you leave off the parentheses, both <code>word</code> and <code>idx</code> vals are assigned with a whole tuple)</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">def</span> <span class="n">findLongest</span><span class="o">(</span><span class="n">words</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Tuple2</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">len</span> <span class="k">=</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">var</span> <span class="n">index</span> <span class="k">=</span> <span class="o">-</span><span class="mi">1</span>

  <span class="k">for</span><span class="o">(</span><span class="n">word</span> <span class="k">&lt;-</span> <span class="n">words</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">word</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">len</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">index</span> <span class="k">=</span> <span class="n">words</span><span class="o">.</span><span class="n">indexOf</span><span class="o">(</span><span class="n">word</span><span class="o">)</span>
      <span class="n">len</span> <span class="k">=</span> <span class="n">word</span><span class="o">.</span><span class="n">length</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="o">(</span><span class="n">words</span><span class="o">(</span><span class="n">index</span><span class="o">),</span> <span class="n">index</span><span class="o">)</span>

<span class="o">}</span>  <span class="c1">// findLongest: (words: Array[String])(String, Int)</span>

<span class="k">var</span> <span class="n">toys</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">(</span><span class="s">"bear"</span><span class="o">,</span> <span class="s">"car"</span><span class="o">,</span> <span class="s">"doll"</span><span class="o">,</span> <span class="s">"loading truck"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">tup</span> <span class="k">=</span> <span class="n">findLongest</span><span class="o">(</span><span class="n">toys</span><span class="o">.</span><span class="n">toArray</span><span class="o">)</span>  <span class="c1">// tup: (String, Int) = (loading truck,3)</span>
</pre></div>

<h3>
<a name="stateful-objects" class="anchor" href="#stateful-objects"><span class="octicon octicon-link"></span></a>Stateful Objects</h3>

<p><strong>402 - Reassignable variables and properties</strong></p>

<blockquote>
<ul>
<li>every non-private <code>var x</code> member of an object implicitly defines getter and setter</li>
<li>getter is named <code>x</code> and setter is named <code>x_=</code>
</li>
<li>getter and setter inherit access from their <code>var</code>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">var</span> <span class="n">hour</span> <span class="k">=</span> <span class="mi">6</span>
<span class="c1">// generates</span>
<span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">h</span> <span class="k">=</span> <span class="mi">6</span>
<span class="c1">// and getter</span>
<span class="n">hour</span>
<span class="c1">// and setter</span>
<span class="n">hour_=</span>

<span class="c1">// the following two class definitions are identical:</span>
<span class="k">class</span> <span class="nc">Time</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">hour</span> <span class="k">=</span> <span class="mi">6</span>
  <span class="k">var</span> <span class="n">minute</span> <span class="k">=</span> <span class="mi">30</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Time</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">h</span> <span class="k">=</span> <span class="mi">6</span>  <span class="c1">// access qualifier: private up to this (invisible outside)</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">m</span> <span class="k">=</span> <span class="mi">30</span>

  <span class="k">def</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">h</span>
  <span class="k">def</span> <span class="n">hour_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="n">h</span> <span class="k">=</span> <span class="n">x</span> <span class="o">}</span>

  <span class="k">def</span> <span class="n">minute</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">m</span>
  <span class="k">def</span> <span class="n">minute_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span> <span class="n">m</span> <span class="k">=</span> <span class="n">x</span> <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// you can define getters and setters explicitly</span>
<span class="k">class</span> <span class="nc">Time</span> <span class="o">{</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">h</span> <span class="k">=</span> <span class="mi">6</span>
  <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">m</span> <span class="k">=</span> <span class="mi">30</span>

  <span class="k">def</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="n">h</span>
  <span class="k">def</span> <span class="n">hour_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">24</span><span class="o">)</span>
    <span class="n">h</span> <span class="k">=</span> <span class="n">x</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// getters and setters can be defined without the accompanying field:</span>
<span class="k">class</span> <span class="nc">Thermometer</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">celsius</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="k">_</span>  <span class="c1">// initialized to default value (0)</span>

  <span class="k">def</span> <span class="n">fahrenheit</span> <span class="k">=</span> <span class="n">celsius</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">/</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">32</span>

  <span class="k">def</span> <span class="n">fahrenheit_=</span> <span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Float</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">celsius</span> <span class="k">=</span> <span class="o">(</span><span class="n">f</span> <span class="o">-</span> <span class="mi">32</span><span class="o">)</span> <span class="o">*</span> <span class="mi">5</span> <span class="o">/</span> <span class="mi">9</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">fahrenheit</span> <span class="o">+</span> <span class="s">"F/"</span> <span class="o">+</span> <span class="n">celsius</span> <span class="o">+</span> <span class="s">"C"</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>initializer sets a variable to default value of that type:

<ul>
<li>
<code>0</code>       - for numeric types</li>
<li>
<code>false</code>   - for booleans</li>
<li>
<code>null</code>    - for reference types</li>
</ul>
</li>
<li>works the same way as uninitialized variables in Java</li>
</ul>
</blockquote>

<p><strong>405 - Case study: Discrete event simulation</strong></p>

<blockquote>
<ul>
<li>internal DSL is a DSL implemented as a library inside another language, rather than being implemented on its own</li>
</ul>
</blockquote>

<h3>
<a name="type-parameterization" class="anchor" href="#type-parameterization"><span class="octicon octicon-link"></span></a>Type Parameterization</h3>

<p><strong>422 - Information hiding</strong></p>

<blockquote>
<ul>
<li>to hide a primary constructor add <code>private</code> modifier in front of the class parameter list</li>
<li>private constructor can only be accessed from withing the class itself or its companion object</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">class</span> <span class="nc">ImmutableQueue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">private</span> <span class="o">(</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span>

<span class="k">new</span> <span class="nc">Queue</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">),</span> <span class="nc">List</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>  <span class="c1">// error: ImmutableQueue cannot be accessed in object $iw</span>

<span class="c1">// now one possibility is to add auxiliary constructor, e.g.:</span>
<span class="k">def</span> <span class="k">this</span><span class="o">()</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>  <span class="c1">// takes empty lists</span>

<span class="c1">// auxiliary constructor that takes 'n' parameters of type 'T':</span>
<span class="k">def</span> <span class="k">this</span><span class="o">(</span><span class="n">elems</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span><span class="o">(</span><span class="n">elems</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>  <span class="c1">// 'T*' - repeated parameters</span>

<span class="c1">// another possibility is to add a factory method</span>
<span class="c1">// convenient way of doing that is to define an ImmutableQueue object</span>
<span class="c1">// that contains 'apply' method</span>
<span class="c1">// by placing this object in the same source file with the ImmutableQueue class</span>
<span class="c1">// it becomes its companion object</span>
<span class="k">object</span> <span class="nc">ImmutableQueue</span> <span class="o">{</span>
  <span class="c1">// creates a queue with initial elements 'xs'</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ImmutableQueue</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// since a companion object contains method 'apply', clients can create queues with:</span>
<span class="nc">ImmutableQueue</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// expands to ImmutableQueue.apply(1, 2, 3)</span>
</pre></div>

<p><strong>428 - Private classes</strong></p>

<blockquote>
<ul>
<li>more radical way of information hiding that hides a class itself</li>
<li>then, you export a trait that reveals the public interface of a class:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">trait</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span>                  <span class="c1">// public</span>
  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>


<span class="k">object</span> <span class="nc">Queue</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span><span class="k">:</span> <span class="kt">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="o">.</span><span class="n">toList</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>

  <span class="k">private</span> <span class="k">class</span> <span class="nc">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span>  <span class="c1">// private inner class</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
    <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="o">)</span> <span class="k">extends</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>         <span class="c1">// mixes in the trait, which has access to private class</span>

    <span class="k">def</span> <span class="n">mirror</span> <span class="k">=</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span>
        <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">(</span><span class="n">trailing</span><span class="o">.</span><span class="n">reverse</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
      <span class="k">else</span>
        <span class="k">this</span>

    <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="n">mirror</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">head</span>

    <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">QueueImpl</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="n">mirror</span>
      <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="n">leading</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">q</span><span class="o">.</span><span class="n">trailing</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">def</span> <span class="n">enqueue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
      <span class="k">new</span> <span class="nc">QueueImpl</span><span class="o">(</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span>
  <span class="o">}</span>

<span class="o">}</span>
</pre></div>

<p><strong>429 - Variance annotations</strong></p>

<blockquote>
<ul>
<li>
<code>Queue</code>, as defined in previous listing is a trait, not a type, so you cannot create variables of type <code>Queue</code>
</li>
<li>instead, trait <code>Queue</code> enables you to specify parameterized types, such as <code>Queue[String]</code>, <code>Queue[AnyRef]</code>
</li>
<li>thus, <code>Queue</code> is a trait, and <code>Queue[String]</code> is a type</li>
<li>this kind of traits are called <strong>type constructors</strong> (you can construct a type by specifying a type parameter, which is analogous to plain-old constructor with specified value parameter)</li>
<li>
<em>type constructors</em> generate a family of types</li>
<li>it is also said that the <code>Queue</code> is a <strong>generic trait</strong>
</li>
<li>in Scala, <strong>generic types have <em>nonvariant</em> (rigid) subtyping</strong>
</li>
<li>consequently, <code>Queue[String]</code> is not a subtype of <code>Queue[AnyRef]</code>
</li>
<li>however, you can demand <strong>covariant</strong> (flexible) subtyping by prefixing a type parameter with <code>+</code>:<br>
</li>
</ul>
</blockquote>

<p><code>trait Queue[+T] { ... }</code></p>

<blockquote>
<ul>
<li>besides <code>+</code> <strong>parameter's variance annotation</strong>, there's also a <code>-</code>, which indicates <strong>contravariant</strong> subtyping:<br>
</li>
</ul>
</blockquote>

<p><code>trait Queue[-T] { ... }</code></p>

<blockquote>
<ul>
<li>then, if <code>T</code> is a subtype of <code>S</code>, this would imply that <code>Queue[S]</code> is a subtype of <code>Queue[T]</code>
</li>
</ul>
</blockquote>

<p><strong>432 - Variance and arrays</strong></p>

<blockquote>
<ul>
<li>arrays in Java are treated as covariants:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// Java</span>
<span class="n">String</span><span class="o">[]</span> <span class="n">a1</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"abc"</span> <span class="o">};</span>
<span class="n">Object</span><span class="o">[]</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">a1</span><span class="o">;</span>
<span class="n">a2</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Integer</span><span class="o">(</span><span class="mi">8</span><span class="o">);</span>  <span class="c1">// ArrayStroreException (Integer placed in String[])</span>
<span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="n">a1</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</pre></div>

<blockquote>
<ul>
<li>because of that, arrays in Scala are nonvariant:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">a1</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="s">"abc"</span><span class="o">)</span>
<span class="k">val</span> <span class="n">a2</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Any</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>  <span class="c1">// error: type mismatch, found Array[String], required Array[Any]</span>
</pre></div>

<blockquote>
<ul>
<li>to interact with legacy methods in Java that use an <code>Object</code> array as a means to emulate generic array, Scala lets you cast an array of <code>T</code>s to an array of any supertype of T:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">a2</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Object</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Array</span><span class="o">[</span><span class="kt">Object</span><span class="o">]]</span>
</pre></div>

<p><strong>433 - Checking variance annotations</strong></p>

<blockquote>
<ul>
<li>to verify the correctness of variance annotations, the compiler classifies all positions in a class or trait body as <strong>positive</strong>, <strong>negative</strong> or <strong>neutral</strong>
</li>
<li>a <em>position</em> is any location in the class (or trait) body where a type parameter may be used</li>
<li>e.g. every method value parameter is a position, because it has a type and therefore a type parameter could appear in that position
type parameters annotated with <code>+</code> can only be used in <em>positive</em> positions, <code>-</code> in negative, and a type parameter without variance annotation may be used in any position (so it's the only one that can be used in <em>neutral</em> positions)</li>
<li>compiler classifies positions like this:

<ul>
<li>the positions at the top level of the class are classified as positive</li>
<li>positions at deeper nesting levels are classified the same as their enclosing level, but with exceptions where the classifications changes (flips):</li>
<li>method value parameter positions are classified to the flipped classification relative to positions outside the method (when flipped, neutral stays the same, negative position becomes positive, and vice versa)</li>
<li>classification is also flipped at the type parameters of methods</li>
<li>it is sometimes flipped at the type argument position of a type (e.g. <code>Arg</code> in <code>C[Arg]</code>), depending on the variance of the corresponding type parameter (if C's type param is annotated with <code>+</code>, then the classification stays the same, and if it's <code>-</code>, then it flips, and if has no variance then it's changed to neutral)</li>
</ul>
</li>
<li>because it's hard to keep track of variance position, it's good to know that the compiler does all the work for you</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// variance checks by the compiler (postfix signs represent position classification):</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Cat</span><span class="o">[</span><span class="kt">-T</span>, <span class="kt">+U</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">meow</span><span class="o">[</span><span class="kt">W-</span><span class="o">](</span><span class="n">volume</span><span class="k">:</span> <span class="kt">T-</span><span class="o">,</span> <span class="n">listener</span><span class="k">:</span> <span class="kt">Cat</span><span class="o">[</span><span class="kt">U+</span>, <span class="kt">T-</span><span class="o">]-)</span><span class="k">:</span> <span class="kt">Cat</span><span class="o">[</span><span class="kt">Cat</span><span class="o">[</span><span class="kt">U+</span>, <span class="kt">T-</span><span class="o">]</span><span class="kt">-</span>, <span class="kt">U+</span><span class="o">]+</span>
<span class="o">}</span>
<span class="c1">// since T is always used in negative position and U in positive, the class is type correct</span>
</pre></div>

<p><strong>437 - Lower bounds</strong></p>

<blockquote>
<ul>
<li>
<code>Queue[T]</code> cannot be made covariant in <code>T</code> because <code>T</code> appears as a type of a parameter of the <code>enqueue</code> method, and that's a negative position</li>
<li>there's still a way to solve that problem by generalizing <code>enqueue</code> by making it polymorphic (i.e. giving the method itself a type parameter) and using a <strong>lower bound</strong> for its type parameter:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">class</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">+T</span><span class="o">](</span><span class="k">private</span> <span class="k">val</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]),</span> <span class="k">private</span> <span class="k">val</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="o">{</span>
  <span class="c1">// defines T as the lower bound for U (U is required to be a supertype of T)</span>
  <span class="k">def</span> <span class="n">enqueue</span><span class="o">[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span> <span class="c1">// U is negative (flip) and T is positive (two flips)</span>
    <span class="k">new</span> <span class="nc">Queue</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span>
    <span class="c1">// ...</span>
<span class="o">}</span>
<span class="c1">// the param to 'enqueue' is now of type 'U'</span>
<span class="c1">// the method's return type is now 'Queue[U]', instead of 'Queue[T]'</span>
<span class="c1">// imagine e.g. class Fruit with two subclasses, Apple and Orange</span>
<span class="c1">// With the new definition of class Queue, it is possible to append an Orange to a </span>
<span class="c1">// Queue[Apple] and the result will be of type Queue[Fruit]</span>
</pre></div>

<p><strong>438 - Contravariance</strong></p>

<blockquote>
<ul>
<li>
<strong>Liskov Substitution Principle</strong> says that it is safe to assume that a type <code>T</code> is a subtype of a type <code>U</code> if you can substitute a value of type <code>T</code> wherever a value of type <code>U</code> is required</li>
<li>the principle holds if <code>T</code> supports the same operations as <code>U</code> and all of <code>T's</code> operations require less and provide more than the corresponding operations in <code>U</code>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// example of Contravariance of a function parameter</span>
<span class="k">class</span> <span class="nc">Publication</span><span class="o">(</span><span class="k">val</span> <span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">class</span> <span class="nc">Book</span><span class="o">(</span><span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Publication</span><span class="o">(</span><span class="n">title</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Library</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">books</span><span class="k">:</span> <span class="kt">Set</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span>
    <span class="nc">Set</span><span class="o">(</span>
      <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="s">"Programming in Scala"</span><span class="o">),</span>
      <span class="k">new</span> <span class="nc">Book</span><span class="o">(</span><span class="s">"Walden"</span><span class="o">)</span>
    <span class="o">)</span>

  <span class="k">def</span> <span class="n">printBookList</span><span class="o">(</span><span class="n">info</span><span class="k">:</span> <span class="kt">Book</span> <span class="o">=&gt;</span> <span class="nc">AnyRef</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// requires function from Book to AnyRef</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">book</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">info</span><span class="o">(</span><span class="n">book</span><span class="o">))</span>  <span class="c1">// always passes a Book to a function</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Customer</span> <span class="k">extends</span> <span class="nc">Application</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">getTitle</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Publication</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">title</span>  <span class="c1">// accesses only Publication</span>
  <span class="nc">Library</span><span class="o">.</span><span class="n">printBookList</span><span class="o">(</span><span class="n">getTitle</span><span class="o">)</span>  <span class="c1">// provides function from Publication to String</span>
<span class="o">}</span>
<span class="c1">// any method declared in Publication is also available on its subclass Book</span>
<span class="c1">// Publication =&gt; String is a subtype of Book =&gt; AnyRef</span>
</pre></div>

<p><img src="https://github.com/mbonaci/scala/blob/master/resources/Scala-covariance-contravariance.png?raw=true" alt="Map hierarchy"></p>

<blockquote>
<ul>
<li>because the result type of a <code>Function1</code> is defined as <em>covariant</em>, the inheritance
relationship of the two result types, shown at the right of the image, is in the same direction as that of the two functions shown in the center</li>
<li>because the parameter type of a <code>Function1</code> is defined as <em>contravariant</em>, the inheritance relationship of the two parameter types, shown at the left of the image, is in the opposite direction as that of the two functions</li>
</ul>
</blockquote>

<p><strong>441 - Object private data</strong></p>

<blockquote>
<ul>
<li>object or class components that are declared as <code>private[this]</code>
</li>
<li>may be accessed only from within their containing object, in which they are defined</li>
<li>accesses to vars from the same object do not cause problems with variance</li>
<li>variance rules can be broken by having a reference to a containing object that has a statically weaker type than the type the object was defined with</li>
<li>for object private values, this is not possible</li>
<li>variance checking has a special case for object private definitions, which is that such definitions are omitted when checking correctness of variance positions</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Purely functional Queue that performs at most one trailing</span>
<span class="cm"> * to leading adjustment for any sequence of head operations</span>
<span class="cm"> * Yes, it has reassignable fields, but they are private,</span>
<span class="cm"> * thus invisible to any client using the class</span>
<span class="cm"> */</span>
<span class="k">class</span> <span class="nc">CovariantQueue</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="nc">private</span> <span class="o">(</span>
    <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">leading</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>  <span class="c1">// object private vars</span>
    <span class="k">private</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">var</span> <span class="n">trailing</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
    <span class="c1">// without [this]:</span>
    <span class="c1">// error: covariant type T occurs in contravariant position</span>
    <span class="c1">// in type List[T] of parameter of setter leading_=</span>
  <span class="o">)</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">def</span> <span class="n">mirror</span><span class="o">()</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">while</span> <span class="o">(!</span><span class="n">trailing</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">leading</span> <span class="k">=</span> <span class="n">trailing</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">leading</span>
        <span class="n">trailing</span> <span class="k">=</span> <span class="n">trailing</span><span class="o">.</span><span class="n">tail</span>
      <span class="o">}</span>
    <span class="o">}</span>

  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span> <span class="o">{</span>
    <span class="n">mirror</span><span class="o">()</span>
    <span class="n">leading</span><span class="o">.</span><span class="n">head</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">CovariantQueue</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">mirror</span><span class="o">()</span>
    <span class="k">new</span> <span class="nc">CovariantQueue</span><span class="o">(</span><span class="n">leading</span><span class="o">.</span><span class="n">tail</span><span class="o">,</span> <span class="n">trailing</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">enqueue</span><span class="o">[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">CovariantQueue</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">leading</span><span class="o">,</span> <span class="n">x</span> <span class="o">::</span> <span class="n">trailing</span><span class="o">)</span>

<span class="o">}</span>
</pre></div>

<p><strong>443 - Upper bounds</strong></p>

<blockquote>
<ul>
<li>with the <code>T &lt;: Ordered[T]</code> you indicate that the type parameter <code>T</code> has an upper bound <code>Ordered[T]</code>, which means that the passed element's type must be a subtype of <code>Ordered</code>
</li>
<li>used e.g. to require that the passed type mixes in a trait (i.e. is a subtype of trait)</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// requires that passed list type mixes in Ordered trait</span>
<span class="k">def</span> <span class="n">orderedMergeSort</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">ys</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ys</span>
      <span class="k">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">xs</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span><span class="o">,</span> <span class="n">y</span> <span class="o">::</span> <span class="n">ys1</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)</span> <span class="n">x</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs1</span><span class="o">,</span> <span class="n">ys</span><span class="o">)</span>
        <span class="k">else</span> <span class="n">y</span> <span class="o">::</span> <span class="n">merge</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">ys1</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="k">val</span> <span class="n">n</span> <span class="k">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">ys</span><span class="o">,</span> <span class="n">zs</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">n</span>
    <span class="n">merge</span><span class="o">(</span><span class="n">orderedMergeSort</span><span class="o">(</span><span class="n">ys</span><span class="o">),</span> <span class="n">orderedMergeSort</span><span class="o">(</span><span class="n">zs</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// this is not a most general way to implement mergeSort, since you cannot pass e.g. List[Int]</span>
<span class="c1">// that's achieved with 'implicit parameters' and 'view bounds' (section 21.6)</span>
</pre></div>

<h3>
<a name="abstract-members" class="anchor" href="#abstract-members"><span class="octicon octicon-link"></span></a>Abstract Members</h3>

<blockquote>
<ul>
<li>a member of a class or trait is <code>abstract</code> if the member does not have a complete definition in the class</li>
<li>abstract members are intended to be implemented by subclasses</li>
<li>in Scala, besides methods, you can declare abstract fields and even abstract types as members of classes and traits (vals, vars, methods and types)</li>
<li>a concrete implementation needs to fill in definitions for each of its abstract members:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// declaration of all four types of abstract members</span>
<span class="k">trait</span> <span class="nc">Abstract</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">val</span> <span class="n">initial</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">var</span> <span class="n">current</span><span class="k">:</span> <span class="kt">T</span>
<span class="o">}</span>

<span class="c1">// the concrete implementation of four type of abstract members</span>
<span class="k">class</span> <span class="nc">Concrete</span> <span class="k">extends</span> <span class="nc">Abstract</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">T</span> <span class="o">=</span> <span class="nc">String</span>  <span class="c1">// defines type 'T' as an alias of type 'String'</span>
  <span class="k">def</span> <span class="n">transform</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">x</span>
  <span class="k">val</span> <span class="n">initial</span> <span class="k">=</span> <span class="s">"hi"</span>
  <span class="k">var</span> <span class="n">current</span> <span class="k">=</span> <span class="n">initial</span>
<span class="o">}</span>
</pre></div>

<p><strong>448 - Type members</strong></p>

<blockquote>
<ul>
<li>
<strong>abstract types</strong> are always members of some class or trait</li>
<li>traits are abstract by definition</li>
<li>a <strong>non-abstract type member</strong> is a way to define a new name (alias) for a type</li>
<li>one reason to use a type member is to define a short, descriptive alias for a type whose real name is more verbose or less obvious in meaning (helps clarify the code)</li>
<li>the other main use of type members is to declare abstract types that must be defined in subclasses</li>
</ul>
</blockquote>

<p><strong>449 - Abstract vals</strong></p>

<blockquote>
<ul>
<li>have a form like <code>val initial: String</code>
</li>
<li>
<code>val</code> is given a name and a type, but not its value</li>
<li>use it when you know that each instance of the class will have an unchangeable value, but you don't know what that value will be</li>
<li>its concrete implementation must be a <code>val</code> (may not be <code>var</code> or <code>def</code>)</li>
<li>guaranteed to return always the same value, unlike methods, which could be implemented by a concrete method that returns a different value every time it's called</li>
<li>
<strong>abstract method declarations</strong> may be implemented by both, concrete method and concrete <code>val</code> definitions</li>
</ul>
</blockquote>

<p><strong>450 - Abstract vars</strong></p>

<blockquote>
<ul>
<li>implicitly declare abstract getters and setters, just like non-abstract <code>vars</code> do</li>
<li>reassignable field is not created</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">trait</span> <span class="nc">AbstractTime</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">var</span> <span class="n">minute</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>

<span class="c1">// gets expanded to:</span>
<span class="k">trait</span> <span class="nc">AbstractTime</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">hour</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">hour_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">minute</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">def</span> <span class="n">minute_=</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>

<p><strong>451 - Initializing abstract vals</strong></p>

<blockquote>
<ul>
<li>abstract vals sometimes play a role of superclass parameters, i.e. they let you provide details in a subclass that are missing in a superclass</li>
<li>that is particularly important for <em>traits</em>, because they don't have a constructor to which you could pass parameters</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// instead of class with two class parameters</span>
<span class="k">trait</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span><span class="k">:</span> <span class="kt">Int</span>  <span class="c1">// 0 until mixed in</span>
  <span class="k">val</span> <span class="n">denomArg</span><span class="k">:</span> <span class="kt">Int</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="c1">// example implementation of two abstract vals</span>
  <span class="c1">// yields an instance of an anonymous class</span>
  <span class="c1">// which mixes in the trait and is defined by the body</span>
  <span class="k">new</span> <span class="nc">RationalTrait</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span>  <span class="c1">// set to 1 as part of the initialization of the anonymous class</span>
    <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span>  <span class="c1">// but the anonymous class is initialized after the RationalTrait</span>
  <span class="o">}</span>                   <span class="c1">// in the meantime, vals are set to their type's default values</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>a class parameter argument is evaluated <strong>before</strong> it is passed to the class constructor (unless it's a by-name parameter)</li>
<li>an implementing <code>val</code> definition in a subclass is evaluated only <strong>after</strong> the superclass has been initialized</li>
<li>e.g. class parameters of <code>Rational(expr1, expr2)</code> are evaluated just before instantiation of the <code>Rational</code> object, but <code>RationalTrait</code>'s vals are evaluated as part of the initialization of the <strong>anonymous class</strong>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">trait</span> <span class="nc">ProblematicRationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span><span class="k">:</span> <span class="kt">Int</span>  <span class="c1">// initialized once an anonymous class is created</span>
  <span class="k">val</span> <span class="n">denomArg</span><span class="k">:</span> <span class="kt">Int</span>  <span class="c1">// which happens after the trait is initialized</span>
  <span class="n">require</span><span class="o">(</span><span class="n">denomArg</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>  <span class="c1">// throws "requirement failed" exception</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="n">gcd</span><span class="o">(</span><span class="n">numerArg</span><span class="o">,</span> <span class="n">denomArg</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">numerArg</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">denomArg</span> <span class="o">/</span> <span class="n">g</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span>
    <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">denom</span>
<span class="o">}</span>

<span class="c1">// when you execute this, 'require' fails, since Int vals are 0 until </span>
<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">2</span>
<span class="k">val</span> <span class="n">fun</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ProblematicRationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">}</span>
</pre></div>

<p><strong>453 - Pre-initialized fields</strong></p>

<blockquote>
<ul>
<li>let you initialize a field of a subclass before the superclass is called</li>
<li>achieved by putting field definition in braces before superclass constructor call:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// anonymous class creation:</span>
<span class="k">new</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">ProblematicRationalTrait</span>

<span class="c1">// object definition:</span>
<span class="k">object</span> <span class="nc">twoThirds</span> <span class="k">extends</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">2</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">3</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">ProblematicRationalTrait</span>

<span class="c1">// subclass definition:</span>
<span class="k">class</span> <span class="nc">RationalClass</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="n">n</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="n">d</span>
<span class="o">}</span> <span class="k">with</span> <span class="nc">ProblematicRationalTrait</span> <span class="o">{</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">RationalClass</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">RationalClass</span><span class="o">(</span>
    <span class="n">numer</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span> <span class="o">+</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">*</span> <span class="n">denom</span><span class="o">,</span>
    <span class="n">denom</span> <span class="o">*</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
  <span class="o">)</span>
<span class="o">}</span>
<span class="c1">// in all cases initialization section comes before the trait is mentioned</span>
</pre></div>

<blockquote>
<ul>
<li>because pre-initialized fields are initialized before the superclass constructor is called, their initializers cannot refer to the object that's being constructed</li>
<li>so, if such an object refers to <code>this</code>, the reference goes to the object containing the class or object that's being constructed, not the constructed object itself:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">object</span> <span class="nc">AbsRat</span> <span class="o">{</span>
  <span class="c1">// ...</span>
  <span class="k">val</span> <span class="n">rat</span> <span class="k">=</span> <span class="k">new</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span>
    <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="k">this</span><span class="o">.</span><span class="n">numerArg</span> <span class="o">*</span> <span class="mi">2</span>  <span class="c1">// value numerArg is not member of object AbsRat</span>
  <span class="o">}</span> <span class="k">with</span> <span class="nc">ProblematicRationalTrait</span>
  <span class="c1">// ...</span>
</pre></div>

<p><strong>455 - Lazy vals</strong></p>

<blockquote>
<ul>
<li>evaluated the first time the val is used</li>
<li>never evaluated more than once (the result of first time evaluation is stored in val)</li>
<li>Scala objects are also initialized on demand, in fact an object definition can be thought of as a shorthand definition of a lazy val with an anonymous class that describes the object's contents</li>
<li>since lazy vals get executed on demand, their textual order is not important when determining the order of their initialization</li>
<li>in the presence of side effects (i.e. when our code produces or is affected by mutations), initialization order starts to matter and then it can be difficult to determine the actual order, which is why lazy vals are an ideal complement to functional objects</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">trait</span> <span class="nc">LazyRationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">val</span> <span class="n">denomArg</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">lazy</span> <span class="k">val</span> <span class="n">numer</span> <span class="k">=</span> <span class="n">numerArg</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">lazy</span> <span class="k">val</span> <span class="n">denom</span> <span class="k">=</span> <span class="n">denomArg</span> <span class="o">/</span> <span class="n">g</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">numer</span> <span class="o">+</span> <span class="s">"/"</span> <span class="o">+</span> <span class="n">denom</span>

  <span class="k">private</span> <span class="k">lazy</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="o">{</span>
    <span class="n">require</span><span class="o">(</span><span class="n">denomArg</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>
    <span class="n">gcd</span><span class="o">(</span><span class="n">numerArg</span><span class="o">,</span> <span class="n">denomArg</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">gcd</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">gcd</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// using LazyRationalTrait from the interpreter:</span>
<span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">2</span>
<span class="k">new</span> <span class="nc">LazyRationalTrait</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">numerArg</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x</span>
  <span class="k">val</span> <span class="n">denomArg</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
<span class="o">}</span>
<span class="c1">// res2: LazyRationalTrait = 1/2</span>

<span class="c1">// 1. - fresh instance of LazyRationalTrait gets created and the initialization code</span>
<span class="c1">//      of LazyRationalTrait is run (fields are not initialized)</span>
<span class="c1">// 2. - the primary constructor of the anonymous subclass is executed (expression 'new')</span>
<span class="c1">//    - this involves the initialization of 'numerArg' with 2 and 'denomArg' with 4</span>
<span class="c1">// 3. - the 'toString' method is invoked on the constructed object (by the interpreter)</span>
<span class="c1">// 4. - the 'numer' field is accessed for the first time, by the 'toString' method</span>
<span class="c1">// 5. - the initializer of 'numer' accesses the private field 'g', so 'g' is evaluated</span>
<span class="c1">//    - the evaluation of 'g' accesses 'numerArg' and 'denomArg' (from step 2)</span>
<span class="c1">// 6. - the 'toString' method accesses the value of 'denom', which causes its evaluation</span>
<span class="c1">//    - that evaluation accesses the values of 'denomArg' and 'g'</span>
<span class="c1">//    - the initializer of the 'g' field is not re-evaluated (it's a 'val', not 'def')</span>
<span class="c1">// 7. - finally, the resulting string "1/2" is constructed and printed</span>
</pre></div>

<p><strong>459 - Abstract types</strong></p>

<blockquote>
<ul>
<li>used as a placeholder for a type that will be defined further down the hierarchy</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// the type of food cannot be determined at the 'Animal' level, every subclass defines it</span>
<span class="k">class</span> <span class="nc">Food</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="k">&lt;:</span> <span class="kt">Food</span>  <span class="c1">// upper bound is 'Food' (requires subclass of 'Food')</span>
  <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">SuitableFood</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Grass</span> <span class="k">extends</span> <span class="nc">Food</span>
<span class="k">class</span> <span class="nc">Cow</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="o">=</span> <span class="nc">Grass</span>  <span class="c1">// 'Cow' fixes its 'SuitableFood' to be 'Grass'</span>
                             <span class="c1">// 'SuitableFood' becomes alias for class 'Grass'</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">Grass</span><span class="o">)</span> <span class="o">{}</span>  <span class="c1">// concrete method for this kind of 'Food'</span>
<span class="o">}</span>
</pre></div>

<p><strong>461 - Path-dependent types</strong></p>

<blockquote>
<ul>
<li>objects in Scala can have types as members (e.g. any instance of 'Cow' will have type 'SuitableFood' as its member)</li>
<li>e.g. <code>milka.SuitableFood</code> means "the type 'SuitableFood' that is a member of the object referenced from 'milka'", or "the type of 'Food' that suitable for 'milka'"</li>
<li>a type like <code>milka.SuitableFood</code> is called a <strong>path-dependent type</strong>, where the word "path" means "the reference to an object"</li>
<li>
<strong>path</strong> can be a single name, such as 'milka', or a longer access path, like <code>farm.barn.milka.SuitableFood</code>, where path components are variables (or singleton object names)that refer to objects</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">class</span> <span class="nc">DogFood</span> <span class="k">extends</span> <span class="nc">Food</span>
<span class="k">class</span> <span class="nc">Dog</span> <span class="k">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
  <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="o">=</span> <span class="nc">DogFood</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">eat</span><span class="o">(</span><span class="n">food</span><span class="k">:</span> <span class="kt">DogFood</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">milka</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Cow</span>
<span class="k">val</span> <span class="n">lassie</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span>
<span class="n">lassie</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="n">milka</span><span class="o">.</span><span class="nc">SuitableFood</span><span class="o">)</span>  <span class="c1">// error: type mismatch; found: Grass, required: DogFood</span>

<span class="c1">// 'SuitableFood' types of two 'Dog's both point to the same type, 'DogFood'</span>
<span class="k">val</span> <span class="n">mickey</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Dog</span>
<span class="n">lassie</span> <span class="n">eat</span> <span class="o">(</span><span class="k">new</span> <span class="n">mickey</span><span class="o">.</span><span class="nc">SuitableFood</span><span class="o">)</span>  <span class="c1">// OK</span>
</pre></div>

<blockquote>
<ul>
<li>although path-dependent types resemble Java's inner classes, there is a crucial difference:

<ul>
<li>a path-dependent type names an outer <strong>object</strong>, whereas an inner class type name an outer class</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">class</span> <span class="nc">Outer</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">Inner</span>
<span class="o">}</span>

<span class="c1">// the inner class is addressed 'Outer#Inner', instead of Java's 'Outer.Inner'</span>
<span class="c1">// in Scala, '.' notation syntax is reserved for objects</span>

<span class="k">val</span> <span class="n">out1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Outer</span>
<span class="k">val</span> <span class="n">out2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Outer</span>

<span class="n">out1</span><span class="o">.</span><span class="nc">Inner</span>  <span class="c1">// path-dependent type</span>
<span class="n">out2</span><span class="o">.</span><span class="nc">Inner</span>  <span class="c1">// path-dependent type (different one)</span>
<span class="c1">// both types are subtypes of 'Outer#Inner', which represents the 'Inner' class with an</span>
<span class="c1">// arbitrary outer object of type 'Outer'</span>
<span class="c1">// by contrast, 'out1.Inner' refers to the 'Inner' class with a specific outer object</span>
<span class="c1">// likewise, type 'out2.Inner' refers to the 'Inner' class with a different, specific</span>
<span class="c1">// outer object (the one referenced from 'out2')</span>
</pre></div>

<blockquote>
<ul>
<li>the same as in Java, inner class instances hold a reference to an enclosing outer class instance, which allows an inner class to access members of its outer class</li>
<li>thus, you cannot instantiate inner class without in some way specifying outer class instance

<ul>
<li>one way to do this is to instantiate the inner class inside the body of the outer class (in this case, the current outer class instance is used - 'this')</li>
<li>the other way is to use a path-dependent type:</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">new</span> <span class="n">out1</span><span class="o">.</span><span class="nc">Inner</span>  <span class="c1">// since 'out1' is a reference to a specific outer object</span>
</pre></div>

<blockquote>
<ul>
<li>the resulting inner object will contain a reference to its outer object ('out1')</li>
<li>by contrast, because the type <code>Outer#Inner</code> does not name any specific instance of <code>Outer</code>, you can't instantiate it:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">new</span> <span class="nc">Outer</span><span class="k">#</span><span class="nc">Inner</span>  <span class="c1">// error: Outer is not a legal prefix for a constructor</span>
</pre></div>

<p><strong>464 - Structural subtyping with Refinement types</strong></p>

<blockquote>
<ul>
<li>when one class inherits from the other, the first one is said to be a <strong>nominal subtype</strong> of the other one (explicit subtype, by name)</li>
<li>Scala additionally supports <strong>structural subtyping</strong>, where you get a subtyping relationship simply because two types have the same members</li>
<li>
<em>structural subtyping</em> is expressed using <strong>refinement types</strong>
</li>
<li>it is recommended that the <em>nominal subtyping</em> is used wherever it can, because <em>structural subtyping</em> can be more flexible than needed (e.g. a Graph and a Cowboy can <code>draw()</code>, but you'd rather get a compilation error than call graphical draw on cowboy)</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// sometimes there is no more to a type than its members</span>
<span class="c1">// e.g. suppose you wanted to define 'Pasture' class that can contain animals that eat 'Grass'</span>
<span class="c1">// one could define a trait 'AnimalThatEatsGrass' and mix it in classes, where applicable</span>
<span class="c1">// but that would be verbose, since 'Cow' already declares that it's an animal that eats grass</span>
<span class="c1">// and with the trait, it again declares that it's an 'AnimalThatEatsGrass'</span>
<span class="c1">// instead, you can use a 'refinement type', and to do that</span>
<span class="c1">// you write the base type, Animal, followed by a sequence of members in curly braces</span>
<span class="c1">// which are used to further refine the types of members from the base class</span>
<span class="c1">// so here is how to write the type "animal that eats grass":</span>
<span class="nc">Animal</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="o">=</span> <span class="nc">Grass</span> <span class="o">}</span>

<span class="c1">// and given this type, you can write the pasture:</span>
<span class="k">class</span> <span class="nc">Pasture</span> <span class="o">{</span>
  <span class="k">var</span> <span class="n">animals</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Animal</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">SuitableFood</span> <span class="kt">=</span> <span class="kt">Grass</span> <span class="o">}]</span> <span class="k">=</span> <span class="nc">Nil</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>another application of structural subtyping is grouping together a number of classes that were written by someone else</li>
<li>for example, to generalize <a href="#control-abstractions">the loan pattern from page 216</a>, which worked for only for type <code>PrintWriter</code>, to work with any type with a <code>close</code> method:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// the first try:</span>
<span class="k">def</span> <span class="n">using</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">S</span><span class="o">](</span><span class="n">obj</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="n">operation</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>  <span class="c1">// operation from any to any type</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">operation</span><span class="o">(</span><span class="n">obj</span><span class="o">)</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">close</span><span class="o">()</span> <span class="c1">// type error: 'T' can be any type and 'AnyRef' doesn't have 'close' method</span>
  <span class="n">result</span>
<span class="o">}</span>

<span class="c1">// the proper implementation:</span>
<span class="k">def</span> <span class="n">using</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="o">{</span> <span class="kt">def</span> <span class="kt">close</span><span class="o">()</span><span class="kt">:</span> <span class="kt">Unit</span><span class="o">}</span>, <span class="kt">S</span><span class="o">](</span><span class="n">obj</span><span class="k">:</span> <span class="kt">T</span><span class="o">)(</span><span class="n">operation</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">S</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// upper bound of 'T' is the structural type '{def close(): Unit}'</span>
  <span class="c1">// which means: "any subtype of AnyRef that has a 'close' method"</span>
  <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">operation</span><span class="o">(</span><span class="n">obj</span><span class="o">)</span>
  <span class="n">obj</span><span class="o">.</span><span class="n">close</span><span class="o">()</span>
  <span class="n">result</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>Structural type</strong> is a refinement type where the refinements are for members that are not in the base type</li>
</ul>
</blockquote>

<p><strong>466 - Enumerations</strong></p>

<blockquote>
<ul>
<li>Scala's <em>enumerations</em> are not a built-in construct</li>
<li>defined in <code>scala.Enumaration</code>
</li>
<li>to create a new enumeration, you define an object that extends <code>scala.Enumeration</code>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">object</span> <span class="nc">Color</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">Red</span><span class="o">,</span> <span class="nc">Green</span><span class="o">,</span> <span class="nc">Blue</span> <span class="k">=</span> <span class="nc">Value</span>  <span class="c1">// 'Value' is an inner class of 'Enumeration'</span>
<span class="o">}</span>
<span class="c1">// 'Value' is also a method of Enumeration that returns a new instance of 'Value' class</span>
<span class="c1">// so 'Color.Red' is of type 'Color.Value' and so is any other enum value in object Color</span>

<span class="c1">// Color object definition provides 3 values: 'Color.Red', 'Color.Green' and 'Color.Blue'</span>

<span class="c1">// to import everything from Color:</span>
<span class="k">import</span> <span class="nn">Color._</span>  <span class="c1">// and then just use 'Red', 'Green' and 'Blue', without the object name</span>
</pre></div>

<blockquote>
<ul>
<li>
<code>Color.Value</code> is a <em>path-dependent</em> type, with <code>Color</code> being the path and <code>Value</code> being the dependent type</li>
<li>it's a completely new type, different from all other types</li>
<li>you can associate names with enumeration values by using a different overloaded variant of the <code>Value</code> method:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">object</span> <span class="nc">Direction</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">Left</span> <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">"Left"</span><span class="o">)</span>
  <span class="k">val</span> <span class="nc">Right</span> <span class="k">=</span> <span class="nc">Value</span><span class="o">(</span><span class="s">"Right"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// to iterate over values:</span>
<span class="k">for</span> <span class="o">(</span><span class="n">d</span> <span class="k">&lt;-</span> <span class="nc">Direction</span><span class="o">.</span><span class="n">values</span><span class="o">)</span> <span class="n">print</span><span class="o">(</span><span class="n">d</span> <span class="o">+</span> <span class="s">" "</span><span class="o">)</span>  <span class="c1">// Left Right</span>

<span class="c1">// you can get the number of enumeration value by its 'id' method (zero-based):</span>
<span class="nc">Direction</span><span class="o">.</span><span class="nc">Right</span><span class="o">.</span><span class="n">id</span>  <span class="c1">// Int = 1</span>

<span class="c1">// also:</span>
<span class="nc">Direction</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>  <span class="c1">// Direction.Value = Left</span>
</pre></div>

<h3>
<a name="implicit-conversions-and-parameters" class="anchor" href="#implicit-conversions-and-parameters"><span class="octicon octicon-link"></span></a>Implicit Conversions and Parameters</h3>

<blockquote>
<ul>
<li>used when working with two bodies of code that were developed separately, thus each may have its own way to represent the same concept</li>
<li>
<strong>implicits</strong> help by reducing the number of explicit conversions one has to write</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// using Swing without implicit conversions (a lot of boilerplate):</span>
<span class="k">val</span> <span class="n">button</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">JButton</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="k">new</span> <span class="nc">ActionListener</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">actionPerformed</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"pressed!"</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">)</span>

<span class="c1">// Scala-friendly version:</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>  <span class="c1">// type mismatch (passing function instead of ActionListener)</span>
  <span class="o">(</span><span class="k">_:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"pressed!"</span><span class="o">)</span>
<span class="o">)</span>

<span class="c1">// first step is to define implicit conversion from function to action listener:</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">function2ActionListener</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">ActionEvent</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">ActionListener</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">actionPerformed</span><span class="o">(</span><span class="n">event</span><span class="k">:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">event</span><span class="o">)</span>
  <span class="o">}</span>

<span class="c1">// now we can write:</span>
<span class="n">button</span><span class="o">.</span><span class="n">addActionListener</span><span class="o">(</span>
  <span class="n">function2ActionListener</span><span class="o">(</span>
    <span class="o">(</span><span class="k">_:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"pressed!"</span><span class="o">)</span>
  <span class="o">)</span>
<span class="o">)</span>

<span class="c1">// which is already much better than the inner class version</span>
<span class="c1">// because the function 'function2ActionListener' is marked as 'implicit', it can be left out:</span>
<span class="n">button</span><span class="o">.</span><span class="nc">AddActionListener</span><span class="o">(</span>  <span class="c1">// now this works!</span>
  <span class="o">(</span><span class="k">_:</span> <span class="kt">ActionEvent</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"pressed!"</span><span class="o">)</span>
<span class="o">)</span>
</pre></div>

<blockquote>
<ul>
<li>how implicits work:

<ul>
<li>the compiler first tries to compile it as is, but it sees a type error</li>
<li>it looks for an implicit conversion that can repair the problem</li>
<li>it finds 'function2ActionListener'</li>
<li>it tries to use it as a conversion method, sees that it works and moves on</li>
</ul>
</li>
</ul>
</blockquote>

<p><strong>482 - Rules for implicits</strong></p>

<blockquote>
<ul>
<li>
<strong>implicit definitions</strong> are definitions that the compiler is allowed to insert into a program in order to fix a type error</li>
<li>you can use <code>implicit</code> to mark any variable, function or object definition<br>
</li>
</ul>
<p><em>Implicit conversions are governed by the following general rules</em></p>

<ul>
<li>
<strong>Marking rule:</strong> Only definitions marked <code>implicit</code> are used</li>
<li>
<strong>Scope rule:</strong> An inserted implicit conversion must be in scope as a single identifier, or be associated with the conversion's source or target type

<ul>
<li>
<em>single identifier</em> means that the compiler will not insert a conversion of the form <code>someVariable.convert</code>
</li>
<li>it is common for libraries to include a <code>Preamble</code> object that contains useful implicits, which allows the code that uses a library to do a single <code>import Preamble._</code>
</li>
<li>there's one exception to single identifier rule: the compiler will also look for implicit definitions in the companion objects of both, source and target types</li>
<li>when implicit is placed in a companion object of some type, it is said that the conversion is <strong>associated</strong> to that type</li>
<li>
<em>modular code reasoning:</em> when you read a source file, the only things you need to consider in other source files are those that are either imported or explicitly referenced through a fully qualified name</li>
</ul>
</li>
<li>
<strong>One-at-a-time rule: Only one implicit is tried</strong>

<ul>
<li>for sanity's sake, the compiler does not insert further implicits when it's already in the process of trying another implicit, e.g. <code>convert1(convert2(x)) + y</code>
</li>
<li>that would cause compile time to increase dramatically on erroneous code and would increase the difference between what the programmer writes and what the program does</li>
<li>it is possible to circumvent this rule by having implicits take implicit params</li>
</ul>
</li>
<li>
<strong>Explicits-First rule:</strong>

<ul>
<li>the compiler will not change code that already works</li>
<li>a consequence of this rule is that you can make trade offs between verbose (explicits) and terse (implicits) code</li>
</ul>
</li>
</ul>
</blockquote>

<p><strong>484 - Naming an implicit conversion</strong></p>

<blockquote>
<ul>
<li>implicit conversions can have arbitrary names</li>
<li>the name matters only in two situations:

<ul>
<li>if you want to write it explicitly in a method application</li>
<li>for determining which implicits are available in a program</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// to determine which implicits will be used:</span>
<span class="k">object</span> <span class="nc">MyConversions</span> <span class="o">{</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">stringWrapper</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">IndexedSeq</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">intToString</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// you can achieve that your code uses only 'stringWrapper' and not 'intToString':</span>
<span class="k">import</span> <span class="nn">MyConversions.stringWrapper</span>  <span class="c1">// possible only because implicit has a name</span>
<span class="c1">// ... code making use of 'stringWrapper'</span>
</pre></div>

<p><strong>485 - Where implicits are tried</strong></p>

<blockquote>
<ul>
<li>there are 3 places where implicits are used:<br><strong>1</strong>  conversions to an expected type (use one type where the other is expected)<br><strong>2</strong>  conversions of the receiver of a selection (adapts receiver of a method call)<br><strong>3</strong>  implicit parameters</li>
</ul>
</blockquote>

<p><strong>485 - Implicit conversion to an expected type</strong></p>

<blockquote>
<ul>
<li>whenever the compiler sees an <code>X</code>, but needs a <code>Y</code>, it will look for an implicit function that converts <code>X</code> to <code>Y</code>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mf">3.5</span>  <span class="c1">// type mismatch (loss of precision)</span>

<span class="c1">// however, if you define implicit conversion:</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">doubleToInt</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Double</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span><span class="o">.</span><span class="n">toInt</span>

<span class="k">val</span> <span class="n">i</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mf">3.5</span>  <span class="c1">// i: Int = 3</span>

<span class="cm">/*</span>
<span class="cm"> * 1. the compiler sees a 'Double' 3.5 in a context where it requires an 'Int'</span>
<span class="cm"> * 2. before giving up and reporting 'type mismatch', it searches for a suitable implicit</span>
<span class="cm"> * 3. it finds 'doubleToInt', and wraps 3.5 in the 'doubleToInt' function call</span>
<span class="cm"> */</span>
</pre></div>

<p><strong>486 - Converting the receiver</strong></p>

<blockquote>
<ul>
<li>implicits are applied on an object on which a method is invoked</li>
<li>has 2 main uses: allows smoother integration of a new class into an existing class hierarchy and second, they support writing DSLs withing the Scala language</li>
<li>how it works:

<ul>
<li>you write down <code>obj.doIt</code> where <code>obj</code> doesn't have a member named <code>doIt</code>
</li>
<li>before giving up, compiler tries to insert conversions that apply to the <code>obj</code>, converting it to a type that has a <code>doIt</code> member</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// use an instance of one type as if it was an instance of some other type</span>
<span class="k">class</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// existing class (from page 155)</span>
  <span class="c1">// ...</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="o">...</span>
  <span class="k">def</span> <span class="o">+</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=</span> <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// the two overloaded methods allow you to:</span>
<span class="k">val</span> <span class="n">oneHalf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>  <span class="c1">// Rational = 1/2</span>
<span class="n">oneHalf</span> <span class="o">+</span> <span class="n">oneHalf</span>  <span class="c1">// Rational = 1/1</span>
<span class="n">oneHalf</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1">// Rational = 3/2</span>

<span class="c1">// but:</span>
<span class="mi">1</span> <span class="o">+</span> <span class="n">oneHalf</span>  <span class="c1">// error: overloaded method value + (of Int) cannot bi applied to Rational</span>

<span class="c1">// so:</span>
<span class="k">implicit</span> <span class="k">def</span> <span class="n">intToRational</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Rational</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>

<span class="mi">1</span> <span class="o">+</span> <span class="n">oneHalf</span>  <span class="c1">// Rational = 3/2</span>

<span class="cm">/*</span>
<span class="cm"> * 1. the compiler first tries to type check the expression '1 + oneHalf' as it is</span>
<span class="cm"> * 2. this fails because none of Int's '+' methods takes a 'Rational' argument</span>
<span class="cm"> * 3. compiler searches for an implicit conversion from 'Int' to another type </span>
<span class="cm"> *    that has a '+' method which can be applied to a 'Rational'</span>
<span class="cm"> * 4. it finds 'intToRational' and wraps 1 in the 'intToRational' call:</span>
<span class="cm"> */</span>
<span class="n">intToRational</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">+</span> <span class="n">oneHalf</span>
</pre></div>

<p><strong>489 - Simulating new syntax</strong></p>

<blockquote>
<ul>
<li>the major use of implicit conversions is to simulate adding new syntax</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// you can make a map using syntax:</span>
<span class="nc">Map</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">"one"</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">"two"</span><span class="o">)</span>  <span class="c1">// what is '-&gt;'</span>

<span class="c1">// '-&gt;' is a method of the class 'ArrowAssoc' (defined in 'scala.Predef' preamble)</span>
<span class="c1">// preamble also defines an implicit conversion from 'Any' to 'ArrayAssoc' so that the</span>
<span class="c1">// '-&gt;' method can be found:</span>

<span class="k">package</span> <span class="nn">scala</span>
<span class="k">object</span> <span class="nc">Predef</span> <span class="o">{</span>
  <span class="k">class</span> <span class="nc">ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">def</span> <span class="o">-&gt;</span> <span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">y</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">Tuple2</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Tuple2</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">implicit</span> <span class="k">def</span> <span class="n">any2ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">ArrowAssoc</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrowAssoc</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

  <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>that is called a <strong>rich wrapper pattern</strong>, which is common in libraries that provide syntax-like extensions to the language</li>
<li>classes named 'RichSomething' (e.g. 'RichInt' or 'RichBoolean') are likely using implicits to add the syntax-like methods to type 'Something'</li>
</ul>
</blockquote>

<p><strong>489 - Implicit parameters</strong></p>

<blockquote>
<ul>
<li>compiler can also insert implicits within argument lists, e.g. replacing <code>someCall(a)</code> with <code>someCall(a)(b)</code> or <code>new SomeClass(a)</code> with <code>new SomeClass(a)(b)</code>, thereby adding a missing parameter list to complete a function call</li>
<li>it is the entire last curried parameter that's supplied, not just the last parameter, e.g. compiler might replace <code>aCall(a)</code> with <code>aCall(a)(b, c, d)</code>
</li>
<li>for this to work, not just that the inserted identifiers (such as b, c and d) must be marked <code>implicit</code> where they are defined, but also the last parameter list in <code>aCall</code>'s definition must be marked <code>implicit</code>:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// suppose you have a class which encapsulates a user's preferred shell prompt string:</span>
<span class="k">class</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="k">val</span> <span class="n">preference</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Greeter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">greet</span>
    <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>  <span class="c1">// first param list</span>
    <span class="o">(</span><span class="k">implicit</span> <span class="n">prompt</span><span class="k">:</span> <span class="kt">PreferredPrompt</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// implicit applies to the entire param list</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"Welcome, "</span> <span class="o">+</span> <span class="n">name</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="n">prompt</span><span class="o">.</span><span class="n">preference</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Prompt</span> <span class="o">{</span>  <span class="c1">// dummy - just hosting 'main'</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">bobsPrompt</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="s">"relax&gt; "</span><span class="o">)</span>
    <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">)(</span><span class="n">bobsPrompt</span><span class="o">)</span>  <span class="c1">// explicit prompt</span>

    <span class="k">implicit</span> <span class="k">val</span> <span class="n">prompt</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="s">"Yes, master&gt; "</span><span class="o">)</span>  <span class="c1">// implicit identifier</span>
    <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">"Joe"</span><span class="o">)</span>  <span class="c1">// implicit prompt</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>example with multiple parameters in the last parameter list:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">class</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="k">val</span> <span class="n">preference</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
<span class="k">class</span> <span class="nc">PreferredDrink</span><span class="o">(</span><span class="k">val</span> <span class="n">preference</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

<span class="k">object</span> <span class="nc">Greeter</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">greet</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">prompt</span><span class="k">:</span> <span class="kt">PreferredPrompt</span><span class="o">,</span> <span class="n">drink</span><span class="k">:</span> <span class="kt">PreferredDrink</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"Welcome, "</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s">". The system is ready."</span><span class="o">)</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"But while you work, "</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"why not enjoy a cup of "</span> <span class="o">+</span> <span class="n">drink</span><span class="o">.</span><span class="n">preference</span> <span class="o">+</span> <span class="s">"?"</span><span class="o">)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">prompt</span><span class="o">.</span><span class="n">preference</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">Prompt</span> <span class="o">{</span>  <span class="c1">// dummy - just hosting 'main'</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">bobsPrompt</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="s">"relax&gt; "</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">bobsDrink</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredDrink</span><span class="o">(</span><span class="s">"travarica"</span><span class="o">)</span>
    <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">"Bob"</span><span class="o">)(</span><span class="n">bobsPrompt</span><span class="o">,</span> <span class="n">bobsDrink</span><span class="o">)</span>  <span class="c1">// all explicit</span>

    <span class="k">implicit</span> <span class="k">val</span> <span class="n">prompt</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredPrompt</span><span class="o">(</span><span class="s">"Yes, master&gt; "</span><span class="o">)</span>
    <span class="k">implicit</span> <span class="k">val</span> <span class="n">drink</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PreferredDrink</span><span class="o">(</span><span class="s">"rakija"</span><span class="o">)</span>
    <span class="nc">Greeter</span><span class="o">.</span><span class="n">greet</span><span class="o">(</span><span class="s">"Joe"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>implicit parameters are most often used to provide information about a type mentioned explicitly in the earlier parameter list (like <em>type classes</em> in Haskell):</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// the weakness of this method is that you cannot use it to sort list of Ints</span>
<span class="c1">// because it requires that 'T' is a subtype of 'Ordered[T]', which Int isn't</span>
<span class="k">def</span> <span class="n">maxListUpBound</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
  <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"empty"</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxListUpBound</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxRest</span><span class="o">)</span> <span class="n">x</span>
      <span class="k">else</span> <span class="n">maxRest</span>
  <span class="o">}</span>

<span class="c1">// to remedy the weakness, we could add an extra argument</span>
<span class="c1">// that converts 'T' to 'Ordered[T]' (i.e. provides info on how to order 'T's)</span>
<span class="k">def</span> <span class="n">maxListImpParm</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">ordered</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
  <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"empty"</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxListImpParm</span><span class="o">(</span><span class="n">rest</span><span class="o">)(</span><span class="n">ordered</span><span class="o">)</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">ordered</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">maxRest</span><span class="o">)</span> <span class="n">x</span>
      <span class="k">else</span> <span class="n">maxRest</span>
  <span class="o">}</span>

<span class="c1">// because patter is so common, the standard library provides implicit 'orderer'</span>
<span class="c1">// methods for many common types, which is why you can use 'maxListImpParm' with:</span>
<span class="n">maxListImpParm</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">10</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>  <span class="c1">// compiler inserts 'orderer' function for Ints</span>
<span class="n">maxListImpParm</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mf">1.5</span><span class="o">,</span> <span class="mf">5.2</span><span class="o">,</span> <span class="mf">10.7</span><span class="o">,</span> <span class="mf">3.22323</span><span class="o">))</span>  <span class="c1">// for Doubles</span>
<span class="n">maxListImpParm</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"two"</span><span class="o">,</span> <span class="s">"three"</span><span class="o">))</span>    <span class="c1">// for String</span>

<span class="cm">/*</span>
<span class="cm"> * Because elements must always be provided explicitly in any invocation of</span>
<span class="cm"> * maxListImpParm, the compiler will know T at compile time, and can therefore</span>
<span class="cm"> * determine whether an implicit definition of type T =&gt; Ordered[T] is in</span>
<span class="cm"> * scope. If so, it can pass in the second parameter list, 'orderer', implicitly.</span>
<span class="cm"> */</span>
</pre></div>

<p><strong>495 - A style rule for implicit parameters</strong></p>

<blockquote>
<ul>
<li>it is best to use a custom named type in the types of implicit parameters (e.g. in the <code>Prompt</code> example, the type of <code>prompt</code> and <code>drink</code> was not <code>String</code>, but <code>PreferredPrompt</code> and <code>PreferredDrink</code>)</li>
<li>use at least one role-determining name within the type of an implicit parameter (in our case <code>Ordered</code>)</li>
</ul>
</blockquote>

<p><strong>495 - View bounds</strong></p>

<blockquote>
<ul>
<li>when you use <code>implicit</code> on a parameter, then not only will the compiler try to supply that parameter with an implicit value, but it will also use that parameter as an available implicit in the body of the method:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">orderer</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
  <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"empty"</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxList</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span>  <span class="c1">// '(orderer)' is implicit</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxRest</span><span class="o">)</span> <span class="n">x</span>           <span class="c1">// 'orderer(x)' is implicit</span>
      <span class="k">else</span> <span class="n">maxRest</span>
  <span class="o">}</span>

<span class="cm">/*</span>
<span class="cm"> * 1. compiler sees that types don't match (e.g. 'x' of type 'T' doesn't have '&gt;' method)</span>
<span class="cm"> * 2. compiler looks for implicit conversions to repair the code</span>
<span class="cm"> * 3. it finds 'orderer' in scope and converts the code to 'orderer(x) &gt; maxRest'</span>
<span class="cm"> * 4. it also converts 'maxList(rest)' to 'maxList(rest)(orderer)'</span>
<span class="cm"> * 5. after these two implicit insertions the code fully type checks</span>
<span class="cm"> *</span>
<span class="cm"> * All that happens without a single mention of the 'orderer' parameter in the body, thus</span>
<span class="cm"> * all uses of 'orderer' are implicit</span>
<span class="cm"> */</span>
</pre></div>

<blockquote>
<ul>
<li>because this pattern is so common, Scala lets you leave out the name of this parameter and shorten the method header by using a <strong>view bound:</strong>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">def</span> <span class="n">maxList</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;%</span> <span class="kt">Ordered</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="n">elements</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=</span>
  <span class="n">elements</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"empty"</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">List</span><span class="o">(</span><span class="n">x</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span>
    <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">rest</span> <span class="k">=&gt;</span>
      <span class="k">val</span> <span class="n">maxRest</span> <span class="k">=</span> <span class="n">maxList</span><span class="o">(</span><span class="n">rest</span><span class="o">)</span>  <span class="c1">// '(orderer)' is implicit</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">maxRest</span><span class="o">)</span> <span class="n">x</span>           <span class="c1">// 'orderer(x)' is implicit</span>
      <span class="k">else</span> <span class="n">maxRest</span>
  <span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>you can think of <code>T &lt;% Ordered[T]</code> as saying "I can use any T, so long as T can be treated as an Ordered[T]", which is different from "T is an Ordered[T]", as <strong>upper bound</strong>, <code>T &lt;: Ordered[T]</code>, would say</li>
<li>so even though class <code>Int</code> is not a subtype of <code>Ordered[Int]</code>, we can still pass a <code>List[Int]</code> to <code>maxList</code>, so long as an implicit conversion from <code>Int</code> to <code>Ordered[Int]</code> is available</li>
<li>if type <code>T</code> happens to already be an <code>Ordered[T]</code>, you can still pass a <code>List[T]</code> to <code>maxList</code> because the compiler will use an implicit <strong>identity function</strong>, declared in <code>Predef</code>:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">implicit</span> <span class="k">def</span> <span class="n">identity</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=</span> <span class="n">x</span>  <span class="c1">// simply returns received object</span>
</pre></div>

<p><strong>498 - When multiple conversions apply</strong></p>

<blockquote>
<ul>
<li>when multiple implicit conversions are in scope, compiler chooses the most specific one (e.g. if one of the conversions takes <code>String</code> and the other takes <code>Any</code>, the compiler will choose the one that takes a <code>String</code>)</li>
<li>one implicit conversion is <strong>more specific</strong> than the other if one of the following applies:

<ul>
<li>the argument type of the former is a subtype of the latter's</li>
<li>both conversions are methods and the enclosing class of the former extends the enclosing class of the latter one</li>
</ul>
</li>
</ul>
</blockquote>

<p><strong>501 - Debugging implicits</strong></p>

<blockquote>
<ul>
<li>when you wonder why the compiler did not find an implicit conversion that you think should have been applied, it helps to write the conversion explicitly, which would possibly produce an error message so you'll know the reason why it was not applied</li>
<li>if inserting the conversion explicitly make the error go away, then you know that insertion was prevented by one of the rules (often Scope rule)</li>
<li>
<code>-Xprint:typer</code> option tells the compiler to show what the code looks like after all implicit conversions have been added by the type checker</li>
<li>implicits can make code confusing if used too frequently, thus, before writing a new implicit conversion, first try to achieve the same effect using inheritance, mixin composition or method overloading</li>
</ul>
</blockquote>

<h3>
<a name="implementing-lists" class="anchor" href="#implementing-lists"><span class="octicon octicon-link"></span></a>Implementing Lists</h3>

<p><strong>503 - The List class in principle</strong></p>

<blockquote>
<ul>
<li>lists are not built-in as a language construct in Scala, they are defined by an abstract class <code>scala.List</code>, which comes with 2 subclasses, <code>Nil</code> and <code>::</code>
</li>
</ul>
</blockquote>

<p><img src="https://github.com/mbonaci/scala/blob/master/resources/Scala-lists-hierarchy.png?raw=true" alt="Lists hierarchy"></p>

<div class="highlight"><pre><span class="k">package</span> <span class="nn">scala</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">List</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>  <span class="c1">// you can assign 'List[Int]' to var of type 'List[Any]'</span>

  <span class="c1">// 3 main methods are abstract in class 'List', and concrete in classes 'Nil' and '::'</span>
  <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span>
  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>The <code>Nil</code> object</strong>

<ul>
<li>defines an empty list</li>
<li>inherits from type <code>List[Nothing]</code>
</li>
<li>because of covariance, <code>Nil</code> is compatible with every instance of the <code>List</code> type</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">case</span> <span class="k">object</span> <span class="nc">Nil</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span> <span class="k">=</span> <span class="kc">true</span>
  <span class="k">def</span> <span class="n">head</span><span class="k">:</span> <span class="kt">Nothing</span> <span class="o">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"head of empty list"</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"tail of empty list"</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>The <code>::</code> object</strong>

<ul>
<li>pronounced <strong>cons</strong>, represents non-empty lists</li>
<li>the pattern <code>x :: xs</code> is treated as <code>::(x, xs)</code>, which is treated as <code>xs.::(x)</code>
</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// idealized implementation (the real deal on page 511)</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">::</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">hd</span>
  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="n">tl</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="c1">// since definitions of 'head' and 'tail' simply return the corresponding param, we can</span>
<span class="c1">// write the code so that it directly uses the parameters as implementations of the</span>
<span class="c1">// abstract methods 'head' and 'tail' that were inherited from class 'List'</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">::</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">head</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span> <span class="n">tail</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>
<span class="c1">// this works because every 'case class' param is implicitly also a field</span>
<span class="c1">// as if param declaration was prefixed with the 'val' keyword</span>
</pre></div>

<blockquote>
<ul>
<li><strong>Some more methods</strong></li>
<li>all other <code>List</code> methods can be elegantly written using the basic three, e.g.:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">def</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">tail</span><span class="o">.</span><span class="n">length</span>

<span class="k">def</span> <span class="n">drop</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">Nil</span>
  <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="o">)</span> <span class="k">this</span>
  <span class="k">else</span> <span class="n">tail</span><span class="o">.</span><span class="n">drop</span><span class="o">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>

<span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">)</span> <span class="nc">Nil</span>
  <span class="k">else</span> <span class="n">f</span><span class="o">(</span><span class="n">head</span><span class="o">)</span> <span class="o">::</span> <span class="n">tail</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
</pre></div>

<p><strong>507 - List construction</strong></p>

<blockquote>
<ul>
<li>
<code>::</code> method should take an element value and yield a new list</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Fruit</span>
<span class="k">class</span> <span class="nc">Apple</span> <span class="k">extends</span> <span class="nc">Fruit</span>
<span class="k">class</span> <span class="nc">Orange</span> <span class="k">extends</span> <span class="nc">Fruit</span>

<span class="k">val</span> <span class="n">apples</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Apple</span> <span class="o">::</span> <span class="nc">Nil</span>      <span class="c1">// apples: List[Apple]</span>
<span class="k">val</span> <span class="n">fruits</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Orange</span> <span class="o">::</span> <span class="n">apples</span>  <span class="c1">// fruits: List[Fruit] - most precise common supertype</span>

<span class="c1">// this flexibility is obtained by defining the 'cons' method as:</span>
<span class="k">def</span> <span class="o">::[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.::(</span><span class="n">x</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>

<span class="c1">// the method is itself polymorphic:</span>
<span class="c1">// 'U' is constrained to be a supertype of the list element type 'T'</span>
</pre></div>

<blockquote>
<ul>
<li>when the code above is executed the result type is widened as necessary to include the types of all list elements</li>
</ul>
</blockquote>

<p><img src="https://github.com/mbonaci/scala/blob/master/resources/Scala-polymorphic-list-construction.png?raw=true" alt="Polymorphic list construction"></p>

<blockquote>
<ul>
<li>first, the type parameter <code>U</code> of <code>::</code> is instantiated to <code>Fruit</code>
</li>
<li>the lower-bound constraint of <code>U</code> is satisfied, because the list <code>apples</code> has type <code>List[Apple]</code> and <code>Fruit</code> is supertype of <code>Apple</code>
</li>
<li>the argument to the <code>::</code> is <code>new Orange</code>, which conforms to type <code>Fruit</code>
</li>
<li>therefore, the method is type-correct with result type <code>List[Fruit]</code>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">def</span> <span class="o">:::[</span><span class="kt">U</span> <span class="k">&gt;:</span> <span class="kt">T</span><span class="o">](</span><span class="n">prefix</span><span class="k">:</span> <span class="kt">MyList</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span><span class="k">:</span> <span class="kt">MyList</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="k">this</span>
  <span class="k">else</span> <span class="n">prefix</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">prefix</span><span class="o">.</span><span class="n">tail</span> <span class="o">:::</span> <span class="k">this</span>

<span class="c1">// the infix operations can be expanded to equivalent method calls:</span>
<span class="n">prefix</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">prefix</span><span class="o">.</span><span class="n">tail</span> <span class="o">:::</span> <span class="k">this</span>
  <span class="c1">// equals (because '::' and ':::' are right-associative)</span>
<span class="n">prefix</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="n">tail</span> <span class="o">:::</span> <span class="k">this</span><span class="o">)</span>
  <span class="c1">// equals (because '::' binds to the right)</span>
<span class="o">(</span><span class="n">prefix</span><span class="o">.</span><span class="n">tail</span> <span class="o">:::</span> <span class="k">this</span><span class="o">).::(</span><span class="n">prefix</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
  <span class="c1">// equals (because ':::' binds to the right)</span>
<span class="k">this</span><span class="o">.:::(</span><span class="n">prefix</span><span class="o">.</span><span class="n">tail</span><span class="o">).::(</span><span class="n">prefix</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
</pre></div>

<p><strong>509 - The <code>ListBuffer</code> class</strong></p>

<blockquote>
<ul>
<li>the typical access pattern for a list is recursive, e.g. to increment every element without using <code>map</code>:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">def</span> <span class="n">incAll</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">xs</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">List</span><span class="o">()</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">()</span>
  <span class="k">case</span> <span class="n">x</span> <span class="o">::</span> <span class="n">xs1</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">::</span> <span class="n">incAll</span><span class="o">(</span><span class="n">xs1</span><span class="o">)</span>  <span class="c1">// not tail recursive (call is inside '::')</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>since the function is not tail recursive, each call allocates a new stack frame</li>
<li>this means that you cannot use <code>incAll</code> on list with more than 30k to 50k elements</li>
<li>
<strong>list buffers</strong> let you accumulate the elements of a list</li>
<li>
<strong>ListBuffer</strong> is a class in package <code>scala.collection.mutable</code>
</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// increment all elements of a list using 'ListBuffer':</span>
<span class="k">def</span> <span class="n">incAll</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="n">buf</span> <span class="o">+=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">buf</span><span class="o">.</span><span class="n">toList</span>
<span class="o">}</span>
<span class="c1">// both '+=' and 'toList' take constant time</span>
</pre></div>

<p><strong>511 - The <code>List</code> class in practice</strong></p>

<blockquote>
<ul>
<li>most methods in the real implementation of class <code>List</code> avoid recursion (even if it's tail call optimized) and use loops with list buffers instead</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// the real implementation of 'map' method:</span>
<span class="k">final</span> <span class="k">override</span> <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span>
  <span class="k">var</span> <span class="n">these</span> <span class="k">=</span> <span class="k">this</span>
  <span class="k">while</span> <span class="o">(!</span><span class="n">these</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// highly efficient</span>
    <span class="n">b</span> <span class="o">+=</span> <span class="n">f</span><span class="o">(</span><span class="n">these</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
    <span class="n">these</span> <span class="k">=</span> <span class="n">these</span><span class="o">.</span><span class="n">tail</span>
  <span class="o">}</span>
  <span class="n">b</span><span class="o">.</span><span class="n">toList</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>a tail recursive implementation would be similarly efficient, but a general recursive implementation would be slower and less scalable</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// the real implementation of '::' method:</span>
<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">::</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">hd</span><span class="k">:</span> <span class="kt">U</span><span class="o">,</span> <span class="k">private</span><span class="o">[</span><span class="kt">scala</span><span class="o">]</span> <span class="k">var</span> <span class="n">tl</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">extends</span> <span class="nc">List</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">head</span> <span class="k">=</span> <span class="n">hd</span>
  <span class="k">def</span> <span class="n">tail</span> <span class="k">=</span> <span class="n">tl</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">isEmpty</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="c1">// 'tl' is a 'var' - possible to modify the tail of a list after it's constructed</span>
<span class="c1">// 'private[scala]' - accessible only from within 'scala' package</span>
<span class="c1">// the client code outside 'scala' package can neither read nor write 'tl'</span>
<span class="c1">// 'ListBuffer', since it is contained in subpackage of 'scala', can access 'tl' field</span>
</pre></div>

<blockquote>
<ul>
<li>the elements of a list buffer are represented as a list and appending new elements involves modification of 'tl' field of the last '::' cell in that list</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// 'ListBuffer' implementation:</span>
<span class="k">package</span> <span class="nn">scala.collection.mutable</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="nc">extends</span> <span class="nc">Buffer</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">start</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Nil</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">last0</span><span class="k">:</span> <span class="kt">::</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">_</span>
  <span class="k">private</span> <span class="k">var</span> <span class="n">exported</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="kc">false</span>
  <span class="c1">// ...</span>

<span class="c1">// start    - points to the list of all elements stored in the buffer</span>
<span class="c1">// last0    - points to the last :: cell in that list</span>
<span class="c1">// exported - indicates whether the buffer has been turned into a list using 'toList'</span>

<span class="k">override</span> <span class="k">def</span> <span class="n">toList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">exported</span> <span class="k">=</span> <span class="o">!</span><span class="n">start</span><span class="o">.</span><span class="n">isEmpty</span>
  <span class="n">start</span>
<span class="o">}</span>
<span class="c1">// very efficient, since it doesn't copy the list which is stored in list buffer</span>

<span class="c1">// once a list is returned from 'toList', it must be immutable, but appending to the</span>
<span class="c1">// 'last0' will modify the 'start' list</span>
<span class="c1">// to maintain correctness, we work on a fresh list instead:</span>
<span class="k">override</span> <span class="k">def</span> <span class="o">+=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">exported</span><span class="o">)</span> <span class="n">copy</span><span class="o">()</span>  <span class="c1">// maintain correctness</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">start</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">last</span> <span class="mi">0</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.::(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="n">start</span> <span class="k">=</span> <span class="n">last0</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">last1</span> <span class="k">=</span> <span class="n">last0</span>
    <span class="n">last0</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.::(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
    <span class="n">last1</span><span class="o">.</span><span class="n">tl</span> <span class="k">=</span> <span class="n">last0</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// most use cases add elements incrementally and then do one 'toList' call at the end</span>
</pre></div>

<p><strong>513 - Functional on the outside</strong></p>

<blockquote>
<ul>
<li>lists are purely functional on the outside, but have an imperative implementation using list buffers on the inside</li>
<li>a typical strategy in Scala programming is to combine purity with efficiency by carefully delimiting the effects of impure operations</li>
<li>Scala opts for pervasive sharing and no mutation for lists</li>
<li>
<code>ListBuffer</code> still allows you to build up lists imperatively and incrementally</li>
</ul>
</blockquote>

<h3>
<a name="for-expressions-revisited" class="anchor" href="#for-expressions-revisited"><span class="octicon octicon-link"></span></a>For Expressions Revisited</h3>

<blockquote>
<ul>
<li>all <code>for</code> expressions that <code>yield</code> a result are translated by the compiler into combination of higher-order methods <code>map</code>, <code>flatMap</code> and <code>withFilter</code>
</li>
<li>all <code>for</code> expressions without <code>yield</code> are translated into combination of <code>withFilter</code> and <code>foreach</code>
</li>
</ul>
</blockquote>

<p><strong>518 - For expressions</strong></p>

<blockquote>
<ul>
<li>generally, a <code>for</code> expression is of the form <code>for (seq) yield expr</code>, where <code>seq</code> is a sequence of <strong>generators</strong>, <strong>definitions</strong> and <strong>filters</strong> with semicolon between successive elements</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">for</span> <span class="o">(</span><span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span><span class="o">;</span> <span class="n">n</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span><span class="o">;</span> <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="n">startsWith</span> <span class="s">"To"</span><span class="o">))</span> <span class="k">yield</span> <span class="n">n</span>

<span class="c1">// if you replace parentheses with curly braces, semicolons become optional:</span>
<span class="k">for</span> <span class="o">{</span>
  <span class="n">p</span> <span class="k">&lt;-</span> <span class="n">persons</span>            <span class="c1">// generator</span>
  <span class="n">n</span> <span class="k">=</span> <span class="n">p</span><span class="o">.</span><span class="n">name</span>              <span class="c1">// definition (has the same effect as 'val' definition)</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="n">startsWith</span> <span class="s">"To"</span><span class="o">)</span>  <span class="c1">// filter</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">n</span>
</pre></div>

<p><strong>519 - The n-queens problem</strong></p>

<blockquote>
<ul>
<li>a particularly suitable application area of for expressions are combinatorial puzzles</li>
<li>an example of such a puzzle is the n-queens problem, where 'n' queens are supposed to be placed on a 'n x n' board, each queen in its own row, such that no two queens check one another</li>
<li>the goal is to find all possible solutions that match the given requirements:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">def</span> <span class="n">queens</span><span class="o">(</span><span class="n">n</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">placeQueens</span><span class="o">(</span><span class="n">k</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
      <span class="nc">List</span><span class="o">(</span><span class="nc">List</span><span class="o">())</span>
    <span class="k">else</span>
      <span class="k">for</span> <span class="o">{</span>
        <span class="n">queens</span> <span class="k">&lt;-</span> <span class="n">placeQueens</span><span class="o">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
        <span class="n">column</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">n</span>
        <span class="n">queen</span> <span class="k">=</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">column</span><span class="o">)</span>
        <span class="k">if</span> <span class="n">isSafe</span><span class="o">(</span><span class="n">queen</span><span class="o">,</span> <span class="n">queens</span><span class="o">)</span>
      <span class="o">}</span> <span class="k">yield</span> <span class="n">queen</span> <span class="o">::</span> <span class="n">queens</span>

  <span class="n">placeQueens</span><span class="o">(</span><span class="n">n</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">def</span> <span class="n">isSafe</span><span class="o">(</span><span class="n">queen</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">),</span> <span class="n">queens</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)])</span> <span class="k">=</span>
  <span class="n">queens</span> <span class="n">forall</span> <span class="o">(</span><span class="n">q</span> <span class="k">=&gt;</span> <span class="o">!</span><span class="n">inCheck</span><span class="o">(</span><span class="n">queen</span><span class="o">,</span> <span class="n">q</span><span class="o">))</span>

<span class="k">def</span> <span class="n">inCheck</span><span class="o">(</span><span class="n">q1</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">),</span> <span class="n">q2</span><span class="k">:</span> <span class="o">(</span><span class="kt">Int</span><span class="o">,</span> <span class="kt">Int</span><span class="o">))</span> <span class="k">=</span>
  <span class="n">q1</span><span class="o">.</span><span class="n">_2</span> <span class="o">==</span> <span class="n">q2</span><span class="o">.</span><span class="n">_2</span> <span class="o">||</span>  <span class="c1">// in the same column</span>
  <span class="o">(</span><span class="n">q1</span><span class="o">.</span><span class="n">_1</span> <span class="o">-</span> <span class="n">q2</span><span class="o">.</span><span class="n">_1</span><span class="o">).</span><span class="n">abs</span> <span class="o">==</span> <span class="o">(</span><span class="n">q1</span><span class="o">.</span><span class="n">_2</span> <span class="o">-</span> <span class="n">q2</span><span class="o">.</span><span class="n">_2</span><span class="o">).</span><span class="n">abs</span>  <span class="c1">// in diagonal</span>


<span class="k">def</span> <span class="n">printSolutions</span><span class="o">(</span><span class="n">tbls</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)]])</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">printSolution</span><span class="o">(</span><span class="n">row</span><span class="k">:</span> <span class="kt">List</span><span class="o">[(</span><span class="kt">Int</span>, <span class="kt">Int</span><span class="o">)])</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">len</span> <span class="k">=</span> <span class="n">row</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">_1</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"_"</span> <span class="o">*</span> <span class="o">(</span><span class="n">len</span> <span class="o">*</span> <span class="mi">2</span><span class="o">))</span>
    <span class="k">val</span> <span class="n">tbl</span> <span class="k">=</span> 
      <span class="k">for</span> <span class="o">{</span>
        <span class="n">pos</span> <span class="k">&lt;-</span> <span class="n">row</span><span class="o">.</span><span class="n">reverse</span>
        <span class="n">col</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="n">len</span>
        <span class="n">pipe</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">col</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="s">"|"</span> <span class="k">else</span> <span class="s">""</span>
        <span class="n">mark</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">col</span> <span class="o">==</span> <span class="n">pos</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span> <span class="s">"Q|"</span> <span class="k">else</span> <span class="s">"_|"</span>
        <span class="n">nl</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">col</span> <span class="o">==</span> <span class="n">len</span><span class="o">)</span> <span class="s">"\n"</span> <span class="k">else</span> <span class="s">""</span>
      <span class="o">}</span> <span class="n">print</span><span class="o">(</span><span class="n">pipe</span> <span class="o">+</span> <span class="n">mark</span> <span class="o">+</span> <span class="n">nl</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">tbl</span> <span class="k">&lt;-</span> <span class="n">tbls</span><span class="o">)</span> <span class="n">printSolution</span><span class="o">(</span><span class="n">tbl</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>

<p><strong>522 - Querying with <code>for</code> expressions</strong></p>

<blockquote>
<ul>
<li>the <code>for</code> notation is essentially equivalent to common operations of database query languages</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// a db table 'books' might be represented as a list of books:</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Book</span><span class="o">(</span><span class="n">title</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">authors</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span>

<span class="k">val</span> <span class="n">books</span> <span class="k">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Book</span><span class="o">]</span> <span class="k">=</span> 
  <span class="nc">List</span><span class="o">(</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">"Essential JavaScript design patterns"</span><span class="o">,</span> <span class="s">"Addi Osmani"</span><span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">"Developing backbone.js applications"</span><span class="o">,</span> <span class="s">"Addi Osmani"</span><span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">"Effective JavaScript"</span><span class="o">,</span> <span class="s">"Dave Herman"</span><span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">"JavaScript: The good parts"</span><span class="o">,</span> <span class="s">"Douglas Crockford"</span><span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">"AngularJS"</span><span class="o">,</span> <span class="s">"Brad Green"</span><span class="o">,</span> <span class="s">"Shyam Seshadri"</span><span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">"Taming text"</span><span class="o">,</span> <span class="s">"Grant S. Ingersoll"</span><span class="o">,</span> <span class="s">"Thomas S. Morton"</span><span class="o">,</span> <span class="s">"Andrew L. Farris"</span><span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">"Graph Databases"</span><span class="o">,</span> <span class="s">"Ian Robinson"</span><span class="o">,</span> <span class="s">"Jim Webber"</span><span class="o">,</span> <span class="s">"Emil Eifrem"</span><span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">"Node.js in action"</span><span class="o">,</span> <span class="s">"Mike Cantelon"</span><span class="o">,</span> <span class="s">"TJ Holowaychuk"</span><span class="o">,</span> <span class="s">"Nathan Rajlich"</span><span class="o">),</span>
    <span class="nc">Book</span><span class="o">(</span>
      <span class="s">"ClojureScript up and running"</span><span class="o">,</span> <span class="s">"Stuart Sierra"</span><span class="o">,</span> <span class="s">"Luke VanderHart"</span><span class="o">)</span>
  <span class="o">)</span>

<span class="c1">// to find the titles of all books whose author's first name starts with "A":</span>
<span class="k">val</span> <span class="n">aAuthors</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">a</span> <span class="k">&lt;-</span> <span class="n">b</span><span class="o">.</span><span class="n">authors</span> <span class="k">if</span> <span class="n">a</span> <span class="n">startsWith</span> <span class="s">"A"</span><span class="o">)</span>
  <span class="k">yield</span> <span class="n">b</span><span class="o">.</span><span class="n">title</span>

<span class="c1">// to find the titles of all books that have "JavaScript" in title</span>
<span class="k">val</span> <span class="n">js</span> <span class="k">=</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">b</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="o">(</span><span class="n">b</span><span class="o">.</span><span class="n">title</span> <span class="n">indexOf</span> <span class="s">"JavaScript"</span><span class="o">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">)</span>
  <span class="k">yield</span> <span class="n">b</span><span class="o">.</span><span class="n">title</span>

<span class="c1">// to find the names of all authors that have written at least 2 books</span>
<span class="k">val</span> <span class="n">two</span> <span class="k">=</span> 
  <span class="k">for</span> <span class="o">(</span><span class="n">b1</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> 
       <span class="n">b2</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">;</span>
       <span class="n">a1</span> <span class="k">&lt;-</span> <span class="n">b1</span><span class="o">.</span><span class="n">authors</span><span class="o">;</span> <span class="n">a2</span> <span class="k">&lt;-</span> <span class="n">b2</span><span class="o">.</span><span class="n">authors</span> <span class="k">if</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="o">)</span>
  <span class="k">yield</span> <span class="n">a1</span>

<span class="k">def</span> <span class="n">removeDuplicates</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">xs</span>
  <span class="k">else</span> <span class="o">{</span>
    <span class="c1">// take head and compare with all in tail</span>
    <span class="c1">// then repeat the same thing with tail</span>
    <span class="n">xs</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">removeDuplicates</span><span class="o">(</span>
      <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">.</span><span class="n">tail</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span>
    <span class="o">)</span>

   <span class="c1">// the same thing with filter</span>
   <span class="c1">// remove from tail if element equals head</span>
    <span class="n">xs</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">removeDuplicates</span><span class="o">(</span>
      <span class="n">xs</span><span class="o">.</span><span class="n">tail</span> <span class="n">filter</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">xs</span><span class="o">.</span><span class="n">head</span><span class="o">)</span>
    <span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p><strong>524 - Translation of <code>for</code> expressions</strong></p>

<blockquote>
<ul>
<li>how the compiler translates <code>for</code> expressions to higher-order function calls</li>
<li><strong>Translating <code>for</code> expressions with one generator</strong></li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// a simple 'for' expression:</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr2</span>
<span class="c1">// is translated to:</span>
<span class="n">expr1</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">expr2</span><span class="o">)</span>
</pre></div>

<blockquote>
<ul>
<li><strong>Translating <code>for</code> expressions starting with a generator and a filter</strong></li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// a 'for' expression that combine a leading generator with some other elements:</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span> <span class="k">if</span> <span class="n">expr2</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr3</span>
<span class="c1">// is translated to 'for' with one less element:</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">expr2</span><span class="o">))</span> <span class="k">yield</span> <span class="n">expr3</span>
<span class="c1">// and then to:</span>
<span class="n">expr1</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">expr2</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">expr3</span><span class="o">)</span>

<span class="c1">// the same translation scheme applies if there are further elements following the filter</span>
<span class="c1">// if 'seq' is an arbitrary sequence of generators, definitions and filters, then:</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span> <span class="k">if</span> <span class="n">expr2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr3</span>
<span class="c1">// is translated to:</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span> <span class="n">withFilter</span> <span class="n">expr2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr3</span>
<span class="c1">// and then translation continues with the second expression which is shorter by one elem</span>
</pre></div>

<blockquote>
<ul>
<li><strong>Translating <code>for</code> expressions starting with two generators</strong></li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">expr2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr3</span>
<span class="c1">// is translated to:</span>
<span class="n">expr1</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="k">for</span> <span class="o">(</span><span class="n">y</span> <span class="k">&lt;-</span> <span class="n">expr2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr3</span><span class="o">)</span>
<span class="c1">// the inner 'for' expression is also translated with the same rules</span>

<span class="c1">// the previous "query" example:</span>
<span class="k">for</span> <span class="o">(</span><span class="n">b1</span> <span class="k">&lt;-</span> <span class="n">books</span><span class="o">;</span> <span class="n">b2</span> <span class="k">&lt;-</span> <span class="n">books</span> <span class="k">if</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">;</span>
     <span class="n">a1</span> <span class="k">&lt;-</span> <span class="n">b1</span><span class="o">.</span><span class="n">authors</span><span class="o">;</span> <span class="n">a2</span> <span class="k">&lt;-</span> <span class="n">b2</span><span class="o">.</span><span class="n">authors</span> <span class="k">if</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a1</span><span class="o">)</span>
<span class="k">yield</span> <span class="n">a1</span>

<span class="c1">// is translated to:</span>
<span class="n">books</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">b1</span> <span class="k">=&gt;</span>
  <span class="n">books</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">b2</span> <span class="k">=&gt;</span> <span class="n">b1</span> <span class="o">!=</span> <span class="n">b2</span><span class="o">)</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">b2</span> <span class="k">=&gt;</span>
    <span class="n">b1</span><span class="o">.</span><span class="n">authors</span> <span class="n">flatMap</span> <span class="o">(</span><span class="n">a1</span> <span class="k">=&gt;</span>
      <span class="n">b2</span><span class="o">.</span><span class="n">authors</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">a2</span> <span class="k">=&gt;</span> <span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="n">a2</span> <span class="k">=&gt;</span>
        <span class="n">a1</span><span class="o">))))</span>
</pre></div>

<blockquote>
<ul>
<li>these were all examples where generators bind simple variables (as opposed to patterns) and with no definitions</li>
<li><strong>Translating patterns in generators</strong></li>
<li>the translation scheme becomes more complicated if the left hand side of generator is a pattern ('pat')</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// if instead if simple variable tuple appears:</span>
<span class="k">for</span> <span class="o">((</span><span class="n">x1</span><span class="o">,</span> <span class="o">...,</span> <span class="n">xn</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr2</span>
<span class="c1">// translates to:</span>
<span class="n">expr1</span><span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">x1</span><span class="o">,</span> <span class="o">...,</span> <span class="n">xn</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">expr2</span> <span class="o">}</span>

<span class="c1">// if a single pattern is involved:</span>
<span class="k">for</span> <span class="o">(</span><span class="n">pat</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr2</span>
<span class="c1">// translates to:</span>
<span class="n">expr1</span> <span class="n">withFilter</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span> <span class="n">map</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">pat</span> <span class="k">=&gt;</span> <span class="n">expr2</span>
<span class="o">}</span>

<span class="c1">// the generated items are first filtered with pattern matching</span>
<span class="c1">// and only the remaining ones are mapped</span>
<span class="c1">// so it's guaranteed that a pattern-matching generator will never throw a 'MatchError'</span>
</pre></div>

<blockquote>
<ul>
<li><strong>Translating definitions</strong></li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// if a 'for' expression contains embedded definitions:</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">;</span> <span class="n">y</span> <span class="k">=</span> <span class="n">expr2</span><span class="o">;</span> <span class="n">seq</span><span class="o">)</span> <span class="k">yield</span> <span class="n">expr3</span>
<span class="c1">// is translated to:</span>
<span class="k">for</span> <span class="o">((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">)</span> <span class="k">yield</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">expr2</span><span class="o">);</span> <span class="n">seq</span><span class="o">)</span>
<span class="k">yield</span> <span class="n">expr3</span>

<span class="c1">// 'expr2' is evaluated every time a new 'x' value is generated</span>
<span class="c1">// which is necessary because 'expr2' might depend on 'x'</span>
<span class="c1">// so it's not a good idea to have definitions in 'for' expressions that do not refer</span>
<span class="c1">// to variables bound by some preceding generator, because reevaluating such </span>
<span class="c1">// expressions is wasteful, e.g. instead of:</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">1000</span><span class="o">;</span> <span class="n">y</span> <span class="k">=</span> <span class="n">expensiveComputationNotInvolvingX</span><span class="o">)</span>
<span class="k">yield</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="c1">// it's better to write:</span>
<span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="n">expensiveComputationNotInvolvingX</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">1000</span><span class="o">)</span> <span class="k">yield</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</pre></div>

<blockquote>
<ul>
<li><strong>Translating <code>for</code> loops</strong></li>
<li>the translation of <code>for</code> loops that perform a side effect without returning anything is similar, but simpler than <code>for</code> expressions</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// wherever the previous translations used 'map' or 'flatMap', we use 'foreach':</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">)</span> <span class="n">body</span>
<span class="c1">// translates to:</span>
<span class="n">expr1</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">body</span><span class="o">)</span>

<span class="c1">// or slightly larger example:</span>
<span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">expr1</span><span class="o">;</span> <span class="k">if</span> <span class="n">expr2</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">expr3</span><span class="o">)</span> <span class="n">body</span>
<span class="c1">// translates to:</span>
<span class="n">expr1</span> <span class="n">withFilter</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">expr2</span><span class="o">)</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> 
  <span class="n">expr3</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">y</span> <span class="k">=&gt;</span> <span class="n">body</span><span class="o">))</span>

<span class="c1">// for example, summing up all elements of a matrix represented as list of lists:</span>
<span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="o">(</span><span class="n">xs</span> <span class="k">&lt;-</span> <span class="n">xss</span><span class="o">;</span> <span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span>
<span class="c1">// is translated into two nested 'foreach' applications:</span>
<span class="k">var</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">0</span>
<span class="n">xss</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">xs</span> <span class="k">=&gt;</span> 
  <span class="n">xs</span> <span class="n">foreach</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">x</span><span class="o">))</span>
</pre></div>

<p><strong>528 - Going the other way</strong></p>

<blockquote>
<ul>
<li>every application of a <code>map</code>, <code>flatMap</code> and <code>withFilter</code> can be represented as a <code>for</code> expression</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">object</span> <span class="nc">ReversedTranslationDemo</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">)</span> <span class="k">yield</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>

  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">A</span>, <span class="kt">B</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span><span class="o">;</span> <span class="n">y</span> <span class="k">&lt;-</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">y</span>

  <span class="k">def</span> <span class="n">filter</span><span class="o">[</span><span class="kt">A</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">],</span> <span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="n">xs</span> <span class="k">if</span> <span class="n">p</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="k">yield</span> <span class="n">x</span>

  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>
    <span class="k">def</span> <span class="n">f1</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">def</span> <span class="n">f2</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span> <span class="n">to</span> <span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)).</span><span class="n">toList</span>
    <span class="k">def</span> <span class="n">f3</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="k">val</span> <span class="n">mapped</span> <span class="k">=</span> <span class="n">map</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">f1</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">flatmapped</span> <span class="k">=</span> <span class="n">flatMap</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">f2</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">filtered</span> <span class="k">=</span> <span class="n">filter</span><span class="o">(</span><span class="n">xs</span><span class="o">,</span> <span class="n">f3</span><span class="o">)</span>

    <span class="n">println</span><span class="o">(</span><span class="n">mapped</span><span class="o">)</span>      <span class="c1">// List(2, 3, 4, 5)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">flatmapped</span><span class="o">)</span>  <span class="c1">// List(1, 2, 2, 3, 3, 4, 4, 5)</span>
    <span class="n">println</span><span class="o">(</span><span class="n">filtered</span><span class="o">)</span>    <span class="c1">// List(2, 4)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p><strong>529 - Generalizing <code>for</code></strong></p>

<blockquote>
<ul>
<li>it is possible to apply <code>for</code> notation to every type that defines <code>map</code>, <code>flatMap</code>, <code>withFilter</code> or <code>foreach</code>
</li>
<li>if a type defines:

<ul>
<li>just <code>map</code>, it allows <code>for</code> expressions with a single generator</li>
<li>
<code>map</code> and <code>flatMap</code> - more than one generator</li>
<li>
<code>foreach</code> - it allows <code>for loops</code> (with single and multiple generators)</li>
<li>
<code>withFilter</code> - it allows filter expressions starting with an <code>if</code> inside <code>for</code>
</li>
</ul>
</li>
<li>the translation happens before type checking, which allows maximal flexibility, because it is only required that the result of expansion type checks</li>
<li>Scala defines no typing rules for <code>for</code> expressions and doesn't require that methods <code>map</code>, <code>flatMap</code>, <code>withFilter</code> and <code>foreach</code> to have any particular type signatures</li>
<li>nevertheless, there is a typical setup that captures most common intention of the higher order methods to which <code>for</code> expressions translate:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="c1">// a class that would be used for a collection 'C' of elements 'A':</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">flatMap</span><span class="o">[</span><span class="kt">B</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">C</span><span class="o">[</span><span class="kt">B</span><span class="o">])</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">withFilter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">C</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">foreach</span><span class="o">(</span><span class="n">b</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="nc">Unit</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span>
<span class="o">}</span>
</pre></div>

<h3>
<a name="the-scala-collections-api" class="anchor" href="#the-scala-collections-api"><span class="octicon octicon-link"></span></a>The Scala Collections API</h3>

<p><strong>534 - Mutable an immutable collections</strong></p>

<blockquote>
<ul>
<li>there are 4 packages with collection types:

<ul>
<li>
<strong>scala.collection</strong> - may be changed by other parties in run time</li>
<li>
<strong>scala.collection.immutable</strong> - collection changes in place</li>
<li>
<strong>scala.collection.mutable</strong> - guaranteed to be immutable for everyone</li>
<li>
<strong>scala.collection.generic</strong> - provide building blocks for implementing collections</li>
</ul>
</li>
<li>typically, collection classes defer the implementation of some of their operations to classes in <code>generic</code>
</li>
</ul>
</blockquote>

<p><strong>535 - Collections consistency</strong></p>

<div class="highlight"><pre><span class="c1">// the most important collection classes:</span>
<span class="nc">Traversable</span>
  <span class="nc">Iterable</span>
    <span class="nc">Seq</span>
      <span class="nc">IndexedSeq</span>
        <span class="nc">Vector</span>
        <span class="nc">ResizableArray</span>
        <span class="nc">GenericArray</span>
      <span class="nc">LinearSeq</span>
        <span class="nc">MutableList</span>
        <span class="nc">List</span>
        <span class="nc">Stream</span>
      <span class="nc">Buffer</span>
        <span class="nc">ListBuffer</span>
        <span class="nc">ArrayBuffer</span>
    <span class="nc">Set</span>
      <span class="nc">SortedSet</span>
        <span class="nc">TreeSet</span>
      <span class="nc">HashSet</span> <span class="o">(</span><span class="n">mutable</span><span class="o">)</span>
      <span class="nc">LinkedHashSet</span>
      <span class="nc">HashSet</span> <span class="o">(</span><span class="n">immutable</span><span class="o">)</span>
      <span class="nc">BitSet</span>
      <span class="nc">EmptySet</span><span class="o">,</span> <span class="nc">Set1</span><span class="o">,</span> <span class="nc">Set2</span><span class="o">,</span> <span class="nc">Set3</span><span class="o">,</span> <span class="nc">Set4</span>
    <span class="nc">Map</span>
      <span class="nc">SortedMap</span>
        <span class="nc">TreeMap</span>
      <span class="nc">HashMap</span> <span class="o">(</span><span class="n">mutable</span><span class="o">)</span>
      <span class="nc">LinkedHashMap</span> <span class="o">(</span><span class="n">mutable</span><span class="o">)</span>
      <span class="nc">HashMap</span> <span class="o">(</span><span class="n">immutable</span><span class="o">)</span>
      <span class="nc">EmptyMap</span><span class="o">,</span> <span class="nc">Map1</span><span class="o">,</span> <span class="nc">Map2</span><span class="o">,</span> <span class="nc">Map3</span><span class="o">,</span> <span class="nc">Map4</span>
</pre></div>

<blockquote>
<ul>
<li>there is a quite a bit commonality shared by all these classes, e.g. every kind of collection can be created by the same uniform syntax:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="nc">Traversable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="nc">Iterable</span><span class="o">(</span><span class="s">"x"</span><span class="o">,</span> <span class="s">"y"</span><span class="o">,</span> <span class="s">"z"</span><span class="o">)</span>
<span class="nc">Map</span><span class="o">(</span><span class="s">"x"</span> <span class="o">-&gt;</span> <span class="mi">24</span><span class="o">,</span> <span class="s">"y"</span> <span class="o">-&gt;</span> <span class="mi">25</span><span class="o">)</span>
<span class="nc">Set</span><span class="o">(</span><span class="nc">Color</span><span class="o">.</span><span class="nc">Red</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Green</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span><span class="o">)</span>
<span class="nc">SortedSet</span><span class="o">(</span><span class="s">"hello"</span><span class="o">,</span> <span class="s">"world"</span><span class="o">)</span>
<span class="nc">Buffer</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span>
<span class="nc">IndexedSeq</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span>
<span class="nc">LinearSeq</span><span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span>
</pre></div>

<p><strong>537 - Trait <code>Traversable</code></strong></p>

<blockquote>
<ul>
<li>on top of the collection hierarchy</li>
<li>its only <em>abstract</em> operation is <code>foreach</code>:</li>
</ul>
</blockquote>

<div class="highlight"><pre><span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span>  <span class="c1">// 'U` - arbitrary result type</span>
</pre></div>

<blockquote>
<ul>
<li>collection classes that mix in <code>Traversable</code>, just need to implement the <code>foreach</code> method, all other methods can be inherited from <code>Traversable</code>
</li>
<li>
<code>foreach</code> is supposed to traverse all elements and apply a given operation, <code>f</code>, to each element</li>
<li>
<code>f</code> is invoked only because of its side effects (result of <code>f</code> is discarded)</li>
<li>the following table lists all concrete methods of <code>Traversable</code>:</li>
</ul>
</blockquote>

<ul>
<li><strong>Abstract method</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs foreach f</code>    Executes function f for every element of xs</li>
</ul>
</blockquote>

<ul>
<li><strong>Addition</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs ++ ys</code>        A collection consisting of the elements of both xs and ys</li>
</ul>
</blockquote>

<ul>
<li><strong>Maps</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs map f</code>        The collection obtained from applying f to every element of xs</li>
<li>
<code>xs flatMap f</code>    The collection obtained by applying f to every element of xs and
                concatenating the results</li>
<li>
<code>xs collect f</code>    The collection obtained by applying partial function f to every
                element in xs for which it is defined and collecting the results</li>
</ul>
</blockquote>

<ul>
<li><strong>Conversions</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs.toArray</code>      Converts the collection to an array</li>
<li>
<code>xs.toList</code>       Converts the collection to a list</li>
<li>
<code>xs.toIterable</code>   Converts the collection to an iterable</li>
<li>
<code>xs.toSeq</code>        Converts the collection to a sequence</li>
<li>
<code>xs.toIndexedSeq</code> Converts the collection to an indexed sequence</li>
<li>
<code>xs.toStream</code>     Converts the collection to a stream (a lazily computed sequence)</li>
<li>
<code>xs.toSet</code>        Converts the collection to a set</li>
<li>
<code>xs.toMap</code>        Converts the collection of key/value pairs to a map</li>
</ul>
</blockquote>

<ul>
<li><strong>Copying</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs copyToBuffer buf</code>         Copies all elements to buffer 'buf'</li>
<li>
<code>xs copyToArray(arr, s, len)</code> Copies at most 'len' elements of 'arr', starting at 's'</li>
</ul>
</blockquote>

<ul>
<li><strong>Element retrieval</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs.head</code>         Retrieves the first element of the collection</li>
<li>
<code>xs.headOption</code>   The first element of xs in an option value, or None if xs is empty</li>
<li>
<code>xs.last</code>         The last element of the collection (or some elem. if no order)</li>
<li>
<code>xs.lastOption</code>   The last element of xs in an option value, or None if xs is empty</li>
<li>
<code>xs find p</code>       An option containing the first element in xs that satisfies p</li>
</ul>
</blockquote>

<ul>
<li><strong>Subcollections</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs.tail</code>             Returns the rest of the collection (except xs.head)</li>
<li>
<code>xs.init</code>             The rest of the collection except xs.last</li>
<li>
<code>xs slice (from, to)</code> Collection of elements from 'from', up to and excluding 'to'</li>
<li>
<code>xs take n</code>           First n elements (or some elements if no order is defined)</li>
<li>
<code>xs drop n</code>           The rest of collection (except xs take n)</li>
<li>
<code>xs takeWhile p</code>      The longest prefix of elements that satisfy p</li>
<li>
<code>xs dropWhile p</code>      The collection without prefix that satisfies p</li>
<li>
<code>xs filter p</code>         The collection of all elements that satisfy p</li>
<li>
<code>xs withFilter p</code>     A non-strict filter</li>
<li>
<code>xs filterNot p</code>      The collection of all elements that do not satisfy p</li>
</ul>
</blockquote>

<ul>
<li><strong>Subdivisions</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs splitAt n</code>    Splits xs returning pair of collections (xs take n, xs drop n)</li>
<li>
<code>xs span p</code>       Splits xs returning (xs takeWhile p, xs dropWhile p)</li>
<li>
<code>xs partition p</code>  Splits on (xs filter p, xs filterNot p)</li>
<li>
<code>xs groupBy f</code>    Partitions xs into a map of collections according to function f</li>
</ul>
</blockquote>

<ul>
<li><strong>Element conditions</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs forall p</code>     A boolean indicating whether all elements satisfy p</li>
<li>
<code>xs exists p</code>     A boolean indicating whether p holds for at least one element</li>
<li>
<code>xs count p</code>      The number of elements in xs that satisfy the predicate p</li>
</ul>
</blockquote>

<ul>
<li><strong>Folds</strong></li>
</ul><blockquote>
<ul>
<li>
<code>(z /: xs)(op)</code>        Applies operation op between successive elements, going
                     left to right, starting with z</li>
<li>
<code>(xs :\ z)(op)</code>        Applies operation op between successive elements, going
                     right to left, starting with z</li>
<li>
<code>xs.foldLeft(z)(op)</code>   Same as (z /: xs)(op)</li>
<li>
<code>xs.foldRight(z)(op)</code>  Same as (xs :\ z)(op)</li>
<li>
<code>xs reduceLeft op</code>     Applies binary operation op between successive elements of
                     non-empty collection xs, going left to right</li>
<li>
<code>xs reduceRight op</code>    Applies binary operation op between successive elements of
                     non-empty collection xs, going right to left</li>
</ul>
</blockquote>

<ul>
<li><strong>Specific folds</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs.sum</code>          The sum of all numeric element values of xs</li>
<li>
<code>xs.product</code>      The product of all numeric element values of xs</li>
<li>
<code>xs.min</code>          The minimum of the ordered element values of xs</li>
<li>
<code>xs.max</code>          The maximum of the ordered element values of xs</li>
</ul>
</blockquote>

<ul>
<li><strong>Strings</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs addString (b, start, sep, end)</code> Adds a string to StringBuilder b that allows
                                  all elems between sep enclosed in strings start
                                  and end (start, sep and end are all optional)</li>
<li>
<code>xs mkString (start, sep, end)</code>     Converts the collection to a string that shows
                                  all elems between sep enclosed in strings
                                  start and end (start, sep and end are optional)</li>
<li>
<code>xs.stringPrefix</code>                   The collection name returned from xs.toString</li>
</ul>
</blockquote>

<ul>
<li><strong>Views</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs.view</code>                  Produces a view over xs</li>
<li>
<code>xs view (from, to)</code>       Produces a view that represents elems in some index range</li>
</ul>
</blockquote>


<h3>
<a name="542---trait-iterable" class="anchor" href="#542---trait-iterable"><span class="octicon octicon-link"></span></a><strong>542 - Trait <code>Iterable</code></strong>
</h3>

<blockquote>
<ul>
<li>all methods are defined in terms of an abstract method <code>iterator</code>, which yields the collection's elements one by one</li>
<li>the <code>foreach</code> method from trait <code>Traversable</code> is implemented in <code>Iterable</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// the actual implementation</span>
<span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="n">iterator</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span> <span class="n">f</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">())</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>many subclasses of <code>Iterable</code> override this standard implementation, because they can provide more efficient implementation (performance matters, since it is the basis for all operations in <code>Traversable</code>)</li>
<li>two more methods exist in <code>Iterable</code> that return iterators <strong><code>grouped</code>** and **<code>sliding</code></strong> (they return subsequences of elements, whose maximal size is given as an argument)</li>
<li>
<code>grouped</code> chunks its elements into increments, whereas <code>sliding</code> yields a sliding window over the elements:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span>
<span class="k">val</span> <span class="n">git</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">grouped</span> <span class="mi">3</span>  <span class="c1">// returns non-empty Iterator[List[Int]]</span>
<span class="n">git</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>  <span class="c1">// List(1, 2, 3)</span>
<span class="n">git</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>  <span class="c1">// List(4, 5)</span>

<span class="k">val</span> <span class="n">sit</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">sliding</span> <span class="mi">3</span>  <span class="c1">// returns non-empty Iterator[List[Int]]</span>
<span class="n">sit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>  <span class="c1">// List(1, 2, 3)</span>
<span class="n">sit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>  <span class="c1">// List(2, 3, 4)</span>
<span class="n">sit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>  <span class="c1">// List(3, 4, 5)</span>
</pre></div>

<p><em>The summary of operations in trait <code>Iterable</code>:</em>  </p>

<ul>
<li><strong>Abstract method</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs.iterator</code>     Iterator that yields every element in the same order as <code>foreach</code>
</li>
</ul>
</blockquote>

<ul>
<li><strong>Other iterators</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs grouped size</code> Iterator that yields fixed-size chunks of the collection</li>
<li>
<code>xs sliding size</code> Iterator that yields a sliding fixed-size window of elements</li>
</ul>
</blockquote>

<ul>
<li><strong>Subcollections</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs takeRight n</code>  Collection consisting of last n elems of xs (or arbitrary)</li>
<li>
<code>xs dropRight n</code>  The rest of the collection except <code>xs takeRight n</code>
</li>
</ul>
</blockquote>

<ul>
<li><strong>Zippers</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs zip ys</code>            An iterable of pairs of corresponding elems from xs and ys</li>
<li>
<code>xs zipAll (ys, x, y)</code> An iterable of pairs, where shorter sequence is extended to
match the longer one by appending elements x or y</li>
<li>
<code>xs.zipWithIndex</code>      An iterable of pairs from xs with their indices</li>
</ul>
</blockquote>

<ul>
<li><strong>Comparison</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs sameElement ys</code>    Tests whether xs and ys have same elements in the same order</li>
</ul>
</blockquote>

<h3>
<a name="544---why-both-traversable-and-iterable" class="anchor" href="#544---why-both-traversable-and-iterable"><span class="octicon octicon-link"></span></a><strong>544 - Why both <code>Traversable</code> and <code>Iterable</code></strong>
</h3>

<blockquote>
<ul>
<li>often times it's easier or more efficient to implement <code>foreach</code> than <code>iterator</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// a class hierarchy for binary trees that have integers at the leaves:</span>
<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">PlainTree</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">Node</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span>

<span class="c1">// now assume you want to make trees traversable:</span>
<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">Tree</span> <span class="k">extends</span> <span class="nc">Traversable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>  <span class="c1">// O(N + N-1)</span>

  <span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">Node</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">f</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">Branch</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="n">foreach</span> <span class="n">f</span><span class="o">;</span> <span class="n">r</span> <span class="n">foreach</span> <span class="n">f</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// less efficient IterTree, to make iterable</span>
<span class="k">sealed</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">IterTree</span> <span class="k">extends</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">iterator</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="k">this</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="nc">IterNode</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Iterator</span><span class="o">.</span><span class="n">single</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
    <span class="k">case</span> <span class="nc">IterBranch</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">l</span><span class="o">.</span><span class="n">iterator</span> <span class="o">++</span> <span class="n">r</span><span class="o">.</span><span class="n">iterator</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">case</span> <span class="k">class</span> <span class="nc">IterBranch</span><span class="o">(</span><span class="n">left</span><span class="k">:</span> <span class="kt">IterTree</span><span class="o">,</span> <span class="n">right</span><span class="k">:</span> <span class="kt">IterTree</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IterTree</span>
<span class="k">case</span> <span class="k">class</span> <span class="nc">IterNode</span><span class="o">(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">IterTree</span>

<span class="c1">// IterTree is much less efficient since iterator concatenation method ++ </span>
<span class="c1">// makes the traversal O(N log(N))</span>
</pre></div>

<h3>
<a name="546---subcategories-of-iterable" class="anchor" href="#546---subcategories-of-iterable"><span class="octicon octicon-link"></span></a><strong>546 - Subcategories of <code>Iterable</code></strong>
</h3>

<blockquote>
<ul>
<li>in the Scala inheritance hierarchy, bellow <code>Iterable</code>, there are three traits: <code>Seq</code>, <code>Set</code> and <code>Map</code>
</li>
<li>the common characteristic is that they all implement the <code>PartialFunction</code> trait, with its <code>apply</code> and <code>isDefinedAt</code> methods</li>
<li>for sequences, <code>apply</code> is positional indexing (elems are numbered from 0):</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="nc">Seq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)(</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="mi">2</span>
</pre></div>

<blockquote>
<ul>
<li>for sets, <code>apply</code> is a membership test:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="nc">Set</span><span class="o">(</span><span class="-Symbol">'a</span><span class="err">'</span><span class="o">,</span> <span class="-Symbol">'b</span><span class="err">'</span><span class="o">,</span> <span class="-Symbol">'c</span><span class="err">'</span><span class="o">)(</span><span class="-Symbol">'b</span><span class="err">'</span><span class="o">)</span> <span class="o">==</span> <span class="kc">true</span>
</pre></div>

<blockquote>
<ul>
<li>for maps, <code>apply</code> is a selection:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="nc">Map</span><span class="o">(</span><span class="-Symbol">'a</span><span class="err">'</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="-Symbol">'b</span><span class="err">'</span> <span class="o">-&gt;</span> <span class="mi">10</span><span class="o">,</span> <span class="-Symbol">'c</span><span class="err">'</span> <span class="o">-&gt;</span> <span class="mi">100</span><span class="o">)(</span><span class="-Symbol">'b</span><span class="err">'</span><span class="o">)</span> <span class="o">==</span> <span class="mi">10</span>
</pre></div>

<h3>
<a name="546---the-sequence-traits-seq-indexedseq-and-linearseq" class="anchor" href="#546---the-sequence-traits-seq-indexedseq-and-linearseq"><span class="octicon octicon-link"></span></a><strong>546 - The sequence traits <code>Seq</code>, <code>IndexedSeq</code> and <code>LinearSeq</code></strong>
</h3>

<blockquote>
<ul>
<li>**<code>seq</code>** trait represents a kind of <code>iterable</code> that has a <code>length</code> and whose elements have fixed index positions, starting from <code>0</code> up to <code>length - 1</code>
</li>
<li>the <code>update</code> method is only available on mutable sequences, since it changes the sequence in place</li>
<li>the <code>updated</code> method always returns a new sequence and it is available on all sequences </li>
<li>each <code>Seq</code> trait has two subtraits, <code>LinearSeq</code> and <code>IndexedSeq</code>, which do not add any new operations, but each offers different performance characteristics</li>
<li>a linear sequence (e.g. <code>List</code> or <code>Stream</code>) has efficient <code>head</code> and <code>tail</code> operations</li>
<li>an indexed sequence (e.g. <code>Array</code> or <code>ArrayBuffer</code>) has efficient <code>apply</code>, <code>length</code> and (if mutable) <code>update</code> operations</li>
<li>the <code>Vector</code> class provides an interesting compromise between indexed and linear access, since it has both effectively constant time indexing overhead and constant time linear access overhead</li>
</ul>
</blockquote>

<p><em>Operations in trait <code>Seq</code>:</em>  </p>

<ul>
<li><strong>Indexing and length</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs(i)</code>                 (or <code>xs apply i</code>) The element of xs at index i</li>
<li>
<code>xs isDefinedAt i</code>      Tests whether i is contained in xs.indices</li>
<li>
<code>xs.length</code>             The length of the sequence (same as <code>size</code>)</li>
<li>
<code>xs.lengthCompare ys</code>   Returns -1 if xs is shorter than ys, +1 if it's longer, and 0 if they have the same length. Works even if one of sequences is infinite</li>
<li>
<code>xs.indices</code>            The index range of xs, extending from 0 to xs.length - 1</li>
</ul>
</blockquote>

<ul>
<li><strong>Index search</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs indexOf x</code>             The index of the first element in xs equal to x</li>
<li>
<code>xs lastIndexOf x</code>         The index of the last element in xs equal to x</li>
<li>
<code>xs indexOfSlice ys</code>       The first index of xs that begins the ys sequence</li>
<li>
<code>xs lastIndexOfSlice ys</code>   The last index of xs that begins the ys sequence</li>
<li>
<code>xs indexWhere p</code>          The index of the first element in xs that satisfies p</li>
<li>
<code>xs segmentLength (p, i)</code>  The length of the longest uninterrupted segment of elements in xs, starting with xs(i), that all satisfy the predicate p</li>
<li>
<code>xs prefixLength p</code>        The length of the longest prefix in xs that all satisfy p</li>
</ul>
</blockquote>

<ul>
<li><strong>Additions</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs += xs</code>            A new sequence consisting of x prepended to xs</li>
<li>
<code>xs :+ x</code>             A new sequence consisting of x appended to xs</li>
<li>
<code>xs padTo (len, x)</code>   The sequence resulting from appending the value x to xs until length len is reached</li>
</ul>
</blockquote>

<ul>
<li><strong>Updates</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs patch (i, ys, r)</code>  The sequence resulting from replacing r elements of xs starting with i by the patch ys</li>
<li>
<code>xs updated (i, x)</code>    A copy of xs with the element at index i replaced with x</li>
<li>
<code>xs(i) = x</code>            (or xs.update(i, x) - available only for mutable.Seqs) Changes the element of xs at index i to y</li>
</ul>
</blockquote>

<ul>
<li><strong>Sorting</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs.sorted</code>             A new sequence obtained by sorting xs using the standard ordering of the element type of xs</li>
<li>
<code>xs sortWith lessThan</code>  A new sequence obtained by sorting xs using lessThan as comparison operation</li>
<li>
<code>xs sortBy f</code>           A new sequence obtained by sorting xs in a way that the function f is first applied to two elements and then results are compared</li>
</ul>
</blockquote>

<ul>
<li><strong>Reversals</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs.reverse</code>          A sequence with the elements of xs in reverse order</li>
<li>
<code>xs.reverseIterator</code>  An iterator yielding all the elements of xs in reverse order</li>
<li>
<code>xs reverseMap f</code>     A sequence obtained by mapping f over elements of xs in reverse order</li>
</ul>
</blockquote>

<ul>
<li><strong>Comparisons</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs startsWith ys</code>        Tests whether xs starts with sequence ys</li>
<li>
<code>xs endsWith ys</code>          Tests whether xs ends with sequence ys</li>
<li>
<code>xs contains x</code>           Tests whether xs has an element equal to x</li>
<li>
<code>xs containsSlice ys</code>     Tests whether xs has a continuous subsequence ys</li>
<li>
<code>(xs corresponds ys)(p)</code>  Tests whether corresponding elements of xs and ys satisfy the binary predicate p</li>
</ul>
</blockquote>

<ul>
<li><strong>Multiset operations</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs intersect ys</code>   The multi-set intersection of xs and ys that preserves the order of elements in xs</li>
<li>
<code>xs diff ys</code>        The multi-set difference of xs and ys that preserves the order of elements in xs</li>
<li>
<code>xs union ys</code>       (or xs ++ ys) Multiset union</li>
<li>
<code>xs.distinct</code>       A subsequence of xs that contains no duplicates</li>
</ul>
</blockquote>

<h3>
<a name="550---buffers" class="anchor" href="#550---buffers"><span class="octicon octicon-link"></span></a><strong>550 - Buffers</strong>
</h3>

<blockquote>
<ul>
<li>buffers allow not only updates of existing elements, but also element insertions, removals, and efficient additions of new elements at the end of the buffer</li>
<li>buffers support element addition at the end and at the front, element insertions and element removal</li>
<li>two most common buffer implementations are <code>ListBuffer</code> and <code>ArrayBuffer</code>
</li>
</ul>
</blockquote>

<p><em>Operations in trait <code>Buffer</code>:</em>  </p>

<ul>
<li><strong>Additions</strong></li>
</ul><blockquote>
<ul>
<li>
<code>buf += x</code>               Appends element x to buffer buf and returns buf</li>
<li>
<code>buf += (x, y)</code>          Appends given elements to buf</li>
<li>
<code>buf ++= xs</code>             Appends all elements in xs to buf</li>
<li>
<code>x +=: buf</code>              Prepends element x to buf</li>
<li>
<code>xs ++=: buf</code>            Prepends all elements in xs to buf</li>
<li>
<code>buf insert (i, x)</code>      Inserts element x at index i in buf</li>
<li>
<code>buf insertAll (i, xs)</code>  Inserts all elements in xs at index i in buf</li>
</ul>
</blockquote>

<ul>
<li><strong>Removals</strong></li>
</ul><blockquote>
<ul>
<li>
<code>buf -= x</code>           Removes element x from buffer buf</li>
<li>
<code>buf remove i</code>       Removes element at index i from buf</li>
<li>
<code>buf remove (i, n)</code>  Removes n elements starting at index i from buf</li>
<li>
<code>buf trimStart n</code>    Removes first n elements from buf</li>
<li>
<code>buf trimEnd n</code>      Removes last n elements from buf</li>
<li>
<code>buf.clear()</code>        Removes all elements from buf</li>
</ul>
</blockquote>

<ul>
<li><strong>Cloning</strong></li>
</ul><blockquote>
<ul>
<li>
<code>buf.clone</code>          A new buffer with the same elements as buf</li>
</ul>
</blockquote>

<h3>
<a name="551---sets" class="anchor" href="#551---sets"><span class="octicon octicon-link"></span></a><strong>551 - Sets</strong>
</h3>

<blockquote>
<ul>
<li>Sets are iterables that contain no duplicate elements</li>
</ul>
</blockquote>

<p><em>Operations in trait <code>Set</code>:</em>  </p>

<ul>
<li><strong>Tests</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs contains x</code>   Tests whether x is an element of xs</li>
<li>
<code>xs(x)</code>           Same as <code>xs contains x</code>
</li>
<li>
<code>xs subsetOf ys</code>  Tests whether xs is a subset of ys</li>
</ul>
</blockquote>

<ul>
<li><strong>Additions</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs + x</code>          The set containing all elements of xs as well as x</li>
<li>
<code>xs + (x, y, z)</code>  The set containing all elements of xs as well as x, y and z</li>
<li>
<code>xs ++ ys</code>        The set containing all elements of xs and of ys</li>
</ul>
</blockquote>

<ul>
<li><strong>Removals</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs - x</code>          The set containing all elements of xs except x</li>
<li>
<code>xs - (x, y, z)</code>  The set containing all elements of xs except x, y and z</li>
<li>
<code>xs -- ys</code>        The set containing all elements of xs except elements of ys</li>
<li>
<code>xs.empty</code>        An empty set of the same class as xs</li>
</ul>
</blockquote>

<ul>
<li><strong>Binary operations</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs &amp; ys</code>          The set intersection of xs and ys</li>
<li>
<code>xs intersect ys</code>  Same as <code>xs &amp; ys</code>
</li>
<li>
<code>xs | ys</code>          The set union of xs and ys</li>
<li>
<code>xs union ys</code>      Same as <code>xs | ys</code>
</li>
<li>
<code>xs &amp;~ ys</code>         The set difference of xs and ys</li>
<li>
<code>xs diff ys</code>       Same as <code>xs &amp;~ ys</code>
</li>
</ul>
</blockquote>

<p><em>Operations in trait <code>mutable.Set</code>:</em>  </p>

<ul>
<li><strong>Additions</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs += x</code>          Adds x to xs as a side effect and returns xs</li>
<li>
<code>xs += (x, y, z)</code>  Adds x, y and z to set xs and returns xs</li>
<li>
<code>xs ++= ys</code>        Adds elements of ys to xs and returns xs</li>
<li>
<code>xs add x</code>         Adds x to xs and returns true if x was not previously contained in the set, false if it was already in the set</li>
</ul>
</blockquote>

<ul>
<li><strong>Removals</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs -= x</code>          Removes x from xs and returns xs</li>
<li>
<code>xs -= (x, y, z)</code>  Removes x, y and z from xs and returns xs</li>
<li>
<code>xs --= ys</code>        Removes all elements from xs that are in ys and returns xs</li>
<li>
<code>xs remove x</code>      Removes x from xs and returns true if x was previously contained in the set or false if it wasn't</li>
<li>
<code>xs retain p</code>      Keeps only those elements in xs that satisfy predicate p</li>
<li>
<code>xs.clear()</code>       Removes all elements from xs</li>
</ul>
</blockquote>

<ul>
<li><strong>Update</strong></li>
</ul><blockquote>
<ul>
<li>
<code>xs(x) = b</code>        (or <code>xs.update(x, b)</code>) If boolean argument b is true, adds x to xs, otherwise removes x from xs</li>
</ul>
</blockquote>

<ul>
<li><strong>Cloning</strong></li>
</ul><blockquote>
<ul>
<li><p><code>xs.clone</code>          A new mutable set with the same elements as xs</p></li>
<li><p>mutable set also has <code>+</code>, <code>++</code>, <code>-</code> and <code>--</code> methods, but they are rarely used because they involve copying the set</p></li>
<li><p>the current default implementation of a mutable set uses a hash table to store the set's elements</p></li>
<li>
<p>the default implementation of an immutable set uses a representation that adapts to the number of element of the set:</p>

<ul>
<li>empty set is represented as a singleton</li>
<li>sets of up to four elements are represented by a single object with elems as fields</li>
<li>beyond 4 elements, immutable sets are represented as <strong>hash tries</strong>
</li>
</ul>
</li>
<li><p>this decision results in more compact and efficient small (up to 4) immutable sets (compared to small mutable sets)</p></li>
</ul>
</blockquote>

<h3>
<a name="556---sorted-sets" class="anchor" href="#556---sorted-sets"><span class="octicon octicon-link"></span></a><strong>556 - Sorted sets</strong>
</h3>

<blockquote>
<ul>
<li>
<code>SortedSet</code> is a subtrait of <code>Set</code> in which elements are traversed in sorted order, regardless of the order in which elements were added to the set </li>
<li>the default representation of a <code>SortedSet</code> is an ordered binary tree, maintaining the invariant that all elements in the left subtree of any node are smaller than all elements in the right subtree (thus, simple, in-order traversal yields elements in the ascending order)</li>
<li>
<code>immutable.TreeSet</code> uses a red-black tree implementation to maintain that order and at the same time keep the tree balanced</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// to create an empty tree set, we may want to first specify the desired ordering:</span>
<span class="k">val</span> <span class="n">myOrdering</span> <span class="k">=</span> <span class="nc">Ordering</span><span class="o">.</span><span class="n">fromLessThan</span><span class="o">[</span><span class="kt">String</span><span class="o">](</span><span class="k">_</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">)</span>  <span class="c1">// scala.math.Ordering[String]</span>

<span class="c1">// then, to create an empty tree set with that ordering:</span>
<span class="k">import</span> <span class="nn">scala.collection.immutable.TreeSet</span>
<span class="nc">TreeSet</span><span class="o">.</span><span class="n">empty</span><span class="o">(</span><span class="n">myOrdering</span><span class="o">)</span>  <span class="c1">// TreeSet()</span>

<span class="c1">// or we can leave out the ordering, but give an element type of the empty set</span>
<span class="c1">// in which case the default ordering will be used (ascending - (_ &lt; _)):</span>
<span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="nc">TreeSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>

<span class="c1">// if you make new sets from a tree set (e.g. by concatenation or filtering)</span>
<span class="c1">// in the new set, the elements will stay in the same order:</span>
<span class="k">val</span> <span class="n">numbers</span> <span class="k">=</span> <span class="n">set</span> <span class="o">+</span> <span class="o">(</span><span class="s">"one"</span><span class="o">,</span> <span class="s">"four"</span><span class="o">,</span> <span class="s">"eight"</span><span class="o">)</span>  <span class="c1">// TreeSet(eight, four, one)</span>

<span class="c1">// sorted sets also support ranges of elements (including start and up to end, excluded):</span>
<span class="n">numbers</span> <span class="n">range</span> <span class="o">(</span><span class="s">"eight"</span><span class="o">,</span> <span class="s">"one"</span><span class="o">)</span>  <span class="c1">// TreeSet(eight, four)</span>

<span class="c1">// they also support 'from' method, which returns elements &gt;= to argument received:</span>
<span class="n">numbers</span> <span class="n">from</span> <span class="s">"four"</span>  <span class="c1">// TreeSet(four, one)</span>
</pre></div>

<h3>
<a name="557---bit-sets" class="anchor" href="#557---bit-sets"><span class="octicon octicon-link"></span></a><strong>557 - Bit sets</strong>
</h3>

<blockquote>
<ul>
<li>sets of non-negative integer elements, that are implemented as one or more words of packed bits</li>
<li>internal representation uses an array of <code>Longs</code>, where the first long covers elements from 0 to 63, the second from 64 to 127, and so on</li>
<li>for every long, each of its 64 bits is set to 1 if the corresponding element is contained in the set and otherwise it contains zero (the size of a bit set depends on the largest integer that's stored in it)</li>
<li>if N is the largest integer, then the size of the set is N/64 Long words, or N/8 bytes, plus a small number of extra bytes that carry status information</li>
<li>hence, bit sets are convenient for storing many small elements</li>
<li>another advantage of bit sets is that operations <code>contains</code>, <code>+=</code> and <code>-=</code> are extremely efficient</li>
</ul>
</blockquote>

<h3>
<a name="557---maps" class="anchor" href="#557---maps"><span class="octicon octicon-link"></span></a><strong>557 - Maps</strong>
</h3>

<blockquote>
<ul>
<li>
<code>Iterables</code> of pairs of keys and values (mappings, associations)</li>
</ul>
</blockquote>

<p><em>Operations in trait <code>Map</code>:</em>  </p>

<ul>
<li><strong>Lookups</strong></li>
</ul><blockquote>
<ul>
<li>
<code>ms get k</code>             The value associated with key 'k' as an 'option', or 'None' if 'k' is not found</li>
<li>
<code>ms(k)</code>                (or <code>ms apply k</code>) The value associated with key 'k', or a thrown exception if not found</li>
<li>
<code>ms getOrElse (k, d)</code>  The value associated with key 'k', or the default value 'd' if not found</li>
<li>
<code>ms contains k</code>        Tests whether 'ms' contains a mapping for key 'k'</li>
<li>
<code>ms isDefinedAt k</code>     Same as <code>contains</code>
</li>
</ul>
</blockquote>

<ul>
<li><strong>Additions and updates</strong></li>
</ul><blockquote>
<ul>
<li>
<code>ms + (k -&gt; v)</code>          The map containing 'ms' and the mapping 'k -&gt; v'</li>
<li>
<code>ms + (k -&gt; v, l -&gt; w)</code>  The map containing 'ms' and given key value pairs</li>
<li>
<code>ms ++ kvs</code>              The map containing 'ms' and all key value pairs of 'kvs'</li>
<li>
<code>ms updated (k, v)</code>      Same as <code>ms + (k -&gt; v)</code>
</li>
</ul>
</blockquote>

<ul>
<li><strong>Removals</strong></li>
</ul><blockquote>
<ul>
<li>
<code>ms - k</code>          The map containing 'ms' except for any mapping of key 'k'</li>
<li>
<code>ms - (k, l, m)</code>  The map containing 'ms' except for any mappings with the given keys</li>
<li>
<code>ms -- ks</code>        The map containing 'ms' except for any mapping with a key in 'ks'</li>
</ul>
</blockquote>

<ul>
<li><strong>Subcollections</strong></li>
</ul><blockquote>
<ul>
<li>
<code>ms.keys</code>            An iterable containing each key of 'ms'</li>
<li>
<code>ms.keySet</code>          A set containing each key in 'ms'</li>
<li>
<code>ms.keysIterator</code>    An iterator yielding each key in ms</li>
<li>
<code>ms.values</code>          An iterable containing each value associated with a key in 'ms'</li>
<li>
<code>ms.valuesIterator</code>  An iterator yielding each value associated with a key in 'ms'</li>
</ul>
</blockquote>

<ul>
<li><strong>Transformation</strong></li>
</ul><blockquote>
<ul>
<li>
<code>ms filterKeys p</code>  A map view containing only those mappings in 'ms' where the key satisfies predicate 'p'</li>
<li>
<code>ms mapValues f</code>   A map view resulting from applying function 'f' to each value associated with a key in 'ms'</li>
</ul>
</blockquote>

<p><em>Operations in trait <code>mutable.Map</code>:</em>  </p>

<ul>
<li><strong>Additions and updates</strong></li>
</ul><blockquote>
<ul>
<li>
<code>ms(k) = v</code>                  (or <code>ms.update(k, v)</code>) Adds 'k -&gt; v' as a side effect, overwriting any previous mapping of 'k'</li>
<li>
<code>ms += (k -&gt; v)</code>             Adds mapping 'k -&gt; v' and returns the altered 'ms'</li>
<li>
<code>ms += (k -&gt; v, l -&gt; w)</code>     Adds the given mappings to 'ms' and returns 'ms'</li>
<li>
<code>ms ++= kvs</code>                 Adds all mappings in 'kvs' to 'ms' and returns 'ms'</li>
<li>
<code>ms put (k, v)</code>              Adds mapping 'k -&gt; v' and returns any value previously associated with 'k' as an 'option'</li>
<li>
<code>ms getOrElseUpdate (k, d)</code>  If key 'k' is defined, returns its value. Otherwise updates 'ms' with the mapping 'k -&gt; d' and returns 'd'</li>
</ul>
</blockquote>

<ul>
<li><strong>Removals</strong></li>
</ul><blockquote>
<ul>
<li>
<code>ms -= k</code>          Removes mapping with key 'k' and returns 'ms'</li>
<li>
<code>ms -= (k, l, m)</code>  Removes mappings with the given keys and returns 'ms'</li>
<li>
<code>ms --= ks</code>        Removes all keys contained in 'ks' and returns 'ms'</li>
<li>
<code>ms remove k</code>      Removes any mapping with key 'k' and returns any value previously associated with 'k' as an 'option'</li>
<li>
<code>ms retain p</code>      Keeps only those mappings that have a key in satisfying predicate 'p'</li>
<li>
<code>ms clear()</code>       Removes all mappings from 'ms'</li>
</ul>
</blockquote>

<ul>
<li><strong>Transformation and cloning</strong></li>
</ul><blockquote>
<ul>
<li>
<code>ms transform f</code>  Transforms all associated values in 'ms' with function 'f'</li>
<li><p><code>ms.clone</code>        Returns a new mutable map with the same mappings as 'ms'</p></li>
<li><p>same as with sets, mutable maps also support <code>+</code>, <code>-</code> and <code>updated</code>, but they are also rarely used since they involve copying of the mutable map</p></li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// getOrElseUpdate is useful for accessing maps that act as caches:</span>
<span class="c1">// if you were to have an expensive operation triggered by invoking a function 'f':</span>
<span class="k">def</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"taking my time slow."</span><span class="o">);</span> <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>
  <span class="n">x</span><span class="o">.</span><span class="n">reverse</span>
<span class="o">}</span>

<span class="c1">// assume further that 'f' has no side-effects, so invoking it again with the same</span>
<span class="c1">// argument will always yield the same result</span>
<span class="c1">// in that case, you could save time by storing previously computed bindings of</span>
<span class="c1">// arguments and results of 'f' in a map, and only computing the result of 'f' if</span>
<span class="c1">// a result of an argument was not found there:</span>
<span class="k">val</span> <span class="n">cache</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]()</span>  <span class="c1">// Map()</span>

<span class="c1">// the more efficient version of function 'f':</span>
<span class="k">def</span> <span class="n">cachedF</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">getOrElseUpdate</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">f</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>

<span class="n">cachedF</span><span class="o">(</span><span class="s">"ijk"</span><span class="o">)</span>
<span class="c1">// taking my time</span>
<span class="c1">// String = kji</span>

<span class="n">cachedF</span><span class="o">(</span><span class="s">"ijk"</span><span class="o">)</span>
<span class="c1">// String = kji</span>

<span class="c1">// the second argument to 'getOrElseUpdate' is "by-name", so the computation of f("ijk")</span>
<span class="c1">// is only performed if 'getOrElseUpdate' requires the value of its second argument</span>
<span class="c1">// which happens only if its first argument is not found in the map</span>

<span class="c1">// the alternative is to implement 'cachedF' directly, using just basic map operations</span>
<span class="c1">// but that would've taken more code:</span>
<span class="k">def</span> <span class="n">cachedF</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">cache</span> <span class="n">get</span> <span class="n">arg</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">result</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">result</span>
  <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span>
    <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">f</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span>
    <span class="n">cache</span><span class="o">(</span><span class="n">arg</span><span class="o">)</span> <span class="k">=</span> <span class="n">result</span>
    <span class="n">result</span>
<span class="o">}</span>
</pre></div>

<h3>
<a name="562---synchronized-sets-and-maps" class="anchor" href="#562---synchronized-sets-and-maps"><span class="octicon octicon-link"></span></a><strong>562 - Synchronized sets and maps</strong>
</h3>

<blockquote>
<ul>
<li>if you need a thread-safe map, you could mix the <code>SynchronizedMap</code> trait into a map implementation, e.g. <code>HashMap</code>
</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">import</span> <span class="nn">scala.collection.mutable.</span><span class="o">{</span><span class="nc">Map</span><span class="o">,</span> <span class="nc">SynchronizedMap</span><span class="o">,</span> <span class="nc">HashMap</span><span class="o">}</span>

<span class="k">object</span> <span class="nc">MapMaker</span> <span class="o">{</span>

  <span class="k">def</span> <span class="n">makeMap</span><span class="o">()</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>

    <span class="c1">// a synthetic subclass of HashMap that mixes in SynchronizedMap trait</span>
    <span class="c1">// is generated, an instance of it is created and then returned</span>
    <span class="k">new</span> <span class="nc">HashMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">with</span> <span class="nc">SynchronizedMap</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">]</span> <span class="o">{</span>

      <span class="c1">// if you ask a map to give you a key that doesn't exist you'll get</span>
      <span class="c1">// NoSuchElementException, but if you override 'default', you'll get </span>
      <span class="c1">// a value returned by 'default' method</span>
      <span class="k">override</span> <span class="k">def</span> <span class="n">default</span><span class="o">(</span><span class="n">key</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="s">"Why?"</span>
    <span class="o">}</span>    
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// because our map mixes in SynchronizedMap it may be used</span>
    <span class="c1">// by multiple threads at the same time</span>
    <span class="k">val</span> <span class="n">capital</span> <span class="k">=</span> <span class="n">makeMap</span>
    <span class="n">capital</span> <span class="o">++=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"US"</span> <span class="o">-&gt;</span> <span class="s">"Washington"</span><span class="o">,</span> <span class="s">"Croatia"</span> <span class="o">-&gt;</span> <span class="s">"Zagreb"</span><span class="o">)</span>

    <span class="n">println</span><span class="o">(</span><span class="n">capital</span><span class="o">(</span><span class="s">"Croatia"</span><span class="o">))</span>      <span class="c1">// Zagreb</span>
    <span class="n">println</span><span class="o">(</span><span class="n">capital</span><span class="o">(</span><span class="s">"New Zealand"</span><span class="o">))</span>  <span class="c1">// Why?</span>

    <span class="n">capital</span> <span class="o">+=</span> <span class="o">(</span><span class="s">"New Zealand"</span> <span class="o">-&gt;</span> <span class="s">"Wellington"</span><span class="o">)</span>

    <span class="n">println</span><span class="o">(</span><span class="n">capital</span><span class="o">(</span><span class="s">"New Zealand"</span><span class="o">))</span>  <span class="c1">// Wellington</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>regardless of <code>Synchronized</code> collections, you're encouraged to use immutable collections with Scala actors instead</li>
</ul>
</blockquote>

<h3>
<a name="564---concrete-immutable-collection-classes" class="anchor" href="#564---concrete-immutable-collection-classes"><span class="octicon octicon-link"></span></a>564 - Concrete immutable collection classes</h3>

<ul>
<li><strong>Lists</strong></li>
</ul><blockquote>
<ul>
<li>finite immutable sequences that provide constant time access to their first element and they have a constant time <em>cons</em> operation for adding a new element to the front</li>
<li>most other operations take linear time (e.g. accessing "non-head" elements)</li>
</ul>
</blockquote>

<ul>
<li><strong>Streams</strong></li>
</ul><blockquote>
<ul>
<li>like a list, except that its elements are computed lazily</li>
<li>because of it laziness, a stream can be infinitely long (only requested elements are computed)</li>
<li>they have the same performance characteristics as lists</li>
<li>whereas lists are constructed with the <code>::</code> operator, streams are constructed with <code>#::</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">str</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">#::</span> <span class="mi">2</span> <span class="o">#::</span> <span class="mi">3</span> <span class="o">#::</span> <span class="nc">Stream</span><span class="o">.</span><span class="n">empty</span>  <span class="c1">// Stream[Int] = Stream(1, ?)</span>

<span class="c1">// the head of the stream is '1', and the tail has '2' and '3'</span>
<span class="c1">// the tail is not printed because it hasn't been computed yet</span>
<span class="c1">// 'toString' method of a stream is careful not to force any extra evaluation</span>

<span class="c1">// computing a Fibonacci sequence starting with the given two numbers</span>
<span class="k">def</span> <span class="n">fibFrom</span><span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">b</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
  <span class="n">a</span> <span class="o">#::</span> <span class="n">fibFrom</span><span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="o">)</span>

<span class="c1">// if the function used '::' instead of '#::', it would cause an infinite recursion</span>
<span class="c1">// since it uses a stream, the right hand side is not evaluated until it is requested</span>
<span class="k">val</span> <span class="n">fibs</span> <span class="k">=</span> <span class="n">fibFrom</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">).</span><span class="n">take</span><span class="o">(</span><span class="mi">7</span><span class="o">)</span>  <span class="c1">// Stream[Int] = Stream(1, ?)</span>
<span class="n">fibs</span><span class="o">.</span><span class="n">toList</span>                       <span class="c1">// List(1, 1, 2, 3, 5, 8, 13)</span>
</pre></div>

<ul>
<li><strong>Vectors</strong></li>
</ul><blockquote>
<ul>
<li>introduced in Scala 2.8</li>
<li>provide efficient access to elements beyond the head</li>
<li>access to any element take "effectively constant time" (larger constant than list's head or array's element, but constant nonetheless)</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// used as any other sequence:</span>
<span class="k">val</span> <span class="n">vec1</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Vector</span><span class="o">.</span><span class="n">empty</span>  <span class="c1">// Vector[Nothing] = Vector()</span>
<span class="k">val</span> <span class="n">vec2</span> <span class="k">=</span> <span class="n">vec1</span> <span class="o">:+</span> <span class="mi">1</span> <span class="o">:+</span> <span class="mi">2</span>  <span class="c1">// Vector[Int] = Vector(1, 2)</span>
<span class="k">val</span> <span class="n">vec3</span> <span class="k">=</span> <span class="mi">100</span> <span class="o">+:</span> <span class="n">vec2</span>     <span class="c1">// Vector[Int] = Vector(100, 1, 2)</span>
<span class="k">val</span> <span class="n">third</span> <span class="k">=</span> <span class="n">vec3</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>        <span class="c1">// Int = 100</span>
</pre></div>

<blockquote>
<ul>
<li>vectors are represented as broad, shallow trees, where every tree node contains up to 32 elements of the vector or up to 32 other tree nodes</li>
<li>so vectors with up to 32 elements can be represented in a single tree node</li>
<li>vectors with up to 32 * 32 (1024) elements can be represented with a single indirection</li>
<li>2^15 (approx 32.77k) elements can be stored within two hops from the root</li>
<li>2^20 (approx 1M) - 3 hops,  2^25 (approx 33.5M) - 4 hops,  2^30 (approx 1B) - 5 hops</li>
<li>so for all vectors of up to 1.074B elements, an element selection involves up to five primitive array selections (thus constant time)</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// we cannot change an element of a vector in place</span>
<span class="c1">// but we can use 'updated' method which returns a new vector that differs from</span>
<span class="c1">// the original vector only in a single element:</span>
<span class="k">val</span> <span class="n">vec</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">vec</span> <span class="n">updated</span> <span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>  <span class="c1">// Vector[Int] = Vector(1, 2, 4)</span>
<span class="n">println</span><span class="o">(</span><span class="n">vec</span><span class="o">)</span>        <span class="c1">// Vector[Int] = Vector(1, 2, 3)</span>
</pre></div>

<blockquote>
<ul>
<li>like selection, functional vector updates also take "effectively constant time"</li>
<li>implementation, to update an element in the middle of a vector, copies the node that contains the element and all nodes that point to it, starting from the root (so it creates between 1 and 5 nodes that each contain up to 32 elements or subtrees)</li>
<li>that is certainly more expensive than in-place update of a mutable array, but it's still a lot cheaper than copying the whole vector</li>
<li>because of this characteristics, vectors strike a good balance between fast random selections and fast random functional updates and are, thus, the current default implementation of immutable indexed sequences:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">IndexedSeq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// IndexedSeq[Int] = Vector(1, 2, 3)</span>
</pre></div>

<ul>
<li><strong>Immutable stacks</strong></li>
</ul><blockquote>
<ul>
<li>
<code>push</code>, <code>pop</code> and <code>top</code> all take constant time</li>
<li>rarely used because their functionality is subsumed by lists</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">stack</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Stack</span><span class="o">.</span><span class="n">empty</span>  <span class="c1">// Stack[Nothing] = Stack()</span>
<span class="k">val</span> <span class="n">hasOne</span> <span class="k">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>  <span class="c1">// Stack[Int] = Stack(1)</span>
<span class="n">stack</span>       <span class="c1">// Stack()</span>
<span class="n">hasOne</span><span class="o">.</span><span class="n">top</span>  <span class="c1">// Int = 1</span>
<span class="n">hasOne</span><span class="o">.</span><span class="n">pop</span>  <span class="c1">// Stack()  - returns the stack, not the popped element (like list's tail)</span>
</pre></div>

<ul>
<li><strong>Immutable queues</strong></li>
</ul><div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">empty</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">Queue</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span>  <span class="c1">// Queue[Int] = Queue()</span>
<span class="k">val</span> <span class="n">hasOne</span> <span class="k">=</span> <span class="n">empty</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>                        <span class="c1">// Queue[Int] = Queue(1)</span>
<span class="k">val</span> <span class="n">has123</span> <span class="k">=</span> <span class="n">hasOne</span><span class="o">.</span><span class="n">enqueue</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">))</span>              <span class="c1">// Queue[Int] = Queue(1, 2, 3)</span>
<span class="k">val</span> <span class="o">(</span><span class="n">element</span><span class="o">,</span> <span class="n">has23</span><span class="o">)</span> <span class="k">=</span> <span class="n">has123</span><span class="o">.</span><span class="n">dequeue</span>  <span class="c1">// element: Int = 1; has23: Queue(2, 3)</span>
<span class="c1">// dequeue returns a pair consisting of the element removed and the rest of the queue</span>
</pre></div>

<ul>
<li><strong>Ranges</strong></li>
</ul><blockquote>
<ul>
<li>ordered sequence of integers that are equally spaced apart</li>
<li>represented in constant space, since they can be defined by just 3 numbers: start, end and step, thus making most operations on ranges extremely fast</li>
<li>to create a range, use predefined methods <code>to</code> and <code>by</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span>  <span class="c1">// immutable.Range.Inclusive with immutable.Range.ByOne = Range(1, 2, 3)</span>
<span class="mi">5</span> <span class="n">to</span> <span class="mi">14</span> <span class="n">by</span> <span class="mi">3</span>  <span class="c1">// immutable.Range = Range(5, 8, 11, 14)</span>
<span class="mi">1</span> <span class="n">until</span> <span class="mi">3</span>  <span class="c1">// immutable.Range = Range(1, 2)</span>
</pre></div>

<ul>
<li><strong>Hash tries</strong></li>
</ul><blockquote>
<ul>
<li>a standard way to implement immutable sets and maps efficiently</li>
<li>represented similar to vectors, in that they are also trees where every node has 32 elements or subtrees, but selection is done based on a hash code</li>
<li>e.g. to find a given key in a map, we use the lowest five bits of the hash code of the key to select the first subtree, the next five bits for the next subtree, and so on</li>
<li>selection stops once all elements stored in a node have hash codes that differ from each other in the bits that are selected so far, thus not all the bits of the hash code are always used</li>
<li>strike a nice balance between reasonably fast lookups and reasonably efficient functional insertions (<code>+</code>) and deletions (<code>-</code>)</li>
<li>sets and maps that contain less than five elements are stored as single objects that just contain the elements as fields</li>
</ul>
</blockquote>

<ul>
<li><strong>Red-black trees</strong></li>
</ul><blockquote>
<ul>
<li>a form of balanced binary trees where some nodes are designated "red" and others "black"</li>
<li>like any other balanced binary tree, operations on them take <em>log(n)</em>
</li>
<li>
<code>TreeSet</code> and <code>TreeMap</code> use a red-black tree internally</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">TreeSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>  <span class="c1">// TreeSet[Int] = TreeSet()</span>
<span class="n">set</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span>  <span class="c1">// TreeSet[Int] = TreeSet(1, 3)</span>
</pre></div>

<blockquote>
<ul>
<li>they are also the standard implementation of <code>SortedSet</code>, because they provide efficient iterator that returns all elements of the set in sorted order</li>
</ul>
</blockquote>

<ul>
<li><strong>Immutable bit sets</strong></li>
</ul><blockquote>
<ul>
<li>represent collections of small integers as the bits of a larger integer, e.g. the bit set containing <code>3, 2 and 0</code> would be represented as integer <code>1101</code> in binary, which is <code>13</code> in decimal</li>
<li>internally, they use an array of 64-bit Longs, where the first Long in the array is for integers 0 through 63, second for 64 to 127, and so on, thus they are very compact as long as the largest integer in the set is less than a few hundred or so</li>
<li>testing for inclusion takes constant time</li>
<li>adding an item to a set takes time proportional to the number of Longs in the array</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">bits</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">BitSet</span><span class="o">.</span><span class="n">empty</span>  <span class="c1">// BitSet = BitSet()</span>
<span class="k">val</span> <span class="n">moreBits</span> <span class="k">=</span> <span class="n">bits</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span>  <span class="c1">// BitSet = BitSet(3, 4)</span>
<span class="n">moreBits</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>  <span class="c1">// true</span>
<span class="n">moreBits</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>  <span class="c1">// false</span>
</pre></div>

<ul>
<li><strong>List maps</strong></li>
</ul><blockquote>
<ul>
<li>represents a map as a linked list of key-value pairs</li>
<li>in general, operations might have to iterate through the entire list, thus taking time linear in the size of the map</li>
<li>rarely used, since regular immutable maps are almost always faster</li>
<li>the one exception is a case when a map is constructed in such a way that the first elements in the list are selected much more often than the other elements</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.</span><span class="nc">ListMap</span><span class="o">(</span><span class="mi">1</span> <span class="o">-&gt;</span> <span class="s">"one"</span><span class="o">,</span> <span class="mi">2</span> <span class="o">-&gt;</span> <span class="s">"two"</span><span class="o">)</span>
<span class="c1">// immutable.ListMap[Int, java.lang.String] = Map((1, one), (2, two))</span>
<span class="n">map</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>  <span class="c1">// java.lang.String = two</span>
</pre></div>

<h3>
<a name="571---concrete-mutable-collection-classes" class="anchor" href="#571---concrete-mutable-collection-classes"><span class="octicon octicon-link"></span></a><strong>571 - Concrete mutable collection classes</strong>
</h3>

<ul>
<li><strong>Array buffers</strong></li>
</ul><blockquote>
<ul>
<li>holds an array and a size</li>
<li>most operations have the same speed as arrays' counterparts, because the operations simply access and modify the underlying array</li>
<li>additionally, they support efficient addition of elements to the end, which take "amortized constant time", thus making them useful for building a large collections, as long as new items are always added to the end:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">ArrayBuffer</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="c1">// ArrayBuffer[Int] = ArrayBuffer()</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="mi">1</span>     <span class="c1">// buf.type = ArrayBuffer(1)</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="mi">10</span>    <span class="c1">// buf.type = ArrayBuffer(1, 10)</span>
<span class="n">buf</span><span class="o">.</span><span class="n">toArray</span>  <span class="c1">// Array[Int] = Array(1, 10)</span>

<span class="c1">// buf.type - a singleton type</span>
<span class="c1">// means that the variable holds exactly the object referred to by buf</span>
</pre></div>

<ul>
<li><strong>List buffers</strong></li>
</ul><blockquote>
<ul>
<li>like an array buffer, except that it uses a linked list internally instead of array</li>
<li>if you plan to convert the buffer to a list once it's built up, use a list buffer instead of an array buffer</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">ListBuffer</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>  <span class="c1">// ListBuffer[Int] = ListBuffer()</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="mi">1</span>    <span class="c1">// buf.type = ListBuffer(1)</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="mi">10</span>   <span class="c1">// buf.type = ListBuffer(1, 10)</span>
<span class="n">buf</span><span class="o">.</span><span class="n">toList</span>  <span class="c1">// List[Int] = List(1, 10)</span>
</pre></div>

<ul>
<li><strong>String builders</strong></li>
</ul><blockquote>
<ul>
<li>imported in the default namespace, so they may be created: <code>new StringBuilder</code>
</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StringBuilder</span>  <span class="c1">// StringBuilder = StringBuilder()</span>
<span class="n">buf</span> <span class="o">+=</span> <span class="-Symbol">'a</span><span class="err">'</span>       <span class="c1">// StringBuilder(a)</span>
<span class="n">buf</span> <span class="o">++=</span> <span class="s">"bcdef"</span>  <span class="c1">// StringBuilder(a, b, c, d, e, f)</span>
<span class="n">buf</span><span class="o">.</span><span class="n">toString</span>     <span class="c1">// String = abcdef</span>
</pre></div>

<ul>
<li><strong>Linked lists</strong></li>
</ul><blockquote>
<ul>
<li>mutable sequences that consist of nodes that are linked with <code>next</code> pointers</li>
<li>in most languages empty linked list would be represented with <code>null</code>, but in Scala, which makes even empty sequences support all sequence methods, empty linked list is encoded in a special way. Their <code>next</code> pointer points back to the node itself</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// otherwise this would happen:</span>
<span class="nc">LinkedList</span><span class="o">.</span><span class="n">empty</span><span class="o">.</span><span class="n">isEmpty</span> <span class="c1">// in Java something like this would throw NullPointerException</span>
</pre></div>

<ul>
<li><strong>Double linked lists</strong></li>
</ul><blockquote>
<ul>
<li>the same as single linked lists, except that besides <code>next</code>, they have another mutable field, <code>prev</code>, which points to the element preceding the current node</li>
<li>the main benefit of that additional link is that it makes element removal very fast</li>
</ul>
</blockquote>

<ul>
<li><strong>Mutable lists</strong></li>
</ul><blockquote>
<ul>
<li>a <code>MutableList</code> consists of a single linked list together with a pointer that refers to the terminal empty node of that list, which makes list append operation take constant time, because it avoids having to traverse the list in search for its terminal node</li>
<li>it is the standard implementation of <code>mutable.LinearSeq</code>
</li>
</ul>
</blockquote>

<ul>
<li><strong>Queues</strong></li>
</ul><blockquote>
<ul>
<li>instead of immutable queue's <code>enqueue</code> method, we use <code>+=</code> and <code>++=</code> to append</li>
<li>also, on mutable queue, <code>dequeue</code> method just removes the head element from the queue and returns it</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Queue</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>  <span class="c1">// Queue[String] = Queue()</span>
<span class="n">q</span> <span class="o">+=</span> <span class="s">"a"</span>              <span class="c1">// q.type = Queue(a)</span>
<span class="n">q</span> <span class="o">++=</span> <span class="nc">List</span><span class="o">(</span><span class="s">"b"</span><span class="o">,</span> <span class="s">"c"</span><span class="o">)</span>  <span class="c1">// q.type = Queue(a, b, c)</span>
<span class="n">q</span>                     <span class="c1">// mutable.Queue[String] = Queue(a, b, c)</span>
<span class="n">q</span><span class="o">.</span><span class="n">dequeue</span>             <span class="c1">// String = a</span>
<span class="n">q</span>                     <span class="c1">// mutable.Queue[String] = Queue(b, c)</span>
</pre></div>

<ul>
<li><strong>Array sequences</strong></li>
</ul><blockquote>
<ul>
<li>
<code>ArraySeq</code> is a mutable sequence of fixed size, implemented as <code>Array[AnyRef]</code>
</li>
<li>used for its performance characteristics (array), when you want to create generic instances of a sequence, but do not know the type of elements and do not have a <code>ClassManifest</code> to provide at runtime</li>
</ul>
</blockquote>

<ul>
<li><strong>Stacks</strong></li>
</ul><blockquote>
<ul>
<li>works exactly the same as the immutable version, except that modifications happen in place</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">stack</span> <span class="k">=</span> <span class="k">new</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">Stack</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>  <span class="c1">// mutable.Stack[Int] = Stack()</span>
<span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>  <span class="c1">// stack.type = Stack(1)</span>
<span class="n">stack</span>          <span class="c1">// mutable.Stack[Int] = Stack(1)</span>
<span class="n">stack</span><span class="o">.</span><span class="n">push</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>  <span class="c1">// stack.type = Stack(2, 1)</span>
<span class="n">stack</span>          <span class="c1">// mutable.Stack[Int] = Stack(2, 1)</span>
<span class="n">stack</span><span class="o">.</span><span class="n">top</span>      <span class="c1">// Int = 2</span>
<span class="n">stack</span>          <span class="c1">// mutable.Stack[Int] = Stack(2, 1)</span>
<span class="n">stack</span><span class="o">.</span><span class="n">pop</span>      <span class="c1">// Int = 2</span>
<span class="n">stack</span>          <span class="c1">// mutable.Stack[Int] = Stack(1)</span>
</pre></div>

<ul>
<li><strong>Array stacks</strong></li>
</ul><blockquote>
<ul>
<li>an alternative implementation of a mutable stack, which is backed by an <code>Array</code> that gets resized as needed</li>
<li>provides fast indexing and is slightly more efficient than a normal mutable stack</li>
</ul>
</blockquote>

<ul>
<li><strong>Hash tables</strong></li>
</ul><blockquote>
<ul>
<li>stores its elements in an underlying array, placing each item at a position in the array determined by the hash code of that item</li>
<li>element addition takes constant time, so long as there isn't already another element in the array that has the same hash code</li>
<li>since it's very fast (as long as the objects placed in them have a good distribution of hash codes), the default mutable map and set types are based on hash tables</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">HashMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span> <span class="c1">// HashMap[Int, String] = Map()</span>
<span class="n">map</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">5</span> <span class="o">-&gt;</span> <span class="s">"html5"</span><span class="o">)</span>  <span class="c1">// map.type = Map((5, html5))</span>
<span class="n">map</span> <span class="o">+=</span> <span class="o">(</span><span class="mi">3</span> <span class="o">-&gt;</span> <span class="s">"css3"</span><span class="o">)</span>   <span class="c1">// map.type = Map((5, html5), (3, css3))</span>
<span class="n">map</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>                 <span class="c1">// html5</span>
<span class="n">map</span> <span class="n">contains</span> <span class="mi">2</span>         <span class="c1">// false</span>
</pre></div>

<blockquote>
<ul>
<li>iteration over a hash table is not guaranteed to occur in any particular order, it simply iterates through the underlying array in whichever order it happens to be</li>
<li>to get a guaranteed iteration order, use a linked hash map or set instead, which is just like a regular hash map or set, except that it also includes a linked list of the elements in the order in which they were added</li>
</ul>
</blockquote>

<ul>
<li><strong>Weak hash maps</strong></li>
</ul><blockquote>
<ul>
<li>a special kind of hash map in which the garbage collector does not follow links from the map to the keys stored in it, which means that a key and its associated value will disappear from the map if there is no other reference to that key</li>
<li>useful for tasks such as caching, where you want to reuse an expensive function's result if the function is called again on the same key</li>
<li>if keys and function results were stored in a regular hash map, the map could grow without bounds, since no key would ever become eligible for garbage collection</li>
<li>in <code>WeakHashMap</code>, as soon as a key object becomes unreachable, its entry is removed from the weak hash map</li>
<li>implemented as a wrapper of <code>java.util.WeakHashMap</code>
</li>
</ul>
</blockquote>

<ul>
<li><strong>Concurrent maps</strong></li>
</ul><blockquote>
<ul>
<li>can be safely accessed by several threads at once</li>
<li>
<code>ConcurrentMap</code> is a trait in collections library, whose current implementation is Java's <code>java.util.concurrent.ConcurrentMap</code>, which can be automatically converted to Scala map using the standard Java/Scala collection conversion</li>
</ul>
</blockquote>

<p><em>Operations in trait <code>ConcurrentMap</code>:</em>  </p>

<blockquote>
<ul>
<li>
<code>m putIfAbsent (k, v)</code>     Adds key/value binding 'k -&gt; v' unless 'k' exists in 'm'</li>
<li>
<code>m remove (k, v)</code>          Removes entry for 'k' if it is currently mapped to 'v'</li>
<li>
<code>m replace (k, old, new)</code>  Replaces value of key 'k' to 'new', if it is set to 'old'</li>
<li>
<code>m replace (k, v)</code>         Replaces value of 'k' with 'v' if it was previously bound to some value</li>
</ul>
</blockquote>

<ul>
<li><strong>Mutable bit sets</strong></li>
</ul><blockquote>
<ul>
<li>slightly more efficient at updating than immutable ones, because they don't have to copy around Longs that haven't changed</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">bits</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">mutable</span><span class="o">.</span><span class="nc">BitSet</span><span class="o">.</span><span class="n">empty</span>  <span class="c1">// mutable.BitSet = BitSet()</span>
<span class="n">bits</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1">// bits.type = BitSet(1)</span>
<span class="n">bits</span> <span class="o">+=</span> <span class="mi">3</span>  <span class="c1">// bits.type = BitSet(1, 3)</span>
<span class="n">bits</span>       <span class="c1">// mutable.BitSet = BitSet(1, 3)</span>
</pre></div>

<h3>
<a name="578---arrays" class="anchor" href="#578---arrays"><span class="octicon octicon-link"></span></a><strong>578 - Arrays</strong>
</h3>

<blockquote>
<ul>
<li>a special kind of collection</li>
<li>Scala arrays correspond one-to-one to Java arrays (e.g. <code>Array[Int]</code> is represented as <code>int[]</code>), but at the same time they offer much more, Scala arrays:

<ul>
<li>can be generic</li>
<li>are compatible with sequences (you can pass <code>Array[T]</code> where <code>Seq[T]</code> is required)</li>
<li>support all sequence operations:</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">a1</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>          <span class="c1">// Array[Int] = Array(1, 2, 3)</span>
<span class="k">val</span> <span class="n">a2</span> <span class="k">=</span> <span class="n">a1</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">3</span><span class="o">)</span>          <span class="c1">// Array[Int] = Array(3, 6, 9)</span>
<span class="k">val</span> <span class="n">a3</span> <span class="k">=</span> <span class="n">a2</span> <span class="n">filter</span> <span class="o">(</span><span class="k">_</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="o">)</span>  <span class="c1">// Array[Int] = Array(3, 9)</span>
<span class="k">val</span> <span class="n">a4</span> <span class="k">=</span> <span class="n">a3</span><span class="o">.</span><span class="n">reverse</span>              <span class="c1">// Array[Int] = Array(9, 3)</span>
</pre></div>

<blockquote>
<ul>
<li>all this is possible because of systematic use of implicit conversions in the implementation</li>
<li>representation of native array is not a subtype of <code>Seq</code>, instead there is implicit <em>wrapping</em> conversion between arrays and instances of <code>scala.collection.mutable.WrappedArray</code>, which is a subclass of <code>Seq</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>            <span class="c1">// Seq[Int] = WrappedArray(1, 2, 3)</span>
<span class="k">val</span> <span class="n">a4</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">toArray</span>  <span class="c1">// Array[Int] = Array(1, 2, 3)</span>
<span class="n">a1</span> <span class="n">eq</span> <span class="n">a4</span>                          <span class="c1">// true</span>
</pre></div>

<blockquote>
<ul>
<li>there is another implicit conversion that gets applied to arrays, but this one does not turn arrays into sequences, it simply <em>adds</em> all sequence methods to it</li>
<li>
<em>adding</em> means that the array is wrapped in another object, of type <code>ArrayOps</code>, which is typically short-lived (usually inaccessible after the call to the sequence method). Modern VMs often avoid creating this object entirely</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// the difference between two implicit conversions:</span>
<span class="k">val</span> <span class="n">seq</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>  <span class="c1">// Seq[Int] = WrappedArray(1, 2, 3)</span>
<span class="n">seq</span><span class="o">.</span><span class="n">reverse</span>             <span class="c1">// Seq[Int] = WrappedArray(3, 2, 1)</span>
<span class="k">val</span> <span class="n">ops</span><span class="k">:</span> <span class="kt">collection.mutable.ArrayOps</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">a1</span>  <span class="c1">// mutable.ArrayOps[Int] = [I(1, 2, 3)]</span>
<span class="n">ops</span><span class="o">.</span><span class="n">reverse</span>             <span class="c1">// Array[Int] = Array(3, 2, 1)</span>

<span class="c1">// calling reverse on 'seq', which is a 'WrappedArray', gives again a 'WrappedArray'</span>
<span class="c1">// that's logical because wrapped arrays are 'Seqs' and calling reverse on any 'Seq'</span>
<span class="c1">// will give again a 'Seq'</span>
<span class="c1">// calling 'reverse' on the 'ArrayOps' results in an 'Array', not a 'Seq'</span>
<span class="c1">// this was only demonstration, you'd never define a value of class 'ArrayOps'</span>
<span class="c1">// you'd simply call a 'seq' method on an array:</span>
<span class="n">a1</span><span class="o">.</span><span class="n">reverse</span>  <span class="c1">// Array[Int] = Array(3, 2, 1)</span>
</pre></div>

<blockquote>
<ul>
<li>this raises the one question, though, how the compiler picked <code>ArrayOps</code> (<code>intArrayOps</code>, to be more precise) over the other implicit conversion, to <code>WrappedArray</code>, since both conversions map an array to a type that supports a <code>reverse</code> method? </li>
<li>the two implicit conversions are prioritized, and the <code>ArrayOps</code> conversion has the higher priority, since it is defined in the <code>Predef</code> object, whereas the other is defined in a class <code>scala.LowPriorityImplicits</code>, which is a superclass of <code>Predef</code>
</li>
<li>implicits in subclasses and subobjects take precedence over implicits in base classes</li>
</ul>
</blockquote>

<p><strong>What's the story on generic arrays?</strong></p>

<blockquote>
<ul>
<li>in Java, you cannot write <code>T[]</code>, how then Scala's <code>Array[T]</code> is represented?</li>
<li>a generic array could be at runtime any of Java's primitive array types, or it could be an array of objects and the only common runtime type encompassing all that is <code>AnyRef</code>, so that's the type Scala compiler maps <code>Array[T]</code> to</li>
<li>at runtime, when an element of an array of type <code>Array[T]</code> is accessed or updated, there is a sequence of type tests that determine the actual array type, followed by the correct array operation on the Java array</li>
<li><p>since these tests slow down operations a bit, you can expect access to generic arrays to be 3 to 4 times slower than to primitive or object arrays</p></li>
<li><p>representing a generic array type is not enough, there must also be a way to <em>create</em> generic arrays, which is an even harder problem:</p></li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// This is not enough - doesn't compile!</span>
<span class="k">def</span> <span class="n">evenElems</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="c1">// this could be e.g. an Array[Int], or an Array[Boolean]</span>
  <span class="c1">// or an array of some of the Java primitive, or an array of some reference type</span>
  <span class="c1">// which all have different runtime representations </span>
  <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]((</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>  <span class="c1">// cannot find a class tag for type T</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="n">by</span> <span class="mi">2</span><span class="o">)</span>
    <span class="n">arr</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="n">arr</span>
<span class="o">}</span>

<span class="c1">// the reason why Scala runtime cannot pick the type is type erasure</span>
<span class="c1">// the actual type that corresponds to the type T is erased at runtime</span>

<span class="c1">// it is required that you provide a runtime type hint to the compiler</span>
<span class="c1">// this hint takes the form of a 'class manifest' of type 'scala.reflect.ClassManifest'</span>
<span class="c1">// a class manifest is a type descriptor object that describes what the top-level class</span>
<span class="c1">// of a type is</span>
<span class="c1">// there's also a full manifest (scala.reflect.Manifest), that describes all aspects</span>
<span class="c1">// of a type, but for array creation, only a class manifest is needed</span>

<span class="c1">// the compiler will generate code to construct and pass class manifests automatically</span>
<span class="c1">// if you demand a class manifest as an implicit parameter:</span>
<span class="k">def</span> <span class="n">evenElems</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">m</span><span class="k">:</span> <span class="kt">ClassManifest</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]((</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="n">by</span> <span class="mi">2</span><span class="o">)</span>
    <span class="n">arr</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="n">arr</span>
<span class="o">}</span>  <span class="c1">//&gt; evenElems: [T](xs: Vector[T])(implicit m: ClassManifest[T])Array[T]</span>

<span class="c1">// or written shorter, with type 'context bound':</span>
<span class="k">def</span> <span class="n">evenElems</span><span class="o">[</span><span class="kt">T:</span> <span class="kt">ClassManifest</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]((</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="n">by</span> <span class="mi">2</span><span class="o">)</span>
    <span class="n">arr</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>
  <span class="n">arr</span>
<span class="o">}</span>  <span class="c1">//&gt; evenElems: [T](xs: Vector[T])(implicit evidence$1: ClassManifest[T])Array[T]</span>

<span class="c1">// the two versions of 'evenElems' are exactly the same</span>
<span class="c1">// when the 'Array[T]' is constructed, the compiler looks for a class manifest for</span>
<span class="c1">// the type parameter 'T', that is, it looks for an implicit value of type</span>
<span class="c1">// 'ClassManifest[T]' and if such a value is found, the manifest is used to construct</span>
<span class="c1">// the right kind of array</span>
<span class="n">evenElems</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">))</span>  <span class="c1">//Array[Int] = Array(1, 3, 5)</span>
<span class="n">evenElems</span><span class="o">(</span><span class="nc">Vector</span><span class="o">(</span><span class="s">"compiler"</span><span class="o">,</span> <span class="s">"of Scala"</span><span class="o">,</span> <span class="s">"is"</span><span class="o">,</span> <span class="s">"not"</span><span class="o">,</span> <span class="s">"a bitch"</span><span class="o">))</span>

<span class="c1">// compiler automatically constructed a class manifest for the element type</span>
<span class="c1">// and passed it to the implicit parameter of 'evenElems'</span>

<span class="c1">// compiler can do that for all the concrete types, but not if the argument is itself</span>
<span class="c1">// another type parameter without its class manifest:</span>
<span class="k">def</span> <span class="n">wrap</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="n">evenElems</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>  <span class="c1">// No ClassManifest available for U</span>
<span class="c1">// not enough arguments for method evenElems</span>
<span class="c1">// unspecified value parameter evidence$1</span>

<span class="k">def</span> <span class="n">wrap</span><span class="o">[</span><span class="kt">U:</span> <span class="kt">ClassManifest</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Vector</span><span class="o">[</span><span class="kt">U</span><span class="o">])</span> <span class="k">=</span> <span class="n">evenElems</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>
<span class="c1">// wrap: [U](xs: Vector[U])(implicit evidence$1: ClassManifest[U])Array[U]</span>

<span class="c1">// the context bound in the definition of 'U' is just a shorthand for an implicit</span>
<span class="c1">// parameter named here 'evidence$1' of type 'ClassManifest[U]'</span>
</pre></div>

<blockquote>
<ul>
<li>so generic array creation demands class manifests</li>
<li>whenever you create an array of type parameter 'T', you also need to provide an implicit class manifest for 'T'</li>
<li>the easiest way to do that is to declare the type parameter with a 'ClassManifest' context bound</li>
</ul>
</blockquote>

<h3>
<a name="583---strings" class="anchor" href="#583---strings"><span class="octicon octicon-link"></span></a><strong>583 - Strings</strong>
</h3>

<blockquote>
<ul>
<li>like arrays, strings are not directly sequences, but they can be converted to them</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">str</span> <span class="k">=</span> <span class="s">"hell0"</span>       <span class="c1">// java.lang.String = hello</span>
<span class="n">str</span><span class="o">.</span><span class="n">reverse</span>             <span class="c1">// 0lleh</span>
<span class="n">str</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toUpper</span><span class="o">)</span>      <span class="c1">// HELL0</span>
<span class="n">str</span> <span class="n">drop</span> <span class="mi">3</span>              <span class="c1">// l0</span>
<span class="n">str</span> <span class="n">slice</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>        <span class="c1">// ell</span>
<span class="k">val</span> <span class="n">s</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=</span> <span class="n">str</span>  <span class="c1">// Seq[Char] = WrappedString(h, e, l, l, 0)</span>

<span class="c1">// these operations are supported by two implicit conversions:</span>
<span class="c1">// low-priority conversion to 'WrappedString', a subclass of 'immutable.IndexedSeq'</span>
<span class="c1">//   which was applied in the last line above</span>
<span class="c1">// high-priority conversion to 'StringOps' object, which adds all immutable seq methods</span>
<span class="c1">//   which was applied to support 'reverse', 'map', 'drop' and 'slice'</span>
</pre></div>

<h3>
<a name="548---performance-characteristics" class="anchor" href="#548---performance-characteristics"><span class="octicon octicon-link"></span></a><strong>548 - Performance characteristics</strong>
</h3>

<blockquote>
<ul>
<li>different collection types have different performance characteristics, which is often the primary reason for picking one over another</li>
</ul>
</blockquote>

<p><em>Performance characteristics of some common operations on collections:</em></p>

<div class="highlight highlight-scala"><pre><span class="cm">/*</span>
<span class="cm">The meaning of symbols:</span>
<span class="cm">   C      the operation takes (fast) constant time</span>
<span class="cm">   eC     effectively constant time (depends on assumptions, e.g. hash key distribution)</span>
<span class="cm">   aC     amortized constant time (in average, but some invocations might take longer)</span>
<span class="cm">   Log    time proportional to the logarithm of the collection size</span>
<span class="cm">   L      linear time (proportional to the collection size)</span>
<span class="cm">   -      the operation is not supported</span>
<span class="cm">*/</span>
</pre></div>

<p><em>Performance characteristics of sequence types:</em></p>

<div class="highlight highlight-scala"><pre><span class="cm">/*</span>
<span class="cm">                 head   tail   apply   update   prepend   append   insert</span>
<span class="cm"> immutable  </span>
<span class="cm">   List           C      C      L        L        C         L        -</span>
<span class="cm">   Stream         C      C      L        L        C         L        -</span>
<span class="cm">   Vector        eC     eC     eC       eC       eC        eC        -</span>
<span class="cm">   Stack          C      C      L        L        C         L        -</span>
<span class="cm">   Queue         aC     aC      L        L        L         C        -</span>
<span class="cm">   Range          C      C      C        -        -         -        -</span>
<span class="cm">   String         C      L      C        L        L         L        -</span>
<span class="cm"> mutable  </span>
<span class="cm">   ArrayBuffer    C      L      C        C        L        aC        L</span>
<span class="cm">   ListBuffer     C      L      L        L        C         C        L</span>
<span class="cm">   StringBuilder  C      L      C        C        L        aC        L</span>
<span class="cm">   MutableList    C      L      L        L        C         C        L</span>
<span class="cm">   Queue          C      L      L        L        C         C        L</span>
<span class="cm">   ArraySeq       C      L      C        C        -         -        -</span>
<span class="cm">   Stack          C      L      L        L        C         L        L</span>
<span class="cm">   ArrayStack     C      L      C        C       aC         L        L</span>
<span class="cm">   Array          C      L      C        C        -         -        -</span>
<span class="cm">*/</span>
</pre></div>

<p><em>Performance characteristics of sets and maps:</em></p>

<div class="highlight highlight-scala"><pre><span class="cm">/*</span>
<span class="cm">                     lookup   add   remove   min</span>
<span class="cm"> immutable  </span>
<span class="cm">   HashSet/HashMap    eC      eC     eC       L</span>
<span class="cm">   TreeSet/TreeMap    Log     Log    Log     Log</span>
<span class="cm">   BitSet              C       L      L      eCa</span>
<span class="cm">   ListMap             L       L      L       L</span>
<span class="cm"> mutable</span>
<span class="cm">   HashSet/HashMap    eC      eC     eC       L</span>
<span class="cm">   WeakHashMap        eC      eC     eC       L</span>
<span class="cm">   BitSet              C      aC      C      eCa</span>

<span class="cm"> eCa - assumption that bits are densely packed</span>
<span class="cm">*/</span>
</pre></div>

<h3>
<a name="585---equality" class="anchor" href="#585---equality"><span class="octicon octicon-link"></span></a><strong>585 - Equality</strong>
</h3>

<blockquote>
<ul>
<li>the collection libraries have a uniform approach to equality and hashing</li>
<li>when checking equality, Scala first divides collections into sets, maps and sequences (collections of different categories are always unequal, even if they contain the same elements)</li>
<li>withing a category, collections are equal only if they have the same elements (for sequences, elements must be in the same order), e.g. <code>List(1, 2, 3) == Vector(1, 2, 3)</code>
</li>
<li>for equality check, it's irrelevant whether a collection is mutable of immutable</li>
<li>you have to be careful not to use mutable collections as a key in a hash map:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">import</span> <span class="nn">collection.mutable.</span><span class="o">{</span><span class="nc">HashMap</span><span class="o">,</span> <span class="nc">ArrayBuffer</span><span class="o">}</span>
<span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// mutable.ArrayBuffer[Int] = ArrayBuffer(1, 2, 3)</span>
<span class="k">val</span> <span class="n">map</span> <span class="k">=</span> <span class="nc">HashMap</span><span class="o">(</span><span class="n">buf</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">)</span>
<span class="c1">// mutable.HashMap[mutable.ArrayBuffer[Int], Int] = Map((ArrayBuffer(1, 2, 3), 3))</span>
<span class="n">map</span><span class="o">(</span><span class="n">buf</span><span class="o">)</span>  <span class="c1">// 3</span>
<span class="n">buf</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">map</span><span class="o">(</span><span class="n">buf</span><span class="o">)</span>  <span class="c1">// java.util.NoSuchElementException: key not found: ArrayBuffer(2, 2, 3)</span>
</pre></div>

<h3>
<a name="587---views" class="anchor" href="#587---views"><span class="octicon octicon-link"></span></a><strong>587 - Views</strong>
</h3>

<blockquote>
<ul>
<li>methods that construct new collections are called <strong>transformers</strong>, because they take at least one collection as their receiver object and produce another collection (e.g. <code>map</code>, <code>filter</code>, <code>++</code>)</li>
<li>transformers can be implemented in two principal ways, <strong>strict</strong> and <strong>non-strict (lazy)</strong>
</li>
<li>a strict transformers construct a new collection with all of its elements, whereas lazy transformers construct only a proxy for the result collection, where its elements are constructed on demand:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">def</span> <span class="n">lazyMap</span><span class="o">[</span><span class="kt">T</span>, <span class="kt">U</span><span class="o">](</span><span class="n">coll</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span> <span class="k">=</span>
  <span class="k">new</span> <span class="nc">Iterable</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="o">{</span>
    <span class="k">def</span> <span class="n">iterator</span> <span class="k">=</span> <span class="n">coll</span><span class="o">.</span><span class="n">iterator</span> <span class="n">map</span> <span class="n">f</span>
  <span class="o">}</span>

<span class="c1">// lazyMap constructs a new 'Iterable' without stepping through all elements of the</span>
<span class="c1">// given collection</span>
<span class="c1">// the given function 'f' is instead applied to the elements of the new collection's</span>
<span class="c1">// 'iterator' as they are demanded</span>
</pre></div>

<blockquote>
<ul>
<li>Scala collections are by default strict in all their transformers, except <code>Stream</code>, which implements all its transformer methods lazily</li>
<li>there is a systematic way to turn every collection into a lazy one and vice versa, which is base on collection views</li>
<li>a <strong>view</strong> is a special kind of collection that represents some base collection, but implements all its transformers lazily</li>
<li>to go from a collection to its view, you use the collection's <code>view</code> method</li>
<li>to get back from a view to a strict collection, you use the <code>force</code> method</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span><span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>  <span class="c1">// immutable.Vector[Int] = Vector(1, 2, 3, 4, 5)</span>
<span class="n">v</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>   <span class="c1">// immutable.Vector[Int] = Vector(4, 6, 8, 10, 12)</span>

<span class="c1">// a note about vector creation:</span>
<span class="c1">// if we had created the vector like this, we would've get 'Range':</span>
<span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="nc">Vector</span><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">5</span><span class="o">)</span>  <span class="c1">// Vector[immutable.Range.Inclusive] = Vector(Range(1,2,3,4,5))</span>

<span class="c1">// the expression 'v map (_ + 1)' constructs a new vector that is then transformed</span>
<span class="c1">// into a third vector by the second 'map' expression</span>

<span class="c1">// we could've used a single 'map' with the composition of the two functions,</span>
<span class="c1">// but that often isn't possible, since the code resides in different modules</span>
<span class="c1">// a more general way to avoid the intermediate results is by first turning the </span>
<span class="c1">// vector into a view, applying transformations to it, and forcing the view to a vector</span>
<span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="n">view</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)).</span><span class="n">force</span>

<span class="c1">// or one by one:</span>
<span class="k">val</span> <span class="n">vv</span> <span class="k">=</span> <span class="n">v</span><span class="o">.</span><span class="n">view</span>  <span class="c1">// collection.SeqView[Int, Vector[Int]] = SeqView(...)</span>
<span class="c1">// the 'v.view' gives us a 'SeqView', i.e. a lazily evaluated 'Seq'</span>
<span class="c1">// the type 'SeqView' has two type parameters, 'Int' shows the type of view's elems</span>
<span class="c1">// and the 'Vector[Int]' shows the type constructor we get back when forcing the view</span>

<span class="c1">// applying the first map to the view gives us:</span>
<span class="k">val</span> <span class="n">resInter</span> <span class="k">=</span> <span class="n">vv</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>  <span class="c1">// SeqView[Int,Seq[_]] = SeqViewM(...)</span>
<span class="c1">// 'SeqView(...)' is in essence a wrapper that records the fact that a 'map' with</span>
<span class="c1">// function (_ + 1) needs to be applied on the vector 'v'</span>
<span class="c1">// it does not apply that 'map' until the view is 'forced'</span>
<span class="c1">// the "M" after 'SeqView' is an indication that the view encapsulates a 'map' operation</span>
<span class="c1">// other letters indicate other delayed operations, "S" for 'slice', "R" for 'reverse'</span>

<span class="c1">// we now apply the second 'map' to the last result:</span>
<span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="n">resInter</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>  <span class="c1">// SeqView[Int, Seq[_]] = SeqViewMM(...)</span>
<span class="c1">// we now get a 'SeqView' that contains two map operations, so it prints with double "M"</span>

<span class="c1">// finally, forcing the last result gives:</span>
<span class="n">res</span><span class="o">.</span><span class="n">force</span>  <span class="c1">// Seq[Int] = Vector(4, 6, 8, 10, 12)</span>

<span class="c1">// both stored functions get applied as part of the execution of the 'force' operation</span>
<span class="c1">// that way, no intermediate data structure is needed</span>

<span class="c1">// one detail to note is that the static type of the final result is a 'Seq',</span>
<span class="c1">// not a 'Vector'</span>
<span class="c1">// tracing the types back we see that as soon as the first delayed 'map' was applied,</span>
<span class="c1">// the result had static type 'SeqViewM[Int, Seq[_]]', that is, the knowledge that</span>
<span class="c1">// the view was applied to the specific sequence type 'Vector' got lost</span>
<span class="c1">// the implementation of a view, for any particular class, requires quite a bit of code,</span>
<span class="c1">// so the Scala collection libraries provide view mostly only for general collection</span>
<span class="c1">// types, not for specific implementations (exception is 'Array': applying delayed</span>
<span class="c1">// operations on array will again give results with static type 'Array')</span>
</pre></div>

<blockquote>
<ul>
<li>there are two reasons why you might want to consider using views, the first, obviously, performance and the second:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// the problem of finding the first palindrome in a list of words:</span>
<span class="k">def</span> <span class="n">isPalindrome</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">reverse</span>
<span class="k">def</span> <span class="n">findPalindrome</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span> <span class="n">s</span> <span class="n">find</span> <span class="n">isPalindrome</span>
<span class="c1">// if 'words' is a previously defined (very long) list of words:</span>
<span class="n">findPalindrome</span><span class="o">(</span><span class="n">words</span> <span class="n">take</span> <span class="mi">1000000</span><span class="o">)</span>
<span class="c1">// this always constructs an intermediary sequence consisting of million words</span>
<span class="c1">// so, if the first word is a palindrome, this would copy 999 999 words into the</span>
<span class="c1">// intermediary result without being inspected at all afterwards</span>

<span class="c1">// with views:</span>
<span class="n">findPalindrome</span><span class="o">(</span><span class="n">words</span><span class="o">.</span><span class="n">view</span> <span class="n">take</span> <span class="mi">1000000</span><span class="o">)</span>
<span class="c1">// this would only construct a single lightweight view object</span>

<span class="c1">// ##### views over mutable sequences: #####</span>
<span class="c1">// many transformer functions on such views provide a window into the original sequence</span>
<span class="c1">// that can then be used to update selectively some elements of that sequence:</span>
<span class="k">val</span> <span class="n">arr</span> <span class="k">=</span> <span class="o">(</span><span class="mi">0</span> <span class="n">to</span> <span class="mi">4</span><span class="o">).</span><span class="n">toArray</span>  <span class="c1">// Array[Int] = Array(0, 1, 2, 3, 4)</span>

<span class="c1">// we can create a subwindow into that array by creating a slice of a view of the array:</span>
<span class="k">val</span> <span class="n">subarr</span> <span class="k">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">slice</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">)</span> <span class="c1">//IndexedSeqView[Int,Array[Int]] = IndexedSeqViewS(...)</span>
<span class="c1">// this gives a view which refers to elements at position 2 through 4 of the array 'arr'</span>
<span class="c1">// the view does not copy these elements, it simply provides a reference to them</span>

<span class="c1">// now assume you have a method that modifies some elements of a sequence</span>
<span class="c1">// e.g. the 'negate' method would negate all elements of the sequence it receives:</span>
<span class="k">def</span> <span class="n">negate</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">collection.mutable.Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="k">=</span> 
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span><span class="o">)</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="o">-</span><span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span>

<span class="c1">// if you wanted to negate elements from positions 2 through 4:</span>
<span class="n">negate</span><span class="o">(</span><span class="n">subarr</span><span class="o">)</span>
<span class="n">arr</span>  <span class="c1">// Array[Int] = Array(0, 1, -2, -3, -4, 5)</span>
<span class="c1">// 'negate' changed all elements which were a slice of the elements of 'arr'</span>
</pre></div>

<blockquote>
<ul>
<li>for smaller collections, the added overhead of forming and applying closures in views is often greater than the gain from avoiding the intermediary data structures</li>
<li>evaluation in views can be very confusing if the delayed operation have side effects</li>
<li>it is recommended that you use views either in purely functional code, where the collection transformations do not have side effects, or that you apply them over mutable collections where all modifications are done explicitly</li>
</ul>
</blockquote>

<h3>
<a name="593---iterators" class="anchor" href="#593---iterators"><span class="octicon octicon-link"></span></a><strong>593 - Iterators</strong>
</h3>

<blockquote>
<ul>
<li>a way to access elements of a collection one by one</li>
<li>a call to <code>it.next()</code> returns the next element and advances the state of the iterator</li>
<li>if there are no more elements, <code>next</code> throws <code>NoSuchElementException</code>
</li>
<li>to avoid that, we use <code>hasNext</code> method</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// the most straightforward way to step through the elements returned by an iterator:</span>
<span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">hasNext</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">())</span>

<span class="c1">// iterators provide analogues of most of the methods of 'Traversable', 'Iterable'</span>
<span class="c1">// and 'Seq' traits:</span>
<span class="n">it</span> <span class="n">foreach</span> <span class="n">println</span>

<span class="c1">// for can be used instead of 'foreach', 'map', 'filter' and 'flatMap':</span>
<span class="k">for</span> <span class="o">(</span><span class="n">elem</span> <span class="k">&lt;-</span> <span class="n">it</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>
</pre></div>

<blockquote>
<ul>
<li>there is an important difference between <code>foreach</code> on iterators and the same method on traversable collections: when called on an iterator, <code>foreach</code> will leave the iterator at its end when it's done (calling <code>next</code> yields 'NoSuchElementException'), but when called on a collection, it leaves the number of elements in the collection unchanged</li>
<li>the other operations that <code>Iterator</code> has in common with <code>Traversable</code> all have the same property of leaving the iterator at its end when done iterating:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="nc">Iterator</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">,</span> <span class="s">"is a"</span><span class="o">,</span> <span class="s">"b"</span><span class="o">)</span>  <span class="c1">// Iterator[String] = non-empty iterator</span>
<span class="k">val</span> <span class="n">res</span> <span class="k">=</span> <span class="n">it</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>  <span class="c1">// Iterator[Int] = non-empty iterator</span>
<span class="n">res</span> <span class="n">foreach</span> <span class="n">print</span>  <span class="c1">// 1141</span>
<span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>  <span class="c1">// java.util.NoSuchElementException: next on empty iterator</span>

<span class="c1">// a method that finds the first word in an iterator that has at least two characters:</span>
<span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="nc">Iterator</span><span class="o">(</span><span class="s">"a"</span><span class="o">,</span> <span class="s">"member"</span><span class="o">,</span> <span class="s">"of"</span><span class="o">,</span> <span class="s">"words"</span><span class="o">)</span>  <span class="c1">// Iterator[String] = non-empty iterator</span>
<span class="k">val</span> <span class="n">it2</span> <span class="k">=</span> <span class="n">it</span> <span class="n">dropWhile</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span>  <span class="c1">// Iterator[String] = non-empty iterator</span>
<span class="n">it2</span><span class="o">.</span><span class="n">next</span>  <span class="c1">// String = member</span>
<span class="n">it2</span><span class="o">.</span><span class="n">next</span>  <span class="c1">// String = of</span>
<span class="n">it</span><span class="o">.</span><span class="n">next</span>   <span class="c1">// String = words</span>

<span class="c1">// there's only one standard operation, 'duplicate', that allows reuse of an iterator:</span>
<span class="k">val</span> <span class="o">(</span><span class="n">it1</span><span class="o">,</span> <span class="n">it2</span><span class="o">)</span> <span class="k">=</span> <span class="n">it</span><span class="o">.</span><span class="n">duplicate</span>
<span class="c1">// 'duplicate' returns a pair of iterators that work independently</span>
<span class="c1">// the original iterator 'it' is advanced to its end by the 'duplicate' operation</span>
</pre></div>

<blockquote>
<ul>
<li>iterators behave like collections <strong>if you never access an iterator again after invoking a method on it</strong>
</li>
<li>Scala makes this explicit, by providing an abstraction called <code>TraversableOnce</code>, which is a common supertrait of <code>Traversable</code> and <code>Iterator</code>
</li>
<li>
<code>TraversableOnce</code> object can be traversed using <code>foreach</code>, but the state of that object after the traversal is not specified</li>
<li>if the <code>TraversableOnce</code> object is an <code>Iterator</code>, it will be at its end, but if it's a <code>Traversable</code>, it will still exist as before</li>
<li>a common use case for <code>TraversableOnce</code> is to use it as an argument type for methods that can take either an iterator or traversable, e.g. appending method <code>++</code> in trait <code>Traversable</code>, which takes a <code>TraversableOnce</code> parameter, so you can append elements coming from either an iterator or a traversable collection</li>
</ul>
</blockquote>

<p><em>All operations in trait <code>Iterator</code>:</em></p>

<ul>
<li><strong>Abstract methods</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it.next()</code>     Returns the next element and advances iter past it</li>
<li>
<code>it.hasNext</code>    Returns 'true' if 'it' can return another element</li>
</ul>
</blockquote>

<ul>
<li><strong>Variations</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it.buffered</code>      A buffered iter returning all elements of 'it'</li>
<li>
<code>it grouped size</code>  An iter that yields elems returned by 'it' in fixed-sized sequence chunks</li>
<li>
<code>xs sliding size</code>  An iter that yields elems returned by 'it' in sequences representing a sliding fixed-sized window</li>
</ul>
</blockquote>

<ul>
<li><strong>Copying</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it copyToBuffer buf</code>        Copies all elems returned by 'it' to buffer 'buf'</li>
<li>
<code>it copyToArray(arr, s, l)</code>  Copies at most 'l' elems returned by 'it' to array 'arr' starting at index 's' (last 2 args are optional)</li>
</ul>
</blockquote>

<ul>
<li><strong>Duplication</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it.duplicate</code>     A pair of iters that each independently return all elements of 'it'</li>
</ul>
</blockquote>

<ul>
<li><strong>Additions</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it ++ jt</code>           An iter returning all elems returned by 'it' followed by all elems returned by 'jt'</li>
<li>
<code>it padTo (len, x)</code>  An iter that returns all elems of 'it' followed by copies of 'x' until length 'len' elems are returned overall</li>
</ul>
</blockquote>

<ul>
<li><strong>Maps</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it map f</code>      The iter obtained from applying 'f' to every elem</li>
<li>
<code>it flatMap f</code>  The iter obtained from applying the iter-valued function 'f' to every elem and appending the result</li>
<li>
<code>it collect f</code>  The iter obtained from applying the partial function 'f' to every elem for which it is defined and collecting the results</li>
</ul>
</blockquote>

<ul>
<li><strong>Conversions</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it.toArray</code>       Collects the elements returned by 'it' in an array</li>
<li>
<code>it.toList</code>        Collects the elements returned by 'it' in a list</li>
<li>
<code>it.toIterable</code>    Collects the elements returned by 'it' in an iterable</li>
<li>
<code>it.toSeq</code>         Collects the elements returned by 'it' in a sequence</li>
<li>
<code>it.toIndexedSeq</code>  Collects the elements returned by 'it' in an indexed sequence</li>
<li>
<code>it.toStream</code>      Collects the elements returned by 'it' in a stream</li>
<li>
<code>it.toSet</code>         Collects the elements returned by 'it' in a set</li>
<li>
<code>it.toMap</code>         Collects the key/value pairs returned by 'it' in a map</li>
</ul>
</blockquote>

<ul>
<li><strong>Size info</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it.isEmpty</code>          Tests whether 'it' is empty (opposite of 'hasNext')</li>
<li>
<code>it.nonEmpty</code>         Tests whether the collection contains elems (alias of hasNext)</li>
<li>
<code>it.size</code>             The number of elems returned by 'it' (waists 'it')</li>
<li>
<code>it.length</code>           Same as 'it.size'</li>
<li>
<code>it.hasDefiniteSize</code>  Returns true if 'it' is known to return finitely many elems</li>
</ul>
</blockquote>

<ul>
<li><strong>Element retrieval index search</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it find p</code>        An option containing the first elem that satisfies 'p', or 'None' if no element qualifies (advances 'it' to just after the elem or to end)</li>
<li>
<code>it indexOf x</code>     The index of the first elem returned by 'it' that equals 'x' (advances past the position of 'x')</li>
<li>
<code>it indexWhere p</code>  The index of the first elem that satisfies 'p' (advances 'it' past the position of that elem)</li>
</ul>
</blockquote>

<ul>
<li><strong>Subiterators</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it take n</code>        An iter returning the first 'n' elems ('it' advances past n'th elem, or its end)</li>
<li>
<code>it drop n</code>        The iter that starts with the (n + 1)'th elem (advances 'it' to that same position)</li>
<li>
<code>it slice (m, n)</code>  The iter that returns a slice of the elems of 'it', starting with the m'th and ending before n'th</li>
<li>
<code>it takeWhile p</code>   An iter returning elems from 'it' as long as 'p' is true</li>
<li>
<code>it dropWhile p</code>   An iter skipping elems from 'it' as long as 'p' is true, and returning the remainder</li>
<li>
<code>it filter p</code>      An iter returning all elems from 'it' that satisfy 'p'</li>
<li>
<code>it withFilter p</code>  Same as 'filter' (needed so that iters can be used in 'for' expressions)</li>
<li>
<code>it filterNot p</code>   An iter returning all elems from 'it' that don't satisfy 'p'</li>
</ul>
</blockquote>

<ul>
<li><strong>Subdivisions</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it partition p</code>   Splits 'it' into a pair of two iters, based on whether elems satisfy 'p'</li>
</ul>
</blockquote>

<ul>
<li><strong>Element conditions</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it forall p</code>      A boolean indicating whether 'p' holds for all elems</li>
<li>
<code>it exists p</code>      A boolean indicating whether 'p' holds for some element</li>
<li>
<code>it count p</code>       The number of elems that satisfy predicate 'p'</li>
</ul>
</blockquote>

<ul>
<li><strong>Folds</strong></li>
</ul><blockquote>
<ul>
<li>
<code>(z /: it)(op)</code>        Applies binary operation 'op' between successive elems, going left to right, starting with 'z'</li>
<li>
<code>(z :\ it)(op)</code>        Applies binary operation 'op' between successive elems, going right to left, starting with 'z'</li>
<li>
<code>it.foldLeft(z)(op)</code>   Same as <code>(z /: it)(op)</code>
</li>
<li>
<code>it.foldRight(z)(op)</code>  Same as <code>(z :\ it)(op)</code>
</li>
<li>
<code>it reduceLeft op</code>     Applies binary operation 'op' between successive elems returned by non-empty iter 'it', going left to right</li>
<li>
<code>it reduceRight op</code>    Applies binary operation 'op' between successive elems returned by non-empty iter 'it', going right to left</li>
</ul>
</blockquote>

<ul>
<li><strong>Specific folds</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it.sum</code>           The sum of the numeric elem values returned by 'it'</li>
<li>
<code>it.product</code>       The product of the numeric elem values returned by 'it'</li>
<li>
<code>it.min</code>           The minimum of the ordered elem values returned by 'it'</li>
<li>
<code>it.max</code>           The maximum of the ordered elem values returned by 'it'</li>
</ul>
</blockquote>

<ul>
<li><strong>Zippers</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it zip jt</code>             Iter of pairs of corresponding elems from 'it' and 'jt'</li>
<li>
<code>it zipAll (jt, x, y)</code>  Iter of pairs of corresponding elems from 'it' and 'jt', where the shorter iter is extended to match the longer one, by appending elems x or y</li>
<li>
<code>it.zipWithIndex</code>       Iter of pairs of elems returned from 'it' with their indices</li>
</ul>
</blockquote>

<ul>
<li><strong>Update</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it patch (i, jt, r)</code>   Iter resulting from 'it' by replacing 'r' elems starting with 'i', by the patch iter 'jt'</li>
</ul>
</blockquote>

<ul>
<li><strong>Comparison</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it sameElements jt</code>    A test whether iters 'it' and 'jt' return the same elems in the same order (at least one of two iters ends up advancing to its end)</li>
</ul>
</blockquote>

<ul>
<li><strong>Strings</strong></li>
</ul><blockquote>
<ul>
<li>
<code>it addString (b, start, sep, end)</code>  Adds a string to 'StringBuilder b'  that shows all elems of 'it' between separators 'sep', enclosed in strings 'start' and 'end' ('start', 'sep', 'end' are all optional)</li>
<li>
<code>it mkString (start, sep, end)</code>      Converts the collection to a string that shows all elems of 'it' between separators 'sep', enclosed in strings 'start' and 'end' ('start', 'sep', 'end' are all optional)</li>
</ul>
</blockquote>

<h3>
<a name="600---buffered-iterators" class="anchor" href="#600---buffered-iterators"><span class="octicon octicon-link"></span></a><strong>600 - Buffered iterators</strong>
</h3>

<blockquote>
<ul>
<li>iterators that can "look ahead" so you can inspect the next element to be returned, without advancing past that element</li>
<li>every iterator can be converted to a buffered iterator by calling its <code>buffered</code> method</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// skip leading empty strings in an iterator (advances past the first non-empty elem)</span>
<span class="k">def</span> <span class="n">skipEmptyWordsNOT</span><span class="o">(</span><span class="n">it</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">().</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{}</span>
<span class="o">}</span>

<span class="c1">// with buffered iterator (instance of trait 'BufferedIterator'):</span>
<span class="k">def</span> <span class="n">skipEmptyWords</span><span class="o">(</span><span class="n">it</span><span class="k">:</span> <span class="kt">BufferedIterator</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="k">=</span>
  <span class="k">while</span> <span class="o">(</span><span class="n">it</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span> <span class="n">it</span><span class="o">.</span><span class="n">next</span><span class="o">()</span> <span class="o">}</span>

<span class="c1">// converting to buffered:</span>
<span class="k">val</span> <span class="n">it</span> <span class="k">=</span> <span class="nc">Iterator</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">)</span>  <span class="c1">// Iterator[Int] = non-empty iterator</span>
<span class="k">val</span> <span class="n">bit</span> <span class="k">=</span> <span class="n">it</span><span class="o">.</span><span class="n">buffered</span>  <span class="c1">// java.lang.Object with BufferedIterator[Int] = non-empty iter</span>
<span class="n">bit</span><span class="o">.</span><span class="n">head</span>    <span class="c1">// Int = 1</span>
<span class="n">bit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>  <span class="c1">// Int = 1</span>
<span class="n">bit</span><span class="o">.</span><span class="n">next</span><span class="o">()</span>  <span class="c1">// Int = 2</span>
</pre></div>

<h3>
<a name="601---creating-collections-from-scratch" class="anchor" href="#601---creating-collections-from-scratch"><span class="octicon octicon-link"></span></a><strong>601 - Creating collections from scratch</strong>
</h3>

<blockquote>
<ul>
<li>as with lists, <code>List(1, 2)</code> and maps, <code>Map('a' -&gt; 1, 'b' -&gt; 2)</code>, you can create any collection type by appending list of elements in parentheses to a collection name, which is, under the cover, a call to the <code>apply</code> method of some object:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="nc">Traversable</span><span class="o">()</span>             <span class="c1">// empty traversable object</span>
<span class="nc">List</span><span class="o">()</span>                    <span class="c1">// empty list</span>
<span class="nc">List</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span>            <span class="c1">// list with two elements</span>
<span class="nc">Vector</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span>          <span class="c1">// vector with two elements</span>
<span class="nc">Iterator</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>         <span class="c1">// iterator returning three integers</span>
<span class="nc">Set</span><span class="o">(</span><span class="n">dog</span><span class="o">,</span> <span class="n">cat</span><span class="o">,</span> <span class="n">bird</span><span class="o">)</span>       <span class="c1">// a set of three animals</span>
<span class="nc">HashSet</span><span class="o">(</span><span class="n">dog</span><span class="o">,</span> <span class="n">cat</span><span class="o">)</span>         <span class="c1">// a hash set of two animal</span>
<span class="nc">Map</span><span class="o">(</span><span class="-Symbol">'a</span><span class="err">'</span> <span class="o">-&gt;</span> <span class="mi">8</span><span class="o">,</span> <span class="-Symbol">'b</span><span class="err">'</span> <span class="o">-&gt;</span> <span class="mi">0</span> <span class="o">)</span>  <span class="c1">// a map from characters to integers</span>

<span class="c1">// under the cover:</span>
<span class="nc">List</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span>
<span class="c1">// expands to</span>
<span class="nc">List</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="mf">1.0</span><span class="o">,</span> <span class="mf">2.0</span><span class="o">)</span>
<span class="c1">// where 'List' is the companion object of the 'List' class, which takes an arbitrary</span>
<span class="c1">// number of arguments and constructs a list from them</span>

<span class="c1">// every collection class has a companion object with 'apply' method</span>
<span class="c1">// no matter if a collection is a concrete class or a trait</span>

<span class="c1">// if it's a trait, calling apply will product some default implementation of the trait:</span>
<span class="nc">Traversable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>          <span class="c1">// Traversable[Int] = List(1, 2, 3)</span>
<span class="n">mutable</span><span class="o">.</span><span class="nc">Traversable</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// mutable.Traversable[Int] = ArrayBuffer(1, 2, 3)</span>

<span class="c1">// besides 'apply', every collection companion object also defines 'empty'</span>
</pre></div>

<p><em>Factory methods for sequences:</em></p>

<blockquote>
<ul>
<li>
<code>S.empty</code>                    The empty sequence</li>
<li>
<code>S(x, y, z)</code>                 A sequence consisting of elements x, y and z</li>
<li>
<code>S.concat(xs, ys, zs)</code>       The sequence obtained by concatenating elems of xs, ys and zs</li>
<li>
<code>S.fill(n)(e)</code>               A sequence of length 'n' where each elem is computed by expression 'e'</li>
<li>
<code>S.fill(m, n)(e)</code>            A sequence of sequences of dimension 'm x n', where each elem is computed by expression 'e'</li>
<li>
<code>S.tabulate(n)(f)</code>           A sequence of length 'n' where the elem at each index 'i' is computed by 'f(i)'</li>
<li>
<code>S.tabulate(m, n)(f)</code>        A sequence of sequences of dimension 'm x n', where the elem at each index '(i, j)' is computed by 'f(i, j)'</li>
<li>
<code>S.range(start, end)</code>        The sequence of integers 'start ... end - 1'</li>
<li>
<code>S.range(start, end, step)</code>  The sequence of integers starting with 'start' and progressing by 'step' increments up to, and excluding 'end'</li>
<li>
<code>S.iterate(x, n)(f)</code>         The sequence of length 'n' with elems 'x, f(x), f(f(x)), ...'</li>
</ul>
</blockquote>

<h3>
<a name="603---conversions-between-java-and-scala-collections" class="anchor" href="#603---conversions-between-java-and-scala-collections"><span class="octicon octicon-link"></span></a><strong>603 - Conversions between Java and Scala collections</strong>
</h3>

<blockquote>
<ul>
<li>Scala offers implicit conversions between all major collection types in the <code>JavaConversions</code> object</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// two-way conversions:</span>
<span class="nc">Iterator</span>           <span class="o">&lt;-&gt;</span>       <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Iterator</span>
<span class="nc">Iterator</span>           <span class="o">&lt;-&gt;</span>       <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Enumeration</span>
<span class="nc">Iterable</span>           <span class="o">&lt;-&gt;</span>       <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Iterable</span>
<span class="nc">Iterable</span>           <span class="o">&lt;-&gt;</span>       <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Collection</span>
<span class="n">mutable</span><span class="o">.</span><span class="nc">Buffer</span>     <span class="o">&lt;-&gt;</span>       <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">List</span>
<span class="n">mutable</span><span class="o">.</span><span class="nc">Set</span>        <span class="o">&lt;-&gt;</span>       <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Set</span>
<span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span>        <span class="o">&lt;-&gt;</span>       <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Map</span>

<span class="c1">// to enable these automatic conversions:</span>
<span class="k">import</span> <span class="nn">collection.JavaConversions._</span>

<span class="k">import</span> <span class="nn">collection.mutable._</span>
<span class="k">val</span> <span class="n">jul</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">ArrayBuffer</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// java.util.List[Int] = [1, 2, 3]</span>
<span class="k">val</span> <span class="n">buf</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="n">jul</span>  <span class="c1">// mutable.Seq[Int] = ArrayBuffer(1, 2, 3)</span>
<span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">java.util.Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">HashMap</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">"ab"</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="c1">// java.util.Map[String, Int] = {ab=2, a=1}</span>

<span class="c1">// internally, these work by setting up a "wrapper" object that forwards all operations</span>
<span class="c1">// to the underlying collection object, so collections are never copied</span>

<span class="c1">// one-way conversion to Java types:</span>
<span class="nc">Seq</span>                 <span class="o">-&gt;</span>       <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">List</span>
<span class="n">mutable</span><span class="o">.</span><span class="nc">Seq</span>         <span class="o">-&gt;</span>       <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">List</span>
<span class="nc">Set</span>                 <span class="o">-&gt;</span>       <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Set</span>
<span class="nc">Map</span>                 <span class="o">-&gt;</span>       <span class="n">java</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="nc">Map</span>

<span class="c1">// because Java does not distinguish between mutable and immutable collection in their</span>
<span class="c1">// type, a conversion from, say, 'immutable.List' will yield a 'java.util.List',</span>
<span class="c1">// on which all attempted mutations will throw an 'UnsupportedOperationException':</span>
<span class="k">val</span> <span class="n">jul</span><span class="k">:</span> <span class="kt">java.util.List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// java.util.List[Int] = [1, 2, 3]</span>
<span class="n">jul</span><span class="o">.</span><span class="n">add</span><span class="o">(</span><span class="mi">8</span><span class="o">)</span>  <span class="c1">// java.lang.UnsupportedOperationException at java.util.AbstractList.add</span>
</pre></div>

<h2>
<a name="the-architecture-of-scala-collections" class="anchor" href="#the-architecture-of-scala-collections"><span class="octicon octicon-link"></span></a>The Architecture of Scala Collections</h2>

<blockquote>
<ul>
<li>the design approach was to implement most operations in collection "templates" that can be flexibly inherited from individual base classes and implementations</li>
</ul>
</blockquote>

<h3>
<a name="608---builders" class="anchor" href="#608---builders"><span class="octicon octicon-link"></span></a><strong>608 - Builders</strong>
</h3>

<blockquote>
<ul>
<li>almost all collection operations are implemented in terms of <em>traversals</em> and <em>builders</em>
</li>
<li>traversals are handled by <code>Traversable</code>'s <code>foreach</code> method, and building new collections is handled by instances of class <code>Builder</code>
</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// abbreviated outline of the 'Builder' class</span>
<span class="k">package</span> <span class="nn">scala.collection.generic</span>

<span class="k">class</span> <span class="nc">Builder</span><span class="o">[</span><span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="o">+=(</span><span class="n">elem</span><span class="k">:</span> <span class="kt">Elem</span><span class="o">)</span><span class="k">:</span> <span class="kt">this.type</span>
  <span class="k">def</span> <span class="n">result</span><span class="o">()</span><span class="k">:</span> <span class="kt">To</span>
  <span class="k">def</span> <span class="n">clear</span><span class="o">()</span>
  <span class="k">def</span> <span class="n">mapResult</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">To</span> <span class="o">=&gt;</span> <span class="nc">NewTo</span><span class="o">)</span><span class="k">:</span> <span class="kt">Bulder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">NewTo</span><span class="o">]</span> <span class="k">=</span> <span class="c1">//...</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>you can add an element to a builder with <code>b += x</code>, or more than one element with <code>b += (x, y)</code> or with <code>b ++= xs</code> (works same as for buffers, which are, in fact, enriched version of builders)</li>
<li>the <code>result()</code> method returns a collection from a builder</li>
<li>the state of builder is undefined after taking its result, but it can be reset into a new clean state using <code>clear()</code>
</li>
<li>builders are generic in both the element type, <code>Elem</code> and in the type <code>To</code>, of collections they return</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// to use 'ArrayBuffer' to produce a builder that builds arrays:</span>
<span class="k">val</span> <span class="n">buf</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>  <span class="c1">// mutable.ArrayBuffer[Int] = ArrayBuffer()</span>
<span class="k">val</span> <span class="n">bldr</span> <span class="k">=</span> <span class="n">buf</span> <span class="n">mapResult</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toArray</span><span class="o">)</span>  <span class="c1">// mutable.Builder[Int, Array[Int]] = ArrayBuffer()</span>

<span class="c1">// the result value, 'bldr' is a builder that uses the array buffer to collect elems</span>
<span class="c1">// when a result is demanded from 'bldr', the result of 'buf' is computed, which</span>
<span class="c1">// yields the array buffer 'but' itself</span>
<span class="c1">// this array buffer is then mapped with '_.toArray' to an array</span>
<span class="c1">// so the end result is that 'bldr' is a builder for arrays</span>
</pre></div>

<h2>
<a name="609---factoring-out-common-operations" class="anchor" href="#609---factoring-out-common-operations"><span class="octicon octicon-link"></span></a><strong>609 - Factoring out common operations</strong>
</h2>

<blockquote>
<ul>
<li>Scala collection library avoids code duplication and achieves the <em>same result type</em> principle by using generic builders and traversals over collections in so-called <strong>implementation traits</strong>
</li>
<li>these traits are named with a <strong>Like</strong> suffix (e.g. <code>IndexedSeqLike</code> is the implementation trait for <code>IndexedSeq</code>)</li>
<li>collection classes such as <code>IndexedSeq</code> or <code>Traversable</code> inherit all their concrete method implementations from these traits</li>
<li>
<em>implementation traits</em> have two type parameters instead of usual one for collections, because they parameterize not only over the collection's element type, but also over the collection's <strong>representation type</strong> (i.e. the type of the underlying collection, such as <code>Seq[I]</code> or <code>List[T]</code>)</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// the header of the trait 'TraversableLike':</span>
<span class="k">trait</span> <span class="nc">TraversableLike</span><span class="o">[</span><span class="kt">+Elem</span>, <span class="kt">+Repr</span><span class="o">]</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="c1">// type parameter 'Elem' - element type of traversable</span>
<span class="c1">// type parameter 'Repr' - representation type of elements</span>
</pre></div>

<blockquote>
<ul>
<li>there are no constraints on 'Repr', it might be instantiated to a type that is itself not a subtype of <code>Traversable</code> (that way classes like <code>String</code> and <code>Array</code> can still make use of all operations defined in a collection implementation trait)</li>
<li>e.g. <code>filter</code> is implemented once for all collection classes in the trait <code>TraversableLike</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// implementation of 'filter' in 'TraversableLike'</span>
<span class="k">package</span> <span class="nn">scala.collection</span>

<span class="k">class</span> <span class="nc">TraversableLike</span><span class="o">[</span><span class="kt">+Elem</span>, <span class="kt">+Repr</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">Repr</span><span class="o">]</span>  <span class="c1">// deferred to concrete implementation classes</span>
  <span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span>         <span class="c1">// deferred</span>

  <span class="k">def</span> <span class="n">filter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Repr</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">newBuilder</span>  <span class="c1">// first constructs a new builder for the representation type</span>
    <span class="n">foreach</span> <span class="o">{</span> <span class="n">elem</span> <span class="k">=&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">p</span><span class="o">(</span><span class="n">elem</span><span class="o">))</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">elem</span> <span class="o">}</span>  <span class="c1">// traverses all elems of the collection</span>
                     <span class="c1">// and if an elem satisfies 'p' adds it to the builder</span>
    <span class="n">b</span><span class="o">.</span><span class="n">result</span>  <span class="c1">// finally, all elems collected in the builder are returned</span>
              <span class="c1">// as an instance of the 'Repr' collection type by calling 'result'</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>a bit more complicated is the <code>map</code> operation on collections, for example, if <code>f</code> is a function from <code>String</code> to <code>Int</code>, and <code>xs</code> is a <code>List[String]</code>, then <code>xs map f</code> should give a <code>List[Int]</code>, but if <code>xs</code> is an <code>Array[String]</code>, then the same expression should return <code>Array[Int]</code>
</li>
<li>how does Scala achieve that without duplicating implementations of the <code>map</code> methods in both <code>List</code> and <code>Array</code>?</li>
<li>the <code>newBuilder</code> &amp; <code>foreach</code> combination is not enough, since it only allows creation of new instances of the same collection type</li>
<li>on top of that requirement, there's a problem that even the result type constructor of a function like <code>map</code> might depend in non trivial ways on the other argument types:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">import</span> <span class="nn">collection.immutable.BitSet</span>
<span class="k">val</span> <span class="n">bits</span> <span class="k">=</span> <span class="nc">BitSet</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// immutable.BitSet = BitSet(1, 2, 3)</span>
<span class="n">bits</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">2</span><span class="o">)</span>            <span class="c1">// BitSet(2, 4, 6)</span>
<span class="n">bits</span> <span class="n">map</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toFloat</span><span class="o">)</span>        <span class="c1">// immutable.Set[Float] = Set(1.0, 2.0, 3.0)</span>

<span class="c1">// if you map the doubling function over a bit set, you get another bit set back</span>
<span class="c1">// but if you map the function 'toFloat' over the same bit set, you get 'Set[Float]'</span>
<span class="c1">// because bit sets can only contain ints</span>
</pre></div>

<blockquote>
<ul>
<li>the map's result type depends on the type of function that's passed to it</li>
<li>if the result type of that function stays int, the result will be bit set, but if the result type of the function argument is something else, the result is just a set</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// the problem is, of course, not just with bit sets:</span>
<span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">y</span><span class="o">,</span> <span class="n">x</span><span class="o">)}</span> <span class="c1">// Map[Int, String] = Map(1-&gt;a,2-&gt;b)</span>
<span class="nc">Map</span><span class="o">(</span><span class="s">"a"</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="s">"b"</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">y</span><span class="o">}</span> <span class="c1">// Iterable[Int] = List(1, 2)</span>

<span class="c1">// second function maps key/value pair to integer, in which case we cannot form a map</span>
<span class="c1">// but we can still form an iterable, a supertrait of map</span>
<span class="c1">// every operation that's legal on iterable, must also be legal on a map</span>
</pre></div>

<blockquote>
<ul>
<li>Scala solves this problem with overloading that's provided by implicit parameters:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// implementation of 'map' in 'TraversableLike':</span>
<span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">That</span><span class="o">](</span><span class="n">p</span><span class="k">:</span> <span class="kt">Elem</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)(</span><span class="k">implicit</span> <span class="n">bf</span><span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">That</span>, <span class="kt">This</span><span class="o">])</span><span class="k">:</span> <span class="kt">That</span> <span class="o">=</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">b</span> <span class="k">=</span> <span class="n">bf</span><span class="o">(</span><span class="k">this</span><span class="o">)</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">x</span> <span class="k">&lt;-</span> <span class="k">this</span><span class="o">)</span> <span class="n">b</span> <span class="o">+=</span> <span class="n">f</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
  <span class="n">b</span><span class="o">.</span><span class="n">result</span>
<span class="o">}</span>

<span class="c1">// where 'filter' used the 'newBuilder' method, 'map' uses a 'builder factory' that's</span>
<span class="c1">// passed as an additional implicit parameter of type 'CanBuildFrom':</span>
<span class="k">package</span> <span class="nn">scala.collection.generic</span>

<span class="k">trait</span> <span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">-From</span>, <span class="kt">-Elem</span>, <span class="kt">+To</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">From</span><span class="o">)</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Elem</span>, <span class="kt">To</span><span class="o">]</span>  <span class="c1">// creates a new builder</span>
<span class="o">}</span>

<span class="c1">// Elem - indicates the element type of the collection to be built</span>
<span class="c1">// To   - indicates the type of collection to be built</span>
<span class="c1">// From - indicates the type for which this builder factory applies</span>

<span class="c1">// e.g. BitSet's companion object would contain a builder factory of type</span>
<span class="c1">// CanBuildFrom[BitSet, Int, BitSet], which means that</span>
<span class="c1">// when operating on BitSet, you can construct another BitSet provided the type of the</span>
<span class="c1">// collection to build is 'Int'</span>
<span class="c1">// if this is not the case, you can always fall back to different, more general</span>
<span class="c1">// implicit builder factory implemented in mutable.Set's companion object:</span>
<span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">A</span>, <span class="kt">Set</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>

<span class="c1">// which means that, when operating on an arbitrary set (Set[_]), you can build a set</span>
<span class="c1">// again, no matter what the element type 'A' is</span>

<span class="c1">// given various implicit instances of `CanBuildFrom`, you can rely on Scala's implicit</span>
<span class="c1">// resolution rules to pick the one that's appropriate and maximally specific</span>

<span class="c1">// but what about dynamic types?</span>
<span class="k">val</span> <span class="n">xs</span><span class="k">:</span> <span class="kt">Iterable</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>  <span class="c1">// Iterable[Int] = List(1, 2, 3)</span>
<span class="k">val</span> <span class="n">ys</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">map</span> <span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">)</span>           <span class="c1">// Iterable[Int] = List(1, 4, 9)</span>

<span class="c1">// the static type 'ys' is iterable, as expected, but its dynamic type is still 'List'</span>
<span class="c1">// this is achieved by one more indirection. The 'apply' method in 'CanBuildFrom' is </span>
<span class="c1">// passed the source collection as argument</span>
<span class="c1">// all builder factories for generic traversables (except for leaf classes) forward the </span>
<span class="c1">// call to a method 'genericBuilder' of a collection, which in turn calls the builder</span>
<span class="c1">// that belongs to the collection in which it is defined</span>

<span class="c1">// so Scala uses static implicit resolution to resolve constraints on the types of 'map'</span>
<span class="c1">// and virtual dispatch to pick the best dynamic type that corresponds to these </span>
<span class="c1">// constraints</span>
</pre></div>

<h3>
<a name="614---integrating-new-collections" class="anchor" href="#614---integrating-new-collections"><span class="octicon octicon-link"></span></a><strong>614 - Integrating new collections</strong>
</h3>

<ul>
<li><strong>Integrating sequences</strong></li>
</ul><div class="highlight highlight-scala"><pre><span class="c1">// sequence type for RNA strands (A, T, G, U)</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">Base</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">A</span> <span class="k">extends</span> <span class="nc">Base</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">T</span> <span class="k">extends</span> <span class="nc">Base</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">G</span> <span class="k">extends</span> <span class="nc">Base</span>
<span class="k">case</span> <span class="k">object</span> <span class="nc">U</span> <span class="k">extends</span> <span class="nc">Base</span>

<span class="k">object</span> <span class="nc">Base</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">fromInt</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">Base</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">U</span><span class="o">)</span>
  <span class="k">val</span> <span class="n">toInt</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=&gt;</span> <span class="nc">Int</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="n">A</span> <span class="o">-&gt;</span> <span class="mi">0</span><span class="o">,</span> <span class="n">T</span> <span class="o">-&gt;</span> <span class="mi">1</span><span class="o">,</span> <span class="n">G</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">,</span> <span class="n">U</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// RNA strands class, v1</span>
<span class="k">import</span> <span class="nn">collection.IndexedSeqLike</span>
<span class="k">import</span> <span class="nn">collection.mutable.</span><span class="o">{</span><span class="nc">Builder</span><span class="o">,</span> <span class="nc">ArrayBuffer</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">collection.generic.CanBuildFrom</span>

<span class="c1">// RNA strands can be very long, so we're building our own collection to optimize</span>
<span class="c1">// since there are only 4 bases, a base can be uniquely identified with 2 bits</span>
<span class="c1">// so you can store 16 bases in an integer</span>
<span class="c1">// we'll create a specialized subclass of 'Seq[Base]'</span>

<span class="c1">// 'groups' represents packed bases (16 in each array elem, except maybe in last)</span>
<span class="c1">// 'length' specifies total number of bases on the array</span>
<span class="c1">// 'private', so clients cannot instantiate it with 'new' (hiding implementation)</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">RNA1</span> <span class="k">private</span> <span class="o">(</span><span class="k">val</span> <span class="n">groups</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>  <span class="c1">// parametric fields</span>
    <span class="k">extends</span> <span class="nc">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="o">{</span>  <span class="c1">// 'IndexedSeq' has 'length' and 'apply' methods</span>
  <span class="k">import</span> <span class="nn">RNA1._</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">idx</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="o">)</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IndexOutOfBoundsException</span>

    <span class="c1">// extract int value from the 'groups', then extract 2-bit number</span>
    <span class="nc">Base</span><span class="o">.</span><span class="n">fromInt</span><span class="o">(</span><span class="n">groups</span><span class="o">(</span><span class="n">idx</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="o">(</span><span class="n">idx</span> <span class="o">%</span> <span class="n">N</span> <span class="o">*</span> <span class="n">S</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">RNA1</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">S</span> <span class="k">=</span> <span class="mi">2</span>             <span class="c1">// number of bits necessary to represent group</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">N</span> <span class="k">=</span> <span class="mi">32</span>            <span class="c1">// number of groups that fit into Int</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">M</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1">// bitmask to isolate a group (lowest S bits in a word)</span>

  <span class="c1">// converts given sequence of bases to instance of RNA1</span>
  <span class="k">def</span> <span class="n">fromSeq</span><span class="o">(</span><span class="n">buf</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Base</span><span class="o">])</span><span class="k">:</span> <span class="kt">RNA1</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">groups</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]((</span><span class="n">buf</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>  <span class="c1">// packs all the bases</span>
      <span class="n">groups</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="o">|=</span> <span class="nc">Base</span><span class="o">.</span><span class="n">toInt</span><span class="o">(</span><span class="n">buf</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">N</span> <span class="o">*</span> <span class="n">S</span><span class="o">)</span>  <span class="c1">// bitwise-or equals</span>

    <span class="k">new</span> <span class="nc">RNA1</span><span class="o">(</span><span class="n">groups</span><span class="o">,</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">bases</span><span class="k">:</span> <span class="kt">Base*</span><span class="o">)</span> <span class="k">=</span> <span class="n">fromSeq</span><span class="o">(</span><span class="n">bases</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// using RNA:</span>
<span class="k">val</span> <span class="n">xs</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">,</span> <span class="n">A</span><span class="o">)</span>       <span class="c1">// List[Product with Base] = List(A, G, T, A)</span>
<span class="nc">RNA1</span><span class="o">.</span><span class="n">fromSeq</span><span class="o">(</span><span class="n">xs</span><span class="o">)</span>                <span class="c1">// RNA(A, G, T, A)</span>
<span class="k">val</span> <span class="n">rna1</span> <span class="k">=</span> <span class="nc">RNA1</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>  <span class="c1">// RNA1(A, U, G, G, T)</span>

<span class="n">println</span><span class="o">(</span><span class="n">rna1</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>            <span class="c1">// Int = 5</span>
<span class="n">println</span><span class="o">(</span><span class="n">rna1</span><span class="o">.</span><span class="n">last</span><span class="o">)</span>              <span class="c1">// Base = T</span>
<span class="n">println</span><span class="o">(</span><span class="n">rna1</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="mi">3</span><span class="o">))</span>           <span class="c1">// IndexedSeq[Base] = Vector(A, U, G)</span>

<span class="c1">// the last line returns 'Vector', as the default implementation of 'IndexedSeq', since</span>
<span class="c1">// all we did in class 'RNA1' was extend 'IndexedSeq', which used its 'take' method,</span>
<span class="c1">// which doesn't know how to handle bases</span>

<span class="c1">// we might override method 'take':</span>
<span class="k">def</span> <span class="n">take</span><span class="o">(</span><span class="n">count</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">RNA1</span> <span class="o">=</span> <span class="nc">RNA1</span><span class="o">.</span><span class="n">fromSeq</span><span class="o">(</span><span class="k">super</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="n">count</span><span class="o">))</span>
<span class="c1">// which would take care of 'take', but what about 'drop', 'filter' or 'init'?</span>
<span class="c1">// we would have to override over 50 methods on sequences that return a sequence</span>

<span class="c1">// there is a way, the 'RNA' class needs to inherit not only from 'IndexedSeq', but</span>
<span class="c1">// also from its implementation trait 'IndexedSeqLike':</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">RNA2</span> <span class="k">private</span> <span class="o">(</span><span class="k">val</span> <span class="n">groups</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="k">with</span> <span class="nc">IndexedSeqLike</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA2</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">RNA2._</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA2</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">ArrayBuffer</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="n">mapResult</span> <span class="n">fromSeq</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">idx</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=</span> <span class="c1">// ... same as before</span>
<span class="o">}</span>
<span class="c1">// 'IndexedSeqLike' trait implements all concrete methods of 'IndexedSeq'</span>
<span class="c1">// the return type of methods like 'take', 'drop', 'filter' is the second type parameter</span>
<span class="c1">// passed to class 'IndexedSeqLike', 'RNA2'</span>

<span class="c1">// to be able to do this, 'IndexedSeqLike' uses the 'newBuilder' abstraction, which</span>
<span class="c1">// creates a builder of the right kind</span>
<span class="c1">// subclasses of trait 'IndexedSeqLike' have to override 'newBuilder' to return </span>
<span class="c1">// collections of their own kind ('Builder[Base, RNA2]', in case of RNA2 class)</span>

<span class="c1">// it first creates an 'ArrayBuffer', which is itself a 'Builder[Base, ArrayBuffer]'</span>
<span class="c1">// it then transforms the 'ArrayBuffer' builder to an 'RNA2' builder, by calling its</span>
<span class="c1">// 'mapResult' method</span>
<span class="c1">// 'mapResult' expects a transformation function from 'ArrayBuffer' to 'RNA2' as param</span>
<span class="c1">// the function we send is simply 'RNA2.fromSeq', which converts an arbitrary base</span>
<span class="c1">// sequence to an 'RNA2' value (array buffer is a kind of sequence, so 'fromSeq' works)</span>
</pre></div>

<blockquote>
<ul>
<li>there are methods that might return the same kind of collection, but with a different element type, e.g. <code>map</code>. If <code>s</code> is a <code>Seq[Int]</code>, and <code>f</code> is a function from <code>Int</code> to <code>String</code>, then <code>s.map(f)</code> would return a <code>Seq[String]</code>, meaning that the element type changes between the receiver and the result, but the type of collection stays the same</li>
<li>there are a number of methods that behave the same as <code>map</code>, like <code>flatMap</code>, <code>collect</code>, and even the append, <code>++</code> method, which also may return a result of a different type, e.g. appending a list of <code>String</code> to a list of <code>Int</code> would give a list of <code>Any</code>
</li>
<li>we can accept the rule that mapping bases to bases over an <code>RNA</code> strand would yield again an <code>RNA</code> strand, but mapping bases to some other type necessarily results in a different type:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// mapping to the same type:</span>
<span class="k">val</span> <span class="n">rna</span> <span class="k">=</span> <span class="nc">RNA</span><span class="o">(</span><span class="n">A</span><span class="o">,</span> <span class="n">U</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">G</span><span class="o">,</span> <span class="n">T</span><span class="o">)</span>
<span class="n">rna</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="n">A</span> <span class="k">=&gt;</span> <span class="n">T</span> <span class="k">case</span> <span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="o">}</span>  <span class="c1">// Vector(A, U, G, G, T)</span>
<span class="n">rna</span> <span class="o">++</span> <span class="n">rna</span>  <span class="c1">// Vector(A, U, G, G, T, A, U, G, G, T)</span>

<span class="c1">// but mapping to some other type:</span>
<span class="n">rna</span> <span class="n">map</span> <span class="nc">Base</span><span class="o">.</span><span class="n">toInt</span>  <span class="c1">// IndexedSeq[Int] = Vector(0, 3, 2, 2, 1)</span>
<span class="n">rna</span> <span class="o">++</span> <span class="nc">List</span><span class="o">(</span><span class="s">"ie"</span><span class="o">,</span> <span class="s">"eg"</span><span class="o">)</span>  <span class="c1">// IndexedSeq[java.lang.Object] = Vector(A, U, G, G, T, ie, eg)</span>

<span class="c1">// to figure out a better way, first look at the signature of the 'map' method</span>
<span class="c1">// which is originally defined in class 'scala.collection.TraversableLike':</span>
<span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">B</span>, <span class="kt">That</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">A</span> <span class="o">=&gt;</span> <span class="n">B</span><span class="o">)</span>
  <span class="o">(</span><span class="k">implicit</span> <span class="n">cbf</span><span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">Repr</span>, <span class="kt">B</span>, <span class="kt">That</span><span class="o">])</span><span class="k">:</span> <span class="kt">That</span>

<span class="c1">// A    - type of elements of the collection</span>
<span class="c1">// Repr - type of the collection itself (gets passed to TraversableLike, IndexedSeqLike)</span>
<span class="c1">// B    - result type of the mapping function (elem type of the new collection)</span>
<span class="c1">// That - result type of 'map' (type of the new collection, that gets created)</span>

<span class="c1">// how is the type of 'That' determined?</span>
<span class="c1">// it is linked to the other types by an implicit parameter 'cbf',</span>
<span class="c1">// these cbf implicits are defined by the individual collection classes</span>
<span class="c1">// 'CanBuildFrom[Repr, B, That]' says: "Here is a way, given a collection of type 'From',</span>
<span class="c1">// to build with elements of type 'Elem' a collection of type 'To'"</span>

<span class="c1">// now it's clear, there was no 'CanBuildFrom' instance that creates 'RNA2' sequences,</span>
<span class="c1">// so the next best thing available was used, 'CanBuildFrom' of the companion object</span>
<span class="c1">// of the inherited trait 'IndexedSeq', which creates indexed seqs</span>

<span class="c1">// to address this, we need to define an implicit instance of 'CanBuildFrom' in the</span>
<span class="c1">// companion object of the 'RNA' class, which should be 'CanBuildFrom[RNA, Base, RNA]'</span>
<span class="c1">// which states that, given an 'RNA' and a new element type 'Base', we can build</span>
<span class="c1">// another collection which is again 'RNA':</span>
<span class="k">final</span> <span class="k">class</span> <span class="nc">RNA</span> <span class="k">private</span> <span class="o">(</span><span class="k">val</span> <span class="n">groups</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="k">val</span> <span class="n">length</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span>
    <span class="k">extends</span> <span class="nc">IndexedSeq</span><span class="o">[</span><span class="kt">Base</span><span class="o">]</span> <span class="k">with</span> <span class="nc">IndexedSeqLike</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="o">{</span>

  <span class="k">import</span> <span class="nn">RNA._</span>
  <span class="c1">// mandatory re-implementation of 'newBuilder' in 'IndexedSeq'</span>
  <span class="k">override</span> <span class="k">protected</span><span class="o">[</span><span class="kt">this</span><span class="o">]</span> <span class="k">def</span> <span class="n">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span> <span class="nc">RNA</span><span class="o">.</span><span class="n">newBuilder</span>
  <span class="c1">// Mandatory implementation of 'apply' in 'IndexedSeq'</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">idx</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">idx</span><span class="o">)</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">IndexOutOfBoundsException</span>

    <span class="nc">Base</span><span class="o">.</span><span class="n">fromInt</span><span class="o">(</span><span class="n">groups</span><span class="o">(</span><span class="n">idx</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="o">(</span><span class="n">idx</span> <span class="o">%</span> <span class="n">N</span> <span class="o">*</span> <span class="n">S</span><span class="o">)</span> <span class="o">&amp;</span> <span class="n">M</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="c1">// optional implementation of 'foreach' to make it more efficient</span>
  <span class="c1">// for every selected array elem it immediately applies given function to all bases</span>
  <span class="c1">// contained in it (as opposed to default 'foreach', which simply selects every i-th</span>
  <span class="c1">// elem using 'apply')</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">foreach</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">Base</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">var</span> <span class="n">b</span> <span class="k">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">b</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">groups</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="k">else</span> <span class="n">b</span> <span class="o">&gt;&gt;&gt;</span> <span class="n">S</span>
      <span class="n">f</span><span class="o">(</span><span class="nc">Base</span><span class="o">.</span><span class="n">fromInt</span><span class="o">(</span><span class="n">b</span> <span class="o">&amp;</span> <span class="n">M</span><span class="o">))</span>
      <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">RNA</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">S</span> <span class="k">=</span> <span class="mi">2</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">M</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">S</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">N</span> <span class="k">=</span> <span class="mi">32</span> <span class="o">/</span> <span class="n">S</span>

  <span class="k">def</span> <span class="n">fromSeq</span><span class="o">(</span><span class="n">buf</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Base</span><span class="o">])</span><span class="k">:</span> <span class="kt">RNA</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">groups</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]((</span><span class="n">buf</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
      <span class="n">groups</span><span class="o">(</span><span class="n">i</span> <span class="o">/</span> <span class="n">N</span><span class="o">)</span> <span class="o">|=</span> <span class="nc">Base</span><span class="o">.</span><span class="n">toInt</span><span class="o">(</span><span class="n">buf</span><span class="o">(</span><span class="n">i</span><span class="o">))</span> <span class="o">&lt;&lt;</span> <span class="o">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">N</span> <span class="o">*</span> <span class="n">S</span><span class="o">)</span>

    <span class="k">new</span> <span class="nc">RNA</span><span class="o">(</span><span class="n">groups</span><span class="o">,</span> <span class="n">buf</span><span class="o">.</span><span class="n">length</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">bases</span><span class="k">:</span> <span class="kt">Base*</span><span class="o">)</span> <span class="k">=</span> <span class="n">fromSeq</span><span class="o">(</span><span class="n">bases</span><span class="o">)</span>

  <span class="c1">// implementation moved here from the RNA class (only a call to this one left there)</span>
  <span class="k">def</span> <span class="n">newBuilder</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ArrayBuffer</span> <span class="n">mapResult</span> <span class="n">fromSeq</span>

  <span class="c1">// </span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">canBuildFrom</span><span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">RNA</span>, <span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">RNA</span>, <span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="o">{</span>
      <span class="c1">// these two are useful for adapting the dynamic type of builder's return type</span>
      <span class="c1">// to be the same as the dynamic type of the receiver (not in play here - final)</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">()</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span> <span class="n">newBuilder</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">RNA</span><span class="o">)</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[</span><span class="kt">Base</span>, <span class="kt">RNA</span><span class="o">]</span> <span class="k">=</span> <span class="n">newBuilder</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<ul>
<li><strong>Integrating new sets and maps</strong></li>
</ul><blockquote>
<ul>
<li>how to integrate new kind of map into the collection framework?</li>
<li>e.g. a mutable map with <code>String</code> as the key type, by a <strong>Patricia trie</strong>, where "Patricia" stands for <em>"Practical Algorithm To Retrieve Information Coded in Alphanumerics"</em> </li>
<li>the idea is to store a set or a map as a tree where subsequent character in a search key uniquely determines a descendant tree</li>
<li>e.g. Patricia trie that stores strings <code>abc</code>, <code>abd</code>, <code>al</code>, <code>all</code> and <code>xy</code> would look like the following image:</li>
</ul>
</blockquote>

<p><a href="https://github.com/mbonaci/scala/blob/master/resources/Scala-patricia-trie.gif?raw=true" target="_blank"><img src="https://github.com/mbonaci/scala/blob/master/resources/Scala-patricia-trie.gif?raw=true" alt="Patricia trie image" style="max-width:100%;"></a></p>

<blockquote>
<ul>
<li>to find a node corresponding to the string <code>abc</code>, you'd simply follow the subtree labeled "a", then proceed to subtree "b", to finally reach its subtree "c"</li>
<li>if it's used as a map, the value associated with a key is stored in nodes that can be reached by that key</li>
<li>if it's a set, you simply store a marker saying that the node is present in the set</li>
<li>
<em>Patricia tries</em> support very efficient lookups and updates</li>
<li>another great feature is that they support selecting a subcollection by giving a prefix (e.g. to find a subcollection of all keys that start with an "a", you simply follow the "a" link from the root of the tree)</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// PrefixMap implementation (Patricia trie based)</span>
<span class="c1">// by 'Prefix' we want to say that our map has method 'withPrefix', that selects</span>
<span class="c1">// a submap of all keys starting with a given prefix</span>
<span class="k">import</span> <span class="nn">collection._</span>
<span class="k">class</span> <span class="nc">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> 
    <span class="nc">extends</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">Map</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">]</span> <span class="k">with</span> <span class="n">mutable</span><span class="o">.</span><span class="nc">MapLike</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">T</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="o">{</span>
    <span class="c1">// inheriting 'MapLike' serves to get the right result type for transformations</span>
    <span class="c1">// such as 'filter'</span>
  <span class="k">var</span> <span class="n">suffixes</span><span class="k">:</span> <span class="kt">immutable.Map</span><span class="o">[</span><span class="kt">Char</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">.</span><span class="n">empty</span>
  <span class="c1">// immutable maps with small number of elems are more efficient than mutable maps</span>
  <span class="k">var</span> <span class="n">value</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">None</span>

  <span class="c1">// </span>
  <span class="k">def</span> <span class="n">get</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="n">value</span>  <span class="c1">// simply select the optional value stored in the root</span>
    <span class="c1">// try to select the submap corresponding to the first char or the string</span>
    <span class="c1">// if that yields a submap, follow up by looking up the remainder of the key</span>
    <span class="c1">// after its first char and if the key is not found return 'None'</span>
    <span class="c1">// When a 'flatMap' is applied to an optional value and a closure (which returns</span>
    <span class="c1">// an optional value), 'ov flatMap f' will succeed if both 'ov' and 'f' return a</span>
    <span class="c1">// defined value, otherwise it returns 'None'</span>
    <span class="k">else</span> <span class="n">suffixes</span> <span class="n">get</span> <span class="o">(</span><span class="n">s</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="n">flatMap</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="n">s</span> <span class="n">substring</span> <span class="mi">1</span><span class="o">))</span>

  <span class="k">def</span> <span class="n">withPrefix</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="k">this</span>
    <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">leading</span> <span class="k">=</span> <span class="n">s</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
      <span class="n">suffixes</span> <span class="n">get</span> <span class="n">leading</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="n">suffixes</span> <span class="k">=</span> <span class="n">suffixes</span> <span class="o">+</span> <span class="o">(</span><span class="n">leading</span> <span class="o">-&gt;</span> <span class="n">empty</span><span class="o">)</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="o">}</span>
      <span class="n">suffixes</span><span class="o">(</span><span class="n">leading</span><span class="o">)</span> <span class="n">withPrefix</span> <span class="o">(</span><span class="n">s</span> <span class="n">substring</span> <span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">update</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span>
    <span class="c1">// first locates the key by calling 'withPrefix', creating submaps if not in tree</span>
    <span class="n">withPrefix</span><span class="o">(</span><span class="n">s</span><span class="o">).</span><span class="n">value</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">elem</span><span class="o">)</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">remove</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span>  <span class="c1">// similar to 'get', only it</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span> <span class="k">val</span> <span class="n">prev</span> <span class="k">=</span> <span class="n">value</span><span class="o">;</span> <span class="n">value</span> <span class="k">=</span> <span class="nc">None</span><span class="o">;</span> <span class="n">prev</span><span class="o">}</span>  <span class="c1">// first sets nodes to None</span>
    <span class="k">else</span> <span class="n">suffixes</span> <span class="n">get</span> <span class="o">(</span><span class="n">s</span><span class="o">(</span><span class="mi">0</span><span class="o">))</span> <span class="n">flatMap</span> <span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">remove</span><span class="o">(</span><span class="n">s</span> <span class="n">substring</span> <span class="mi">1</span><span class="o">))</span>

  <span class="c1">// returns iterator that yields all key-value pairs from the map</span>
  <span class="c1">// If the map contains a defined value, 'Some(x)', in the value field at its root,</span>
  <span class="c1">// then '("", x)' is the first element returned from the iterator</span>
  <span class="c1">// The iterator needs to traverse the iterators of all submaps stored in the suffixes</span>
  <span class="c1">// field, but it needs to add a character in front of every key string returned by</span>
  <span class="c1">// those iterators</span>
  <span class="c1">// If 'm' is the submap reached from the root through a character 'chr', and '(s, v)'</span>
  <span class="c1">// is an element returned from 'm.iterator', then the root’s iterator will return </span>
  <span class="c1">// '(chr +: s, v)' instead</span>
  <span class="k">def</span> <span class="n">iterator</span><span class="k">:</span> <span class="kt">Iterator</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">)]</span> <span class="k">=</span>
    <span class="c1">// 'Option' values define an iterator method that returns either no element, if the</span>
    <span class="c1">// option value is 'None', or exactly one element, 'x', if the option is 'Some(x)'</span>
    <span class="o">(</span><span class="k">for</span> <span class="o">(</span><span class="n">v</span> <span class="k">&lt;-</span> <span class="n">value</span><span class="o">.</span><span class="n">iterator</span><span class="o">)</span> <span class="k">yield</span> <span class="o">(</span><span class="s">""</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span> <span class="o">++</span>
    <span class="o">(</span><span class="k">for</span> <span class="o">((</span><span class="n">chr</span><span class="o">,</span> <span class="n">m</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">suffixes</span><span class="o">.</span><span class="n">iterator</span><span class="o">;</span>
        <span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="n">m</span><span class="o">.</span><span class="n">iterator</span><span class="o">)</span> <span class="k">yield</span> <span class="o">(</span><span class="n">chr</span> <span class="o">+:</span> <span class="n">s</span><span class="o">,</span> <span class="n">v</span><span class="o">))</span>

<span class="c1">// since maps and sets come with default builders, which are instances of 'MapBuilder',</span>
<span class="c1">// there's no need to implement the 'newBuilder' method</span>

  <span class="k">def</span> <span class="o">+=</span> <span class="o">(</span><span class="n">kv</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">T</span><span class="o">))</span><span class="k">:</span> <span class="kt">this.</span><span class="k">type</span> <span class="o">=</span> <span class="o">{</span> <span class="n">update</span><span class="o">(</span><span class="n">kv</span><span class="o">.</span><span class="n">_1</span><span class="o">,</span> <span class="n">kv</span><span class="o">.</span><span class="n">_2</span><span class="o">);</span> <span class="k">this</span> <span class="o">}</span>
  <span class="k">def</span> <span class="o">-=</span> <span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">this.</span><span class="k">type</span> <span class="o">=</span> <span class="o">{</span> <span class="n">remove</span><span class="o">(</span><span class="n">s</span><span class="o">);</span> <span class="k">this</span> <span class="o">}</span>

  <span class="c1">// to build the right kind of set or map, we need to start with an empty set or map of</span>
  <span class="c1">// this kind, thus the 'empty' method</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">emtpy</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>


<span class="k">import</span> <span class="nn">scala.collection.mutable.</span><span class="o">{</span><span class="nc">Builder</span><span class="o">,</span> <span class="nc">MapBuilder</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">scala.collection.generic.CanBuildFrom</span>

<span class="c1">// the main purpose of this object is to define some convenience factory methods</span>
<span class="c1">// and to define a 'CanBuildFrom' implicit to make typing work better</span>
<span class="k">object</span> <span class="nc">PrefixMap</span> <span class="k">extends</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">empty</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="c1">// methods 'empty' and 'apply' allow us to write 'PrefixMap' literals</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">kvs</span><span class="k">:</span> <span class="o">(</span><span class="kt">String</span><span class="o">,</span> <span class="kt">T</span><span class="o">)*)</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">m</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="n">empty</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">kv</span> <span class="k">&lt;-</span> <span class="n">kvs</span><span class="o">)</span> <span class="n">m</span> <span class="o">+=</span> <span class="n">kv</span>
    <span class="n">m</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">newBuilder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="k">:</span> <span class="kt">Builder</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">)</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">MapBuilder</span><span class="o">[</span><span class="kt">String</span>, <span class="kt">T</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]](</span><span class="n">empty</span><span class="o">)</span>

  <span class="c1">// makes methods like 'map' return best possible type</span>
  <span class="k">implicit</span> <span class="k">def</span> <span class="n">canBuildFrom</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span><span class="k">:</span> <span class="kt">CanBuildFrom</span><span class="o">[</span><span class="kt">PrefixMap</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">)</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span>
    <span class="k">new</span> <span class="nc">CanBuildFrom</span><span class="o">[</span><span class="kt">PrefixMap</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="o">(</span><span class="kt">String</span>, <span class="kt">T</span><span class="o">)</span>, <span class="kt">PrefixMap</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="o">{</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">from</span><span class="k">:</span> <span class="kt">PrefixMap</span><span class="o">[</span><span class="k">_</span><span class="o">])</span> <span class="k">=</span> <span class="n">newBuilder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
      <span class="k">def</span> <span class="n">apply</span><span class="o">()</span> <span class="k">=</span> <span class="n">newBuilder</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// made possible by methods 'empty' and 'apply':</span>
<span class="k">val</span> <span class="n">pm</span> <span class="k">=</span> <span class="nc">PrefixMap</span><span class="o">(</span><span class="s">"hello"</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">,</span> <span class="s">"hi"</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">)</span>  <span class="c1">// PrefixMap[Int] = Map((hello. 5), (hi, 2))</span>
<span class="k">val</span> <span class="n">epm</span> <span class="k">=</span> <span class="nc">PrefixMap</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>            <span class="c1">// PrefixMap[String] = Map()</span>

<span class="c1">// made possible by 'CanBuildFrom'</span>
<span class="c1">// consider mapping a function over the key-value pairs of a 'PrefixMap'</span>
<span class="c1">// as long as that function produces pairs of strings and some other type, the resulting</span>
<span class="c1">// collection will again be a 'PrefixMap'</span>
<span class="c1">// Without 'canBuildFrom' implicit, the result would have been a general mutable map:</span>
<span class="n">pm</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">k</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">k</span> <span class="o">+</span> <span class="s">"!"</span><span class="o">,</span> <span class="s">"x"</span> <span class="o">*</span> <span class="n">v</span><span class="o">)</span> <span class="o">}</span>
    <span class="c1">// PrefixMap[String] = Map((hello!, xxxxx), (hi!, xx))</span>
</pre></div>

<blockquote>
<ul>
<li>to summarize, if you want to fully integrate a new collection class into the collection framework, you need to pay attention to the following:

<ul>
<li>decide whether the collection should be mutable or immutable</li>
<li>pick the right traits for the collection</li>
<li>inherit from the right implementation trait to implement most collection operations</li>
<li>if you want <code>map</code> and similar operations to return instances of your collection type, provide an implicit <strong><code>CanBuildFrom</code></strong> in your class's companion object</li>
</ul>
</li>
</ul>
</blockquote>

<h2>
<a name="extractors" class="anchor" href="#extractors"><span class="octicon octicon-link"></span></a>Extractors</h2>

<blockquote>
<ul>
<li>until now, constructor patterns were linked to <em>case classes</em>, but sometimes you might want to write patterns like this without creating an associated case class, moreover, you may wish to be able to create your own kinds of patterns that are decoupled from an object's representation. Enter <strong>extractors</strong>
</li>
</ul>
</blockquote>

<h3>
<a name="631---an-example-extracting-email-address" class="anchor" href="#631---an-example-extracting-email-address"><span class="octicon octicon-link"></span></a><strong>631 - An example: extracting email address</strong>
</h3>

<div class="highlight highlight-scala"><pre><span class="c1">// given a string, we want to decide whether it's an email address, and it it is</span>
<span class="c1">// we want to extract user and domain parts of the address</span>
<span class="c1">// the traditional way:</span>
<span class="k">def</span> <span class="n">isEMail</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
<span class="k">def</span> <span class="n">domain</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>
<span class="k">def</span> <span class="n">user</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span>

<span class="c1">// and then:</span>
<span class="k">if</span> <span class="o">(</span><span class="n">isEMail</span><span class="o">(</span><span class="n">s</span><span class="o">))</span> <span class="n">println</span><span class="o">(</span><span class="n">user</span><span class="o">(</span><span class="n">s</span><span class="o">)</span> <span class="o">+</span> <span class="s">" AT "</span> <span class="o">+</span> <span class="n">domain</span><span class="o">(</span><span class="n">s</span><span class="o">))</span>
<span class="k">else</span> <span class="n">println</span><span class="o">(</span><span class="s">"wtf?"</span><span class="o">)</span>

<span class="c1">// lets assume that we could match a string with a pattern:</span>
<span class="nc">EMail</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span>
<span class="c1">// the pattern would match if the string contained an embedded '@' sign, in which case</span>
<span class="c1">// it would bind variable 'user' to the part of the string before it, and variable</span>
<span class="c1">// 'domain' to the part after it</span>

<span class="c1">// the previous expression could be written more clearly like this:</span>
<span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">user</span> <span class="o">+</span> <span class="s">" AT "</span> <span class="o">+</span> <span class="n">domain</span><span class="o">)</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"wtf?"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// to find two successive emails with the same user part:</span>
<span class="n">ss</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">u1</span><span class="o">,</span> <span class="n">d1</span><span class="o">)</span> <span class="o">::</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">u2</span><span class="o">,</span> <span class="n">d2</span><span class="o">)</span> <span class="o">::</span> <span class="k">_</span> <span class="k">if</span> <span class="o">(</span><span class="n">u1</span> <span class="o">==</span> <span class="n">u2</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="o">...</span>
<span class="o">}</span>
</pre></div>

<h3>
<a name="632---extractors" class="anchor" href="#632---extractors"><span class="octicon octicon-link"></span></a><strong>632 - Extractors</strong>
</h3>

<blockquote>
<ul>
<li>an <strong>extractor</strong> is an object that has a method called <code>unapply</code> as one of it members (whose purpose is to match a value and take it apart)</li>
<li>often times, the extractor object also defines a dual method <code>apply</code> for building values, but that's not required</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// extractor object for e-mail addresses:</span>
<span class="k">object</span> <span class="nc">EMail</span> <span class="o">{</span>
  <span class="c1">// the injection method (optional)</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">user</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">domain</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">user</span> <span class="o">+</span> <span class="s">"@"</span> <span class="o">+</span> <span class="n">domain</span>

  <span class="c1">// the extraction method (mandatory)</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">str</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">String</span><span class="o">)]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="c1">// returns option type over pair of strings, since it must handle the case where</span>
    <span class="c1">// received param is not an email address</span>
    <span class="k">val</span> <span class="n">parts</span> <span class="k">=</span> <span class="n">str</span> <span class="n">split</span> <span class="s">"@"</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">parts</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span> <span class="nc">Some</span><span class="o">(</span><span class="n">parts</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">parts</span><span class="o">(</span><span class="mi">1</span><span class="o">))</span> <span class="k">else</span> <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 'apply' is used to turn EMail into an object that can be applied to arguments in</span>
<span class="c1">// parentheses in the same way a method is applied, so you can write:</span>
<span class="nc">EMail</span><span class="o">(</span><span class="s">"John"</span><span class="o">,</span> <span class="s">"epfl.ch"</span><span class="o">)</span> <span class="c1">// to construct the string "John@epfl.ch"</span>

<span class="c1">// to make this more explicit, we could also let 'EMail' inherit from function type:</span>
<span class="k">object</span> <span class="nc">EMail</span> <span class="k">extends</span> <span class="o">((</span><span class="nc">String</span><span class="o">,</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">String</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>

<span class="c1">// '(String, String) =&gt; String' is the same as 'Function2[String, String, String]',</span>
<span class="c1">// which declares an abstract 'apply' method that 'EMail' implements</span>
<span class="c1">// As a result of this inheritance declaration, we could pass 'EMail' to a method</span>
<span class="c1">// that expects a 'Function[String, String, String]'</span>

<span class="n">unapply</span><span class="o">(</span><span class="s">"John@epfl.ch"</span><span class="o">)</span> <span class="-Symbol">'equals</span><span class="err">'</span> <span class="nc">Some</span><span class="o">(</span><span class="s">"John"</span><span class="o">,</span> <span class="s">"epfl.ch"</span><span class="o">)</span>
<span class="n">unapply</span><span class="o">(</span><span class="s">"John Doe"</span><span class="o">)</span> <span class="-Symbol">'equals</span><span class="err">'</span> <span class="nc">None</span>
<span class="c1">// a side note: when passing a tuple to a function that takes a single argument, we</span>
<span class="c1">// can leave off one pair of parentheses, so instead of 'Some((user, domain))' we</span>
<span class="c1">// can write 'Some(user, domain)'</span>

<span class="c1">// whenever pattern matching encounters a pattern referring to an extractor object,</span>
<span class="c1">// it invokes  the extractor's 'unapply' method on the selector expression:</span>
<span class="n">selectorString</span> <span class="k">match</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="o">}</span>
<span class="c1">// will be turned into the call:</span>
<span class="nc">EMail</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">selectorString</span><span class="o">)</span>  <span class="c1">// which returns either 'None' or 'Some(u, d)'</span>

<span class="c1">// in the 'None' case, the pattern doesn't match and the system tries another pattern</span>
<span class="c1">// or fails with a 'MatchError' exception</span>


<span class="c1">// in the previous example, 'selectorString' matched the argument type of 'unapply', but</span>
<span class="c1">// that is not necessary and it would also be possible to use the 'EMail' extractor</span>
<span class="c1">// to match selector expressions for more general types:</span>
<span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Any</span> <span class="o">=</span> <span class="o">...</span>
<span class="n">x</span> <span class="k">match</span> <span class="o">{</span> <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="o">}</span>

<span class="c1">// here, the pattern matcher will first check whether the given value 'x' conforms to </span>
<span class="c1">// 'String', the parameter type of 'unapply' method, and if it does, the value is cast</span>
<span class="c1">// to 'String' and pattern matching proceeds as normal</span>
<span class="c1">// If it doesn't conform, the pattern fails immediately</span>
</pre></div>

<blockquote>
<ul>
<li>in object <code>EMail</code>, the <code>apply</code> method is called <strong>injection</strong>, because it takes some arguments and yields an element of a given set (a set of strings that are email addresses, in this case)</li>
<li>the <code>unapply</code> method is called <strong>extraction</strong>, because it takes an element of the same set and extracts some of its parts (the user and domain substrings, in this case)</li>
<li>
<em>injection</em> and <em>extraction</em> are often grouped together in one object, because then you can use the object's name for both a constructor and a pattern, which simulates the convention for pattern matching with case classes</li>
<li>it is also possible to define an extraction in an object without a corresponding injection, when the object itself is called an <strong>extractor</strong>, regardless of whether or not it has an <code>apply</code> method</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// if an injection method is included, it should be dual to the extraction method</span>
<span class="c1">// e.g. a call to:</span>
<span class="nc">EMail</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="nc">EMail</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">))</span>
<span class="c1">// should return</span>
<span class="nc">Some</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">domain</span><span class="o">)</span>
<span class="c1">// going in the other direction means running first the 'unapply' and then 'apply':</span>
<span class="nc">EMail</span><span class="o">.</span><span class="n">unapply</span><span class="o">(</span><span class="n">obj</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">EMail</span><span class="o">.</span><span class="n">apply</span><span class="o">(</span><span class="n">u</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// where, if the match on 'obj' succeeds, we expect to get back that same object from</span>
<span class="c1">// the 'apply'</span>
</pre></div>

<blockquote>
<ul>
<li>the duality of <code>apply</code> and <code>unapply</code> is a good design principle, which is not enforced by Scala, of course, but it's recommended when designing extractors</li>
</ul>
</blockquote>

<h3>
<a name="635---patterns-with-zero-or-one-variable" class="anchor" href="#635---patterns-with-zero-or-one-variable"><span class="octicon octicon-link"></span></a><strong>635 - Patterns with zero or one variable</strong>
</h3>

<blockquote>
<ul>
<li>to bind <code>n</code> variables, <code>unapply</code> returns an <em>N-element tuple</em> wrapped in a <code>Some</code>
</li>
<li>the case when a pattern binds just one variable is treated differently, since there's no one-tuple in Scala, so to return just one pattern element, the <code>unapply</code> method simply wraps the element itself in a <code>Some</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// extractor object for strings that consist of a substring appearing twice in a row </span>
<span class="k">object</span> <span class="nc">Twice</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">s</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">length</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">val</span> <span class="n">half</span> <span class="k">=</span> <span class="n">s</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">length</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">half</span> <span class="o">==</span> <span class="n">s</span><span class="o">.</span><span class="n">substring</span><span class="o">(</span><span class="n">length</span><span class="o">))</span> <span class="nc">Some</span><span class="o">(</span><span class="n">half</span><span class="o">)</span> <span class="k">else</span> <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>it is also possible that an extractor pattern does not bind any variables, in which case the corresponding <code>unapply</code> returns a boolean, <code>true</code> for success and <code>false</code> for failure:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// extractor object that characterizes strings consisting of all uppercase letters:</span>
<span class="k">object</span> <span class="nc">UpperCase</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">unapply</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">toUpperCase</span> <span class="o">==</span> <span class="n">s</span>
  <span class="c1">// it would make no sense to define 'apply', because there's nothing to construct</span>
<span class="o">}</span>

<span class="c1">// function that applies all previously defined extractors:</span>
<span class="k">def</span> <span class="n">userTwiceUpper</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="nc">Twice</span><span class="o">(</span><span class="n">x</span> <span class="k">@</span> <span class="nc">UpperCase</span><span class="o">()),</span> <span class="n">domain</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="s">"match: "</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="s">" in domain "</span> <span class="o">+</span> <span class="n">domain</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"no match"</span>
  <span class="c1">// UpperCase is written with parentheses since without them, the match would test for</span>
  <span class="c1">// equality with the object 'UpperCase'</span>
  <span class="c1">// 'x @ UpperCase()' associates variable 'x' with the pattern matched by 'UpperCase()'</span>
<span class="o">}</span>

<span class="n">userTwiceUpper</span><span class="o">(</span><span class="s">"CANCAN@gmail.com"</span><span class="o">)</span>  <span class="c1">// match: CAN in domain gmail.com</span>
<span class="n">userTwiceUpper</span><span class="o">(</span><span class="s">"CANCAM@gmail.com"</span><span class="o">)</span>  <span class="c1">// no match</span>
<span class="n">userTwiceUpper</span><span class="o">(</span><span class="s">"cancan@gmail.com"</span><span class="o">)</span>  <span class="c1">// no match</span>
</pre></div>

<h3>
<a name="637---variable-argument-extractors" class="anchor" href="#637---variable-argument-extractors"><span class="octicon octicon-link"></span></a><strong>637 - Variable argument extractors</strong>
</h3>

<blockquote>
<ul>
<li>if you don't know the number of element values in advance, the previous method is not flexible enough</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// match on a string representing domain name and extract all domain parts</span>
<span class="c1">// in the end, we should be able to use it like this:</span>
<span class="n">dom</span> <span class="k">match</span> <span class="o">{</span>  <span class="c1">// domains are in reverse order so it better fits sequence patterns</span>
  <span class="k">case</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">"org"</span><span class="o">,</span> <span class="s">"acm"</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"acm.org"</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">"com"</span><span class="o">,</span> <span class="s">"sun"</span><span class="o">,</span> <span class="s">"java"</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"java.sun.com"</span><span class="o">)</span>
  <span class="k">case</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">"net"</span><span class="o">,</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"a .net domain"</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// a sequence wildcard pattern '_*', at the end of an argument list matches any remaining</span>
<span class="c1">// elements in a sequence, which is more useful if top level domains come first</span>
<span class="c1">// because then we can use wildcard to match sub-domains of arbitrary length</span>
</pre></div>

<blockquote>
<ul>
<li>the question of supporting <em>vararg matching</em> remains, since the <code>unapply</code> methods are not sufficient, because they return a fixed number of sub-elements in the success case</li>
<li>to handle this case, Scala lets you define a different extraction method, specifically for <em>vararg</em> matching, which is called <code>unapplySeq</code>
</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">object</span> <span class="nc">Domain</span> <span class="o">{</span>
  <span class="c1">// the injection (optional)</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">(</span><span class="n">parts</span><span class="k">:</span> <span class="kt">String*</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
    <span class="n">parts</span><span class="o">.</span><span class="n">reverse</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">"."</span><span class="o">)</span>

  <span class="c1">// the extraction (mandatory)</span>
  <span class="c1">// first splits on periods, then reverses and wraps in 'Some'</span>
  <span class="k">def</span> <span class="n">unapplySeq</span><span class="o">(</span><span class="n">whole</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span>  <span class="c1">// must return 'Option[Seq[T]]'</span>
    <span class="nc">Some</span><span class="o">(</span><span class="n">whole</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">"\\."</span><span class="o">).</span><span class="n">reverse</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// to search for an email address "luka.bonaci" in some ".hr" domain:</span>
<span class="k">def</span> <span class="n">isLukaBonaciInDotHr</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="n">s</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="nc">EMail</span><span class="o">(</span><span class="s">"luka.bonaci"</span><span class="o">,</span> <span class="nc">Domain</span><span class="o">(</span><span class="s">"hr"</span><span class="o">,</span> <span class="k">_</span><span class="o">*))</span> <span class="k">=&gt;</span> <span class="kc">true</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="c1">// it's also possible to return some fixed elements from 'unapplySeq', together with the</span>
<span class="c1">// variable part, which is expressed by returning all elements in a tuple, where the</span>
<span class="c1">// variable part comes last, as usual</span>
<span class="c1">// e.g. extractor for emails where the domain part is already expanded into sequence:</span>
<span class="k">object</span> <span class="nc">ExpandedEMail</span> <span class="o">{</span>
  <span class="c1">// returns optional value of a pair (Tuple2), where the first part is the user, and </span>
  <span class="c1">// the second part is a sequence of names representing the domain</span>
  <span class="k">def</span> <span class="n">unapplySeq</span><span class="o">(</span><span class="n">email</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[(</span><span class="kt">String</span>, <span class="kt">Seq</span><span class="o">[</span><span class="kt">String</span><span class="o">])]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">parts</span> <span class="k">=</span> <span class="n">email</span> <span class="n">split</span> <span class="s">"@"</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">parts</span><span class="o">.</span><span class="n">length</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
      <span class="nc">Some</span><span class="o">(</span><span class="n">parts</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="n">parts</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">split</span><span class="o">(</span><span class="s">"\\."</span><span class="o">).</span><span class="n">reverse</span><span class="o">)</span>
    <span class="k">else</span>
      <span class="nc">None</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">val</span> <span class="n">s</span> <span class="k">=</span> <span class="s">"luka@support.epfl.hr"</span>
<span class="k">val</span> <span class="nc">ExpandedEMail</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">topdom</span><span class="o">,</span> <span class="n">subdoms</span> <span class="k">@</span> <span class="k">_</span><span class="o">*)</span> <span class="k">=</span> <span class="n">s</span>
<span class="c1">// name: String = luka</span>
<span class="c1">// topdom: String = hr</span>
<span class="c1">// subdoms: Seq[String] = WrappedArray(epfl, support)</span>
</pre></div>

<h3>
<a name="640---extractors-and-sequence-patterns" class="anchor" href="#640---extractors-and-sequence-patterns"><span class="octicon octicon-link"></span></a><strong>640 - Extractors and sequence patterns</strong>
</h3>

<blockquote>
<ul>
<li>sequence patterns, such as <code>List()</code>, <code>List(x, y, _*)</code>, <code>Array(x, 0, _)</code> are implemented using extractors in the standard Scala library. E.g. patterns of the form <code>List(...)</code> are possible because the <code>scala.List</code> companion object is an extractor that defines <code>unapplySeq</code> method:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// 'List' companion object (similar for 'Array')</span>
<span class="k">package</span> <span class="nn">scala</span>
<span class="k">object</span> <span class="nc">List</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">apply</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">elems</span><span class="k">:</span> <span class="kt">T*</span><span class="o">)</span> <span class="k">=</span> <span class="n">elems</span><span class="o">.</span><span class="n">toList</span>  <span class="c1">// lets you write e.g. 'List(1, 2)' or 'List()'</span>
  <span class="c1">// returns all elements as a sequence</span>
  <span class="k">def</span> <span class="n">unapplySeq</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">x</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Set</span><span class="o">[</span><span class="kt">T</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="n">x</span><span class="o">)</span>
<span class="o">}</span>
</pre></div>

<h3>
<a name="641---extractors-versus-case-classes" class="anchor" href="#641---extractors-versus-case-classes"><span class="octicon octicon-link"></span></a><strong>641 - Extractors versus case classes</strong>
</h3>

<blockquote>
<ul>
<li>even though case classes are very useful, they have a shortcoming of exposing the concrete representation of data, because the name of the class in a constructor pattern corresponds to the concrete representation type of the selector object</li>
<li>if a match against <code>case C(...)</code> succeeds, you know that the selector expression is an instance of class <code>C</code>
</li>
<li>extractors break this link between data representation and patterns, by allowing patterns that have nothing to do with the data type the the object that's matched against</li>
<li>this property is called <strong>representation independence</strong>, and it is known to be very important in open systems of large scale, because it allows you to change an implementation type used in a set of components without affecting clients of these components</li>
<li>on the other hand, case classes have their advantages over extractors

<ul>
<li>case classes are much easier to set up and define, thus requiring less code</li>
<li>they usually lead to more efficient pattern matches than extractors, because compiler can optimize patterns over case classes much better than those over extractors, because the mechanisms of case classes are fixed, whereas an <code>unapply</code> or <code>unapplySeq</code> in an extractor could do almost anything</li>
<li>if your case classes inherit from a <code>sealed</code> base class, the compiler will check your pattern matches for exhaustiveness and will complain if some combination of possible values is not covered by a set of patterns, which is not available with extractors</li>
</ul>
</li>
<li>if you're writing a closed application, you should prefer case classes, but if you need to expose an API to clients, extractors might be preferable</li>
</ul>
</blockquote>

<h3>
<a name="642---regular-expressions" class="anchor" href="#642---regular-expressions"><span class="octicon octicon-link"></span></a><strong>642 - Regular expressions</strong>
</h3>

<blockquote>
<ul>
<li>a particularly useful application area of extractors, since they make it much nicer to interact with regular expressions library <code>scala.util.matching</code>
</li>
</ul>
</blockquote>

<p><em>Forming regular expressions</em></p>

<blockquote>
<ul>
<li>Scala inherits its regex syntax from Java, which in turn inherits it from Perl</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">import</span> <span class="nn">scala.util.matching.Regex</span>
<span class="k">val</span> <span class="nc">Decimal</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Regex</span><span class="o">(</span><span class="s">"(-)?(\\d+)(\\.\\d*)?"</span><span class="o">)</span>  <span class="c1">// Regex = (-)?(\d+)(\.\d*)?</span>

<span class="c1">// like in Java, we need to escape backslashes, which can be painful to write and read</span>
<span class="c1">// Scala provides raw strings to help with that</span>
<span class="c1">// the difference between raw and normal string is that all characters in a raw string</span>
<span class="c1">// appear exactly as they are typed, so we can write:</span>
<span class="k">val</span> <span class="nc">Decimal</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Regex</span><span class="o">(</span><span class="s">"""(-)?(\d+)(\.\d*)?"""</span><span class="o">)</span> <span class="c1">// Regex = (-)?(\d+)(\.\d*)?</span>

<span class="c1">// another, even shorter way:</span>
<span class="k">val</span> <span class="nc">Decimal</span> <span class="k">=</span> <span class="s">"""(-)?(\d+)(\.\d*)?"""</span><span class="o">.</span><span class="n">r</span>          <span class="c1">// Regex = (-)?(\d+)(\.\d*)?</span>

<span class="c1">// appending '.r' to a string creates regular expression (method of 'StringOps')</span>
</pre></div>

<p><em>Searching for regular expressions</em></p>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">input</span> <span class="k">=</span> <span class="s">"for -1.0 to 99 by 3"</span>
<span class="k">for</span> <span class="o">(</span><span class="n">s</span> <span class="k">&lt;-</span> <span class="nc">Decimal</span> <span class="n">findAllIn</span> <span class="n">input</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="n">s</span> <span class="o">+</span> <span class="s">"   "</span><span class="o">)</span>        <span class="c1">// -1.0   99   3   </span>

<span class="nc">Decimal</span> <span class="n">findFirstIn</span> <span class="n">input</span>   <span class="c1">// Option[String] = Some(-1.0)</span>
<span class="nc">Decimal</span> <span class="n">findPrefixOf</span> <span class="n">input</span>  <span class="c1">// Option[String] = None  (must be at the start of a string)</span>
</pre></div>

<p><em>Extracting with regular expressions</em></p>

<blockquote>
<ul>
<li>every regex defines an extractor, which is used to identify substrings that are matched by the groups of the regular expression:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// we could decompose a decimal number like this:</span>
<span class="k">val</span> <span class="nc">Decimal</span><span class="o">(</span><span class="n">sign</span><span class="o">,</span> <span class="n">integerpart</span><span class="o">,</span> <span class="n">decimalpart</span><span class="o">)</span> <span class="k">=</span> <span class="s">"-1.23"</span>
<span class="c1">// sign: String = -</span>
<span class="c1">// integerpart: String = 1</span>
<span class="c1">// decimalpart: String = .23</span>

<span class="c1">// the 'Decimal' regex value defines 'unapplySeq', which matches every string that</span>
<span class="c1">// corresponds to the regex syntax for decimal numbers</span>
<span class="c1">// If the string matches, the parts that correspond to the 3 groups in the regex</span>
<span class="c1">// are returned as elements of the pattern and are then matched by the 3 pattern</span>
<span class="c1">// variables 'sign', 'integerpart' and 'decimalpart'</span>
<span class="c1">// If a group is missing, the element value is set to 'null':</span>
<span class="k">val</span> <span class="nc">Decimal</span><span class="o">(</span><span class="n">sign</span><span class="o">,</span> <span class="n">integerpart</span><span class="o">,</span> <span class="n">decimalpart</span><span class="o">)</span> <span class="k">=</span> <span class="s">"1.0"</span>
<span class="c1">// sign: String = null      integerpart = 1      decimalpart = .0</span>

<span class="c1">// it is also possible to mix extractors with regular expression searches in a for</span>
<span class="c1">// expression:</span>
<span class="k">for</span> <span class="o">(</span><span class="nc">Decimal</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">&lt;-</span> <span class="nc">Decimal</span> <span class="n">findAllIn</span> <span class="n">input</span><span class="o">)</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"sign: "</span> <span class="o">+</span> <span class="n">s</span> <span class="o">+</span> <span class="s">", integer: "</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="s">", decimal: "</span> <span class="o">+</span> <span class="n">d</span><span class="o">)</span>
</pre></div>

<h2>
<a name="annotations" class="anchor" href="#annotations"><span class="octicon octicon-link"></span></a>Annotations</h2>

<blockquote>
<ul>
<li>structured information added to program source code</li>
<li>not valid Scala expressions</li>
<li>may be added to any variable, method, expression, or other program element</li>
</ul>
</blockquote>

<h3>
<a name="647---why-have-annotations" class="anchor" href="#647---why-have-annotations"><span class="octicon octicon-link"></span></a><strong>647 - Why have annotations?</strong>
</h3>

<blockquote>
<ul>
<li>a <strong>meta-programming</strong> tool (program that take other programs as input)</li>
<li>the compiler understands just one feature, annotations, but it doesn't attach any meaning to individual annotations</li>
<li>example use cases:

<ul>
<li>a documentation generator instructed to document certain methods as deprecated</li>
<li>a pretty printer instructed to skip over parts of the program that have been carefully hand formatted</li>
<li>a checker for non-closed files instructed to ignore a particular file that has been manually verified to be closed</li>
<li>a side-effects checker instructed to verify that a specified method has no side effects</li>
</ul>
</li>
</ul>
</blockquote>

<h3>
<a name="648---syntax-of-annotations" class="anchor" href="#648---syntax-of-annotations"><span class="octicon octicon-link"></span></a><strong>648 - Syntax of annotations</strong>
</h3>

<blockquote>
<ul>
<li>a typical use of an annotation looks like this:<br>
</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="nd">@deprecated</span> <span class="k">def</span> <span class="n">bigMistake</span><span class="o">()</span> <span class="k">=</span> <span class="c1">// ... applies to the entirety of the 'bigMistake' method</span>

<span class="nd">@deprecated</span> <span class="k">class</span> <span class="nc">QuickAndDirty</span> <span class="o">{</span> <span class="cm">/*...*/</span> <span class="o">}</span>

<span class="o">(</span><span class="n">e</span><span class="k">:</span> <span class="kt">@unchecked</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>  <span class="c1">// applied to expressions</span>
  <span class="c1">// non-exhaustive cases...</span>
<span class="o">}</span>

<span class="c1">// annotations have a richer general form:</span>
<span class="nd">@annot</span><span class="o">(</span><span class="n">exp1</span><span class="o">,</span> <span class="n">exp2</span><span class="o">,</span> <span class="o">...)</span>  <span class="c1">// parentheses are optional if annotation has no arguments</span>
<span class="c1">// where 'annot' specifies the class of annotation</span>

<span class="c1">// the precise form of the arguments you may give to annotation depends on the particular</span>
<span class="c1">// annotation class (compiler supports arbitrary expressions, as long as they type check)</span>

<span class="c1">// some annotation classes can make use of this, e.g. to let you refer to a variable:</span>
<span class="nd">@cool</span> <span class="k">val</span> <span class="n">normal</span> <span class="k">=</span> <span class="s">"Hello"</span>
<span class="nd">@coolerThan</span><span class="o">(</span><span class="n">normal</span><span class="o">)</span> <span class="k">val</span> <span class="n">fonzy</span> <span class="k">=</span> <span class="s">"Hot"</span>
</pre></div>

<blockquote>
<ul>
<li>internally, Scala represents an annotation as just a constructor call of an annotation class (replace <code>@</code> with <code>new</code> and you have a valid instance creation expr.)</li>
<li>a somewhat tricky bit concerns annotations that take other annotations as arguments</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// we cannot write an annotation directly as an argument to an annotation, because they</span>
<span class="c1">// are not valid expressions</span>
<span class="c1">// in such cases we must use 'new' instead of '@':</span>
<span class="k">import</span> <span class="nn">annotation._</span>
<span class="k">class</span> <span class="nc">strategy</span><span class="o">(</span><span class="n">arg</span><span class="k">:</span> <span class="kt">Annotation</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Annotation</span>
<span class="k">class</span> <span class="nc">delayed</span> <span class="k">extends</span> <span class="nc">Annotation</span>

<span class="nd">@strategy</span><span class="o">(</span><span class="nd">@delayed</span><span class="o">)</span> <span class="k">def</span> <span class="n">f</span><span class="o">(){}</span>     <span class="c1">// error: illegal start of simple expression</span>

<span class="nd">@strategy</span><span class="o">(</span><span class="k">new</span> <span class="n">delayed</span><span class="o">)</span> <span class="k">def</span> <span class="n">f</span><span class="o">(){}</span>  <span class="c1">// f: ()Unit</span>
</pre></div>

<h3>
<a name="650---standard-annotations" class="anchor" href="#650---standard-annotations"><span class="octicon octicon-link"></span></a><strong>650 - Standard annotations</strong>
</h3>

<blockquote>
<ul>
<li>introduced for features that are used widely enough to alter the language specification, yet not fundamental enough to merit their own syntax<br>
</li>
</ul>
</blockquote>

<p><em>Deprecation</em></p>

<blockquote>
<ul>
<li>used when there's a need to purge some classes or methods from the specification</li>
<li>lets us gracefully remove a method or a class that turns out to be a mistake</li>
<li>since we cannot simply delete a language element, because clients' code might stop working, we mark a class or a method as deprecated, by simply writing <strong><code>@deprecated</code></strong> before its declaration</li>
<li>such an annotation will cause the compiler to emit deprecation warning whenever Scala code accesses the language element</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="nd">@deprecated</span> <span class="k">def</span> <span class="n">bigMistake</span><span class="o">()</span> <span class="k">=</span> <span class="c1">// ...</span>

<span class="c1">// if you provide a string as an argument, that string will be emitted along with warning</span>
<span class="nd">@deprecated</span><span class="o">(</span><span class="s">"use newShinyMethod() instead"</span><span class="o">)</span>
<span class="k">def</span> <span class="n">bigMistake</span><span class="o">()</span> <span class="k">=</span> <span class="c1">// ...</span>

<span class="c1">// now, any caller will get a message like this:</span>
<span class="nc">$scalac</span> <span class="o">-</span><span class="n">deprecation</span> <span class="nc">Deprecation2</span><span class="o">.</span><span class="n">scala</span>
<span class="c1">// Deprecation2.scala:33: warning: method bigMistake in object Deprecation2 is</span>
<span class="c1">// deprecated: use newShinyMethod() instead</span>
<span class="c1">//     bigMistake()</span>
<span class="c1">//     ^</span>
<span class="c1">// one warning found</span>
</pre></div>

<p><em>Volatile fields</em></p>

<blockquote>
<ul>
<li>concurrent programming does not mix well with shared mutable state, and for this reason, the focus of Scala's concurrency support is message passing and a minimum of shared mutable state</li>
<li>the <code>@volatile</code> annotation helps in cases when developers use mutable state in their concurrent programs</li>
<li>it informs the compiler that a variable will be used by multiple threads</li>
<li>such variables are implemented so that reads and writes of the variable value is slower, but accesses from multiple threads behave more predictably</li>
<li>we get the same behavior as if we marked the variable with <strong><code>volatile</code></strong> modifier in Java</li>
</ul>
</blockquote>

<p><em>Binary serialization</em></p>

<blockquote>
<ul>
<li>a serialization framework lets us convert objects into streams of bytes and vice versa, which is useful if we want to save objects to disk or transfer over network</li>
<li>Scala doesn't have its own serialization framework, instead, you should use a framework of the underlying platform</li>
<li>Scala provides 3 annotations that are useful for a variety of frameworks, and also the compiler interprets these annotations in the Java way</li>
<li>
<strong><code>@serializable</code></strong> marks a class as serializable (all classes are considered non serializable by default)</li>
<li>
<strong><code>@SerialVersionUID(n)</code></strong> helps to deal with serializable classes future changes, by providing a serial number to a class version, which the framework stores in the generated byte stream. Later, when we reload that byte stream and try to convert it to an object, the framework checks that the current version of the class has the same version number as the version in the byte stream. If not, the framework refuses to load the old instances of the class. So, if you want to make a serialization-incompatible changes to the class, change the version number</li>
<li>**<code>@transient</code>** works the same as Java <code>transient</code> field modifier (field is excluded from serialization when its parent object is serialized)</li>
</ul>
</blockquote>

<p><em>Automatic <code>get</code> and <code>set</code> methods</em></p>

<blockquote>
<ul>
<li>Scala code normally doesn't need explicit getters and setters for fields, because Scala blends the calling syntax for field access and method invocation</li>
<li>because some platform-specific frameworks do expect get and set methods, Scala provides <strong><code>@scala.reflect.BeanProperty</code></strong> annotation, which tells the compiler to automatically generate getters and setters </li>
<li>it conforms to Java Bean standard, which means that a field named <code>crazy</code> will be supplemented with <code>getCrazy</code> and <code>setCrazy</code>, which will be available only after the compilation passes (so you cannot compile code that uses those methods in that same pass)</li>
</ul>
</blockquote>

<p><em>Tailrec</em></p>

<blockquote>
<ul>
<li>annotation <strong><code>@tailrec</code></strong> is added to a method that needs to be tail recursive (e.g. if you expect that, without tail recursion optimization, it would recurse very deep)</li>
<li>it is used to make sure that the compiler will perform tail recursion optimization</li>
<li>if the optimization cannot be performed, you will get a warning with an explanation</li>
</ul>
</blockquote>

<p><em>Unchecked</em></p>

<blockquote>
<ul>
<li>
<strong><code>@unchecked</code></strong> is interpreted by the compiler during pattern matching, and it tells the compiler not to worry if the match expression left out some cases</li>
</ul>
</blockquote>

<p><em>Native methods</em></p>

<blockquote>
<ul>
<li>
<strong><code>@native</code></strong> informs the compiler that a method's implementation is supplied by the runtime rather than the Scala code</li>
<li>compiler then toggles the appropriate flags in the output, and it leaves out to the developer to supply the implementation using a mechanism such as <em>Java Native Interface</em> (JNI)</li>
<li>when using this annotation, a method body must be supplied, but it will not be emitted into the output:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="nd">@native</span> <span class="k">def</span> <span class="n">beginCountDown</span><span class="o">()</span> <span class="o">{}</span>
</pre></div>

<h2>
<a name="working-with-xml" class="anchor" href="#working-with-xml"><span class="octicon octicon-link"></span></a>Working with XML</h2>

<h3>
<a name="657---xml-literals" class="anchor" href="#657---xml-literals"><span class="octicon octicon-link"></span></a><strong>657 - XML literals</strong>
</h3>

<blockquote>
<ul>
<li>Scala lets you type in XML as a literal, anywhere that en expression is valid:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span>
         <span class="nc">This</span> <span class="n">is</span> <span class="n">old</span> <span class="n">stuff</span><span class="o">.</span>
         <span class="nc">Who</span> <span class="n">needs</span> <span class="nc">XML</span> <span class="n">any</span> <span class="n">more</span><span class="o">?</span> <span class="o">&lt;</span><span class="n">exclamation</span><span class="o">/&gt;</span>
       <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="c1">// res0: scala.xml.Elem = </span>
<span class="c1">// &lt;a&gt;</span>
<span class="c1">//   This is old stuff.</span>
<span class="c1">//   Who needs XML any more? &lt;exclamation&gt;&lt;/exclamation&gt;</span>
<span class="c1">// &lt;/a&gt;</span>
</pre></div>

<blockquote>
<ul>
<li>the usual XML suspects:

<ul>
<li>class <code>Elem</code> represents an XML element</li>
<li>class <code>Node</code> is the abstract superclass of all XML node classes</li>
<li>class <code>Text</code> is a node holding just unstructured text, from withing a tag</li>
<li>class <code>NodeSeq</code> holds a sequence of nodes. Many methods in the XML library process node sequences in places you might expect them to process individual nodes (since <code>Node</code> extends <code>NodeSeq</code>, you can use those methods on individual nodes. You can think of an individual node as a one-element node sequence)</li>
</ul>
</li>
<li>code can be evaluated in the middle of an XML literal, by using curly braces:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;{</span><span class="s">"hello"</span> <span class="o">+</span> <span class="s">", world"</span><span class="o">}&lt;/</span><span class="n">a</span><span class="o">&gt;</span>  <span class="c1">// scala.xml.Elem = &lt;a&gt;hello, world&lt;/a&gt;</span>

<span class="c1">// braces can include arbitrary Scala content, e.g. including further XML literals:</span>
<span class="k">val</span> <span class="n">yearMade</span> <span class="k">=</span> <span class="mi">1955</span>  <span class="c1">// Int = 1955</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;{</span> <span class="k">if</span> <span class="o">(</span><span class="n">yearMade</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="o">)</span> <span class="o">&lt;</span><span class="n">old</span><span class="o">&gt;{</span><span class="n">yearMade</span><span class="o">}&lt;/</span><span class="n">old</span><span class="o">&gt;</span>
     <span class="k">else</span> <span class="n">xml</span><span class="o">.</span><span class="nc">NodeSeq</span><span class="o">.</span><span class="nc">Empty</span> <span class="o">}</span>
<span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="c1">// scala.xml.Elem = &lt;a&gt; &lt;old&gt;1955&lt;/old&gt; &lt;/a&gt;</span>

<span class="c1">// if an expression inside a braces does not evaluate to an XML node (may evaluate to </span>
<span class="c1">// any Scala value), the result is converted to a string and inserted as a text node:</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;{</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="o">}&lt;/</span><span class="n">a</span><span class="o">&gt;</span>  <span class="c1">// scala.xml.Elem = &lt;a&gt;7&lt;/a&gt;</span>

<span class="c1">// any '&lt;', '&gt;' and '&amp;' characters in the text will be escaped:</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;{</span><span class="s">"&lt;/a&gt;potential security hole&lt;a&gt;"</span><span class="o">}&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="c1">// scala.xml.Elem = &lt;a&gt;&amp;lt;/a&amp;gt;potential security hole&amp;lt;a&amp;gt;&lt;/a&gt;</span>
</pre></div>

<h3>
<a name="659---serialization" class="anchor" href="#659---serialization"><span class="octicon octicon-link"></span></a><strong>659 - Serialization</strong>
</h3>

<div class="highlight highlight-scala"><pre><span class="c1">// writing our own serializer that converts internal data structures to XML:</span>
<span class="k">abstract</span> <span class="k">class</span> <span class="nc">CCTherm</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">description</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">val</span> <span class="n">yearMade</span><span class="k">:</span> <span class="kt">Int</span>
  <span class="k">val</span> <span class="n">dateObtained</span><span class="k">:</span> <span class="kt">String</span>
  <span class="k">val</span> <span class="n">bookPrice</span><span class="k">:</span> <span class="kt">Int</span>      <span class="c1">// in cents</span>
  <span class="k">val</span> <span class="n">purchasePrice</span><span class="k">:</span> <span class="kt">Int</span>  <span class="c1">// in cents</span>
  <span class="k">val</span> <span class="n">condition</span><span class="k">:</span> <span class="kt">Int</span>      <span class="c1">// 1 to 10</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">toString</span> <span class="k">=</span> <span class="n">description</span>
  <span class="k">def</span> <span class="n">toXML</span> <span class="k">=</span> 
    <span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;{</span><span class="n">description</span><span class="o">}&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;{</span><span class="n">yearMade</span><span class="o">}&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;{</span><span class="n">dateObtained</span><span class="o">}&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;{</span><span class="n">bookPrice</span><span class="o">}&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;{</span><span class="n">purchasePrice</span><span class="o">}&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;{</span><span class="n">condition</span><span class="o">}&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>
<span class="o">}</span>

<span class="c1">// usage:</span>
<span class="k">val</span> <span class="n">therm</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">CCTherm</span> <span class="o">{</span>  <span class="c1">// possible because Scala instantiates anonymous subclass</span>
  <span class="k">val</span> <span class="n">description</span> <span class="k">=</span> <span class="s">"The joy of Clojure"</span>
  <span class="k">val</span> <span class="n">yearMade</span> <span class="k">=</span> <span class="mi">2011</span>
  <span class="k">val</span> <span class="n">dateObtained</span> <span class="k">=</span> <span class="s">"24.08.2013"</span>
  <span class="k">val</span> <span class="n">bookPrice</span> <span class="k">=</span> <span class="mi">2400</span>
  <span class="k">val</span> <span class="n">purchasePrice</span> <span class="k">=</span> <span class="mi">2000</span>
  <span class="k">val</span> <span class="n">condition</span> <span class="k">=</span> <span class="mi">10</span>
<span class="o">}</span> <span class="c1">// therm: CCTherm = The joy of Clojure</span>

<span class="n">therm</span><span class="o">.</span><span class="n">toXML</span>
<span class="c1">// scala.xml.Elem = </span>
<span class="c1">// &lt;cctherm&gt; ...</span>

<span class="c1">// to include curly braces in the XML text just double them:</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;{{</span><span class="n">brace</span> <span class="n">yourself</span><span class="o">!}}&lt;/</span><span class="n">a</span><span class="o">&gt;</span>  <span class="c1">// scala.xml.Elem = &lt;a&gt;{brace yourself!}&lt;/a&gt;</span>
</pre></div>

<h3>
<a name="661---taking-xml-apart" class="anchor" href="#661---taking-xml-apart"><span class="octicon octicon-link"></span></a><strong>661 - Taking XML apart</strong>
</h3>

<blockquote>
<ul>
<li>there are 3 particularly useful methods, based on <em>XPath</em>, that are used to deconstruct XML: <code>text</code>, <code>\</code> and <code>\\</code>, and <code>@</code>
</li>
</ul>
</blockquote>

<p><em>Extracting text</em></p>

<blockquote>
<ul>
<li>by calling the <code>text</code> method on any XML node, you retrieve all the text within that node, minus any element tags:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="nc">Sounds</span> <span class="o">&lt;</span><span class="n">tag</span><span class="o">/&gt;</span> <span class="n">good</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;.</span><span class="n">text</span>  <span class="c1">// String = Sounds  good</span>

<span class="c1">// any encoded characters are decoded automatically:</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span> <span class="n">input</span> <span class="o">---&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">output</span> <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;.</span><span class="n">text</span>  <span class="c1">// String =  input ---&gt; output</span>
</pre></div>

<p><em>Extracting sub-elements</em></p>

<blockquote>
<ul>
<li>to find a sub-element by tag name, simply call <code>\</code> with the name of the tag:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="o">\</span> <span class="s">"b"</span>  <span class="c1">// scala.xml.NodeSeq = &lt;b&gt;&lt;c&gt;hello&lt;/c&gt;&lt;/b&gt;</span>

<span class="c1">// you can do a deep search and look through sub-sub-elements (searches all levels):</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;&lt;</span><span class="n">d</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">d</span><span class="o">&gt;&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>   <span class="o">\</span> <span class="s">"a"</span>  <span class="c1">// NodeSeq =</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;&lt;</span><span class="n">d</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">d</span><span class="o">&gt;&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>  <span class="o">\\</span> <span class="s">"a"</span>  <span class="c1">// NodeSeq = &lt;a&gt;&lt;b&gt;&lt;c&gt;&lt;d&gt;hello&lt;/d&gt;&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;&lt;</span><span class="n">d</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">d</span><span class="o">&gt;&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>   <span class="o">\</span> <span class="s">"b"</span>  <span class="c1">// NodeSeq = &lt;b&gt;&lt;c&gt;&lt;d&gt;hello&lt;/d&gt;&lt;/c&gt;&lt;/b&gt;</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;&lt;</span><span class="n">d</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">d</span><span class="o">&gt;&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>  <span class="o">\\</span> <span class="s">"b"</span>  <span class="c1">// NodeSeq = &lt;b&gt;&lt;c&gt;&lt;d&gt;hello&lt;/d&gt;&lt;/c&gt;&lt;/b&gt;</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;&lt;</span><span class="n">d</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">d</span><span class="o">&gt;&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>   <span class="o">\</span> <span class="s">"c"</span>  <span class="c1">// NodeSeq =</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;&lt;</span><span class="n">d</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">d</span><span class="o">&gt;&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>  <span class="o">\\</span> <span class="s">"c"</span>  <span class="c1">// NodeSeq = &lt;c&gt;&lt;d&gt;hello&lt;/d&gt;&lt;/c&gt;</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;&lt;</span><span class="n">d</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">d</span><span class="o">&gt;&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>   <span class="o">\</span> <span class="s">"d"</span>  <span class="c1">// NodeSeq =</span>
<span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">&gt;&lt;</span><span class="n">c</span><span class="o">&gt;&lt;</span><span class="n">d</span><span class="o">&gt;</span><span class="n">hello</span><span class="o">&lt;/</span><span class="n">d</span><span class="o">&gt;&lt;/</span><span class="n">c</span><span class="o">&gt;&lt;/</span><span class="n">b</span><span class="o">&gt;&lt;/</span><span class="n">a</span><span class="o">&gt;</span>  <span class="o">\\</span> <span class="s">"d"</span> <span class="c1">//&gt; NodeSeq = &lt;d&gt;hello&lt;/d&gt;</span>
</pre></div>

<p><em>Extracting attributes</em></p>

<blockquote>
<ul>
<li>you can extract tag attributes using the same <code>\</code> and <code>\\</code> methods, by simply putting <code>@</code> sign before the attribute name:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">joe</span> <span class="k">=</span> <span class="o">&lt;</span><span class="n">employee</span>
  <span class="n">name</span><span class="o">=</span><span class="s">"JR"</span>
  <span class="n">rank</span><span class="o">=</span><span class="s">"dev"</span>
  <span class="n">serial</span><span class="o">=</span><span class="s">"8"</span><span class="o">/&gt;</span> <span class="c1">// scala.xml.Elem = &lt;employee rank="dev" name="JR" serial="8"&gt;&lt;/employee&gt;</span>

<span class="n">joe</span> <span class="o">\</span> <span class="s">"@name"</span>    <span class="c1">// scala.xml.NodeSeq = JR</span>
<span class="n">joe</span> <span class="o">\</span> <span class="s">"@serial"</span>  <span class="c1">// scala.xml.NodeSeq = 8</span>
</pre></div>

<h3>
<a name="663---deserialization" class="anchor" href="#663---deserialization"><span class="octicon octicon-link"></span></a><strong>663 - Deserialization</strong>
</h3>

<div class="highlight highlight-scala"><pre><span class="c1">// with XML deconstruction methods, we can now write a parser from XML back to our</span>
<span class="c1">// internal data structure:</span>
<span class="c1">// To parse back a 'CCTherm' instance:</span>
<span class="k">def</span> <span class="n">fromXML</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">scala.xml.Node</span><span class="o">)</span><span class="k">:</span> <span class="kt">CCTherm</span> <span class="o">=</span>
  <span class="k">new</span> <span class="nc">CCTherm</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">description</span>   <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span> <span class="s">"description"</span>  <span class="o">).</span><span class="n">text</span>
    <span class="k">val</span> <span class="n">yearMade</span>      <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span> <span class="s">"yearMade"</span>     <span class="o">).</span><span class="n">text</span><span class="o">.</span><span class="n">toInt</span>
    <span class="k">val</span> <span class="n">dateObtained</span>  <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span> <span class="s">"dateObtained"</span> <span class="o">).</span><span class="n">text</span>
    <span class="k">val</span> <span class="n">bookPrice</span>     <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span> <span class="s">"bookPrice"</span>    <span class="o">).</span><span class="n">text</span><span class="o">.</span><span class="n">toInt</span>
    <span class="k">val</span> <span class="n">purchasePrice</span> <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span> <span class="s">"purchasePrice"</span><span class="o">).</span><span class="n">text</span><span class="o">.</span><span class="n">toInt</span>
    <span class="k">val</span> <span class="n">condition</span>     <span class="k">=</span> <span class="o">(</span><span class="n">node</span> <span class="o">\</span> <span class="s">"condition"</span>    <span class="o">).</span><span class="n">text</span><span class="o">.</span><span class="n">toInt</span>
  <span class="o">}</span>

<span class="k">val</span> <span class="n">th</span> <span class="k">=</span> <span class="n">fromXML</span> <span class="o">(</span><span class="n">therm</span><span class="o">.</span><span class="n">toXML</span><span class="o">)</span>  <span class="c1">// CCTherm = The joy of Clojure</span>
</pre></div>

<h3>
<a name="664---loading-and-saving" class="anchor" href="#664---loading-and-saving"><span class="octicon octicon-link"></span></a><strong>664 - Loading and saving</strong>
</h3>

<blockquote>
<ul>
<li>the last part needed to write a data serializer is conversion between XML and stream of bytes</li>
<li>to convert XML to string, all you need is <code>toString</code> method</li>
<li>however, it's better to use a library routine and convert all the way to bytes. That way, the resulting XML can include a directive that specifies which character encoding was used. Otherwise, if you encode string to bytes yourself, you must keep track of the character encoding yourself</li>
<li>to convert from XML to a file of bytes, you can use <code>XML.save</code> command:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">node</span> <span class="k">=</span> <span class="n">therm</span><span class="o">.</span><span class="n">toXML</span>
<span class="n">scala</span><span class="o">.</span><span class="n">xml</span><span class="o">.</span><span class="nc">XML</span><span class="o">.</span><span class="n">save</span><span class="o">(</span><span class="s">"therm1.xml"</span><span class="o">,</span> <span class="n">node</span><span class="o">)</span>

<span class="c1">// to load XML from a file:</span>
<span class="k">val</span> <span class="n">load</span> <span class="k">=</span> <span class="n">scala</span><span class="o">.</span><span class="n">xml</span><span class="o">.</span><span class="nc">XML</span><span class="o">.</span><span class="n">loadFile</span><span class="o">(</span><span class="s">"therm1.xml"</span><span class="o">)</span>
<span class="c1">// scala.xml.Elem = &lt;cctherm&gt;</span>
<span class="c1">//       &lt;description&gt;The joy of Clojure&lt;/description&gt;</span>
<span class="c1">//       &lt;yearMade&gt;2011&lt;/yearMade&gt;</span>
<span class="c1">//       &lt;dateObtained&gt;24.08.2013&lt;/dateObtained&gt;</span>
<span class="c1">//       &lt;bookPrice&gt;2400&lt;/bookPrice&gt;</span>
<span class="c1">//       &lt;purchasePrice&gt;2000&lt;/purchasePrice&gt;</span>
<span class="c1">//       &lt;condition&gt;10&lt;/condition&gt;</span>
<span class="c1">//     &lt;/cctherm&gt;</span>
<span class="k">val</span> <span class="n">th1</span> <span class="k">=</span> <span class="n">fromXML</span><span class="o">(</span><span class="n">load</span><span class="o">)</span>  <span class="c1">// CCTherm = The joy of Clojure</span>
</pre></div>

<h3>
<a name="665---pattern-matching-on-xml" class="anchor" href="#665---pattern-matching-on-xml"><span class="octicon octicon-link"></span></a><strong>665 - Pattern matching on XML</strong>
</h3>

<blockquote>
<ul>
<li>sometimes you may not know what kind of XML structure you're supposed to take apart</li>
<li>an XML pattern looks just like an XML literal, but with one difference. If you insert escape <code>{}</code>, the code withing curly braces is not an expression but a pattern</li>
<li>a pattern embedded in curlies can use the full Scala pattern language, including binding new variables, type tests and ignoring content using <code>_</code> and <code>_*</code> patterns:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">def</span> <span class="n">proc</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">scala.xml.Node</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
  <span class="n">node</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;{</span><span class="n">contents</span><span class="o">}&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">"It's ej "</span> <span class="o">+</span> <span class="n">contents</span>  <span class="c1">// looks for &lt;a&gt; with single subnode</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;{</span><span class="n">contents</span><span class="o">}&lt;/</span><span class="n">b</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">"It's bi "</span> <span class="o">+</span> <span class="n">contents</span>  <span class="c1">// loks</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"Is it something?"</span>
  <span class="o">}</span>
<span class="c1">// expression 'case &lt;a&gt;{contents}&lt;/a&gt;' looks for &lt;a&gt; with single sub node</span>
<span class="c1">// if found, it binds the content to variable named 'contents' and then evaluates the</span>
<span class="c1">// code to the right of the fat arrow</span>

<span class="c1">// usage:</span>
<span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="n">apple</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;)</span>   <span class="c1">// String = It's ej apple</span>
<span class="n">proc</span><span class="o">(&lt;</span><span class="n">b</span><span class="o">&gt;</span><span class="n">banana</span><span class="o">&lt;/</span><span class="n">b</span><span class="o">&gt;)</span>  <span class="c1">// String = It's bi banana</span>

<span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="n">a</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">red</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">apple</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;)</span>  <span class="c1">// String = Is it something?</span>
<span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">/&gt;)</span>                         <span class="c1">// String = Is it something?</span>
</pre></div>

<blockquote>
<ul>
<li>if you want the function to match cases like the last two, you'll have to match against a sequence of nodes instead of a single one</li>
<li>the pattern for any sequence is written <code>_*</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">def</span> <span class="n">proc</span><span class="o">(</span><span class="n">node</span><span class="k">:</span> <span class="kt">scala.xml.Node</span><span class="o">)</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=</span>
  <span class="n">node</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;{</span><span class="n">contents</span> <span class="k">@</span> <span class="k">_</span><span class="o">*}&lt;/</span><span class="n">a</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">"It's an ej "</span> <span class="o">+</span> <span class="n">contents</span>
    <span class="k">case</span> <span class="o">&lt;</span><span class="n">b</span><span class="o">&gt;{</span><span class="n">contents</span> <span class="k">@</span> <span class="k">_</span><span class="o">*}&lt;/</span><span class="n">b</span><span class="o">&gt;</span> <span class="k">=&gt;</span> <span class="s">"It's a bi "</span> <span class="o">+</span> <span class="n">contents</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">"Is it something else?"</span>
  <span class="o">}</span>
<span class="c1">// so now:</span>
<span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="n">a</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="n">red</span><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span> <span class="n">apple</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;)</span>  <span class="c1">// It's an ej ArrayBuffer(a , &lt;em&gt;red&lt;/em&gt;,  apple)</span>
<span class="n">proc</span><span class="o">(&lt;</span><span class="n">a</span><span class="o">/&gt;)</span>                         <span class="c1">// It's an ej Array()</span>
</pre></div>

<blockquote>
<ul>
<li>XML patterns work very nicely with <code>for</code> expressions as a way to iterate through some parts of an XML tree, while ignoring other parts:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// if you wished to skip over the white space between records in the following XML:</span>
<span class="k">val</span> <span class="n">catalog</span> <span class="k">=</span>
  <span class="o">&lt;</span><span class="n">catalog</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;</span><span class="n">hot</span> <span class="n">dog</span> <span class="k">#</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;</span><span class="mi">1952</span><span class="o">&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;</span><span class="nc">March</span> <span class="mi">14</span><span class="o">,</span> <span class="mi">2006</span><span class="o">&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;</span><span class="mi">2199</span><span class="o">&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;</span><span class="mi">500</span><span class="o">&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="mi">9</span><span class="o">&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">description</span><span class="o">&gt;</span><span class="nc">Sprite</span> <span class="nc">Boy</span><span class="o">&lt;/</span><span class="n">description</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">yearMade</span><span class="o">&gt;</span><span class="mi">1964</span><span class="o">&lt;/</span><span class="n">yearMade</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">dateObtained</span><span class="o">&gt;</span><span class="nc">April</span> <span class="mi">28</span><span class="o">,</span> <span class="mi">2003</span><span class="o">&lt;/</span><span class="n">dateObtained</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">bookPrice</span><span class="o">&gt;</span><span class="mi">1695</span><span class="o">&lt;/</span><span class="n">bookPrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">purchasePrice</span><span class="o">&gt;</span><span class="mi">595</span><span class="o">&lt;/</span><span class="n">purchasePrice</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">condition</span><span class="o">&gt;</span><span class="mi">5</span><span class="o">&lt;/</span><span class="n">condition</span><span class="o">&gt;</span>
    <span class="o">&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span>
  <span class="o">&lt;/</span><span class="n">catalog</span><span class="o">&gt;</span>

<span class="n">catalog</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">&lt;</span><span class="n">catalog</span><span class="o">&gt;{</span><span class="n">therms</span> <span class="k">@</span> <span class="k">_</span><span class="o">*}&lt;/</span><span class="n">catalog</span><span class="o">&gt;</span> <span class="k">=&gt;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">therm</span> <span class="k">&lt;-</span> <span class="n">therms</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"processing: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">therm</span> <span class="o">\</span> <span class="s">"description"</span><span class="o">).</span><span class="n">text</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// processing: </span>
<span class="c1">// processing: hot dog #5</span>
<span class="c1">// processing: </span>
<span class="c1">// processing: Sprite Boy</span>
<span class="c1">// processing: </span>

<span class="c1">// there's actually 5 nodes inside '&lt;catalog&gt;', although it looks as if there were 2</span>
<span class="c1">// there's a whitespace before, after and between two elements</span>

<span class="c1">// to ignore the whitespace and process only subnodes inside a '&lt;cctherm&gt;' elem:</span>
<span class="n">catalog</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="o">&lt;</span><span class="n">catalog</span><span class="o">&gt;{</span><span class="n">therms</span> <span class="nd">@_*</span><span class="o">}&lt;/</span><span class="n">catalog</span><span class="o">&gt;</span> <span class="k">=&gt;</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">therm</span> <span class="k">@</span> <span class="o">&lt;</span><span class="n">cctherm</span><span class="o">&gt;{</span><span class="k">_</span><span class="o">*}&lt;/</span><span class="n">cctherm</span><span class="o">&gt;</span> <span class="k">&lt;-</span> <span class="n">therms</span><span class="o">)</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"processing: "</span> <span class="o">+</span> <span class="o">(</span><span class="n">therm</span> <span class="o">\</span> <span class="s">"description"</span><span class="o">).</span><span class="n">text</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// processing: hot dog #5</span>
<span class="c1">// processing: Sprite Boy</span>

<span class="c1">// '&lt;cctherm&gt;{_*}&lt;/cctherm&gt;' restricts matches only to 'cctherm' elements,</span>
<span class="c1">// ignoring whitespace</span>
</pre></div>

<h2>
<a name="modular-programming-using-objects" class="anchor" href="#modular-programming-using-objects"><span class="octicon octicon-link"></span></a>Modular Programming Using Objects</h2>

<blockquote>
<ul>
<li>packages and access modifiers enable you to organize a large program using packages as <em>modules</em>, where a module is a smaller program piece with a well defined interface and a hidden implementation</li>
<li>while packages are quite helpful, they are limited, because they don't provide a way to abstract, i.e. to reconfigure a package two different ways within the same program or to inherit between packages. A package always includes one precise list of contents, which stays the same until you change the code and recompile</li>
</ul>
</blockquote>

<h3>
<a name="670---the-problem" class="anchor" href="#670---the-problem"><span class="octicon octicon-link"></span></a><strong>670 - The problem</strong>
</h3>

<blockquote>
<ul>
<li>being able to compile different modules that make up a system separately helps different teams work independently</li>
<li>being able to unplug one implementation of a module and plug in another is useful, because it allows different configurations to be used in different contexts</li>
<li>any technique that aims to provide solutions to these problems should:

<ul>
<li>have a module construct that provides clean separation of interface and implementation</li>
<li>be able to replace one module with another that has the same interface, without changing or recompiling the modules that depend on the replaced one</li>
<li>be able to wire modules together (can be thought of as <em>configuring the system</em>)</li>
</ul>
</li>
<li>one approach of solving this problem is <strong>dependency injection</strong>, a technique supported by Spring and Guice on the Java platform</li>
<li>Spring, for example, essentially allows you to represent the interface of a module as a Java interface and implementation of a module as Java classes, where you can specify dependencies between modules and wire an application together via external XML configuration files</li>
<li>with Scala you have some alternatives provided by the language itself, which enables you to solve "the problem" without using an external framework</li>
</ul>
</blockquote>

<h3>
<a name="671---application-design" class="anchor" href="#671---application-design"><span class="octicon octicon-link"></span></a><strong>671 - Application design</strong>
</h3>

<blockquote>
<ul>
<li>the intention is to partition our application into a <strong>domain layer</strong> and an <strong>application layer</strong>
</li>
<li>in the <em>domain layer</em> we'll define <strong>domain objects</strong>, which will capture business concepts and rules, and encapsulate state that will be persisted to a database</li>
<li>in the <em>application layer</em> we'll provide an <strong>API</strong> organized in terms of the services the application offers to clients (including the user interface layer) and implement these services by coordinating tasks and delegating the work to the objects of the <em>domain layer</em>
</li>
<li>to be able to plug in real and mock versions of certain objects in each of these layers (e.g. to more easily write unit tests) we'll treat objects that we want to mock as modules</li>
</ul>
</blockquote>

<h3>
<a name="674---abstraction" class="anchor" href="#674---abstraction"><span class="octicon octicon-link"></span></a><strong>674 - Abstraction</strong>
</h3>

<blockquote>
<ul>
<li>to avoid using hard link between modules we use abstract classes and then make modules inherit from these classes</li>
<li>that way, we can avoid code duplication by providing all common operations in the abstract classes</li>
</ul>
</blockquote>

<h3>
<a name="677---splitting-modules-into-traits" class="anchor" href="#677---splitting-modules-into-traits"><span class="octicon octicon-link"></span></a><strong>677 - Splitting modules into traits</strong>
</h3>

<blockquote>
<ul>
<li>when a module becomes too large to fit into a single file, we can use traits to split a module into separate files</li>
<li>
<strong>self type</strong> specifies the requirements on any concrete class the trait is mixed into. If you have a trait that is only ever used when mixed in with another trait or traits, then you can specify that those other traits should be assumed:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">trait</span> <span class="nc">SimpleRecipes</span> <span class="o">{</span>
  <span class="k">this:</span> <span class="kt">SimpleFoods</span> <span class="o">=&gt;</span>  <span class="c1">// self type</span>
    <span class="c1">// presents a requirement to a class that mixes this trait in:</span>
    <span class="c1">// that it has to always be mixed in together with SimpleFoods</span>

  <span class="k">object</span> <span class="nc">FruitSalad</span> <span class="k">extends</span> <span class="nc">Recipe</span><span class="o">(</span>
    <span class="s">"fruit salad"</span><span class="o">,</span>
    <span class="nc">List</span><span class="o">(</span><span class="nc">Apple</span><span class="o">,</span> <span class="nc">Pear</span><span class="o">),</span> <span class="c1">// 'this.Pear' is in scope because of self type</span>
    <span class="s">"Mix it all together."</span>
  <span class="o">)</span>
  <span class="k">def</span> <span class="n">allRecipes</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="nc">FruitSalad</span><span class="o">)</span>
<span class="o">}</span>
<span class="c1">// this is safe because any concrete class that mixes in 'SimpleRecipes' must also mix </span>
<span class="c1">// in, i.e. be a subtype of 'SimpleFoods', so 'Pear' will always be a member</span>
<span class="c1">// Since abstract classes and traits cannot be instantiated with 'new', there is no risk</span>
<span class="c1">// that the 'this.Pear' reference will ever fail</span>
</pre></div>

<p><a href="https://github.com/mbonaci/scala/tree/master/scala2e-book/src/scala2e/chapter29/recipesApp">See the whole app for the complete picture.</a></p>

<h3>
<a name="680---runtime-linking" class="anchor" href="#680---runtime-linking"><span class="octicon octicon-link"></span></a><strong>680 - Runtime linking</strong>
</h3>

<blockquote>
<ul>
<li>modules can be linked together at runtime, and you can decide which modules will link to which depending on runtime computations:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// a simple program that chooses a database at runtime:</span>
<span class="k">object</span> <span class="nc">GotApples</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">db</span><span class="k">:</span> <span class="kt">Database</span> <span class="o">=</span>
      <span class="k">if</span><span class="o">(</span><span class="n">args</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">==</span> <span class="s">"student"</span><span class="o">)</span>
        <span class="nc">StudentDatabase</span>
      <span class="k">else</span>
        <span class="nc">SimpleDatabase</span>

    <span class="k">object</span> <span class="nc">browser</span> <span class="k">extends</span> <span class="nc">Browser</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">database</span> <span class="k">=</span> <span class="n">db</span>
    <span class="o">}</span>

    <span class="k">val</span> <span class="n">apple</span> <span class="k">=</span> <span class="nc">SimpleDatabase</span><span class="o">.</span><span class="n">foodNamed</span><span class="o">(</span><span class="s">"Apple"</span><span class="o">).</span><span class="n">get</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">recipe</span> <span class="k">&lt;-</span> <span class="n">browser</span><span class="o">.</span><span class="n">recipesUsing</span><span class="o">(</span><span class="n">apple</span><span class="o">))</span>
      <span class="n">println</span><span class="o">(</span><span class="n">recipe</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h3>
<a name="681---tracking-module-instances" class="anchor" href="#681---tracking-module-instances"><span class="octicon octicon-link"></span></a><strong>681 - Tracking module instances</strong>
</h3>

<blockquote>
<ul>
<li>despite using the same code, the different browser and database modules really are separate modules, which means that each module has its own contents, including any nested classes. E.g. <code>FoodCategory</code> in <code>SimpleDatabase</code> is a different class from <code>FoodCategory</code> in <code>StudentDatabase</code>
</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">category</span> <span class="k">=</span> <span class="nc">StudentDatabase</span><span class="o">.</span><span class="n">allCategories</span><span class="o">.</span><span class="n">head</span>
<span class="c1">// category: StudentDatabase.FoodCategory = FoodCategory(edible,List(FrozenFood))</span>

<span class="nc">SimpleBrowser</span><span class="o">.</span><span class="n">displayCategory</span><span class="o">(</span><span class="n">category</span><span class="o">)</span>
<span class="c1">// type mismatch:</span>
<span class="c1">// found    : StudentDatabase.FoodCategory</span>
<span class="c1">// required : SimpleDatabase.FoodCategory</span>
</pre></div>

<blockquote>
<ul>
<li>if you want all <code>FoodCategory</code> objects to be the same, move its definition outside of any class or trait</li>
<li>sometimes you can encounter a situation where two types are the same but the compiler can't verify it. In such cases you can often fix the problem using <strong>singleton types</strong>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// the type checker doesn't know that 'db' and 'browser.database' are of the same type:</span>
<span class="k">object</span> <span class="nc">GotApples</span> <span class="o">{</span>
  <span class="c1">// same definitions as before ...</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">cat</span> <span class="k">&lt;-</span> <span class="n">db</span><span class="o">.</span><span class="n">allCategories</span><span class="o">)</span>
    <span class="n">browser</span><span class="o">.</span><span class="n">displayCategory</span><span class="o">(</span><span class="n">cat</span><span class="o">)</span>
  <span class="c1">// type mismatch</span>
  <span class="c1">// found    : db.FoodCategory</span>
  <span class="c1">// required : browser.database.FoodCategory</span>

<span class="c1">// to circumvent the problem, inform the type checker that they are the same object:</span>
  <span class="k">object</span> <span class="nc">browser</span> <span class="k">extends</span> <span class="nc">Browser</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">database</span><span class="k">:</span> <span class="kt">db.</span><span class="k">type</span> <span class="o">=</span> <span class="n">db</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>
<em>singleton type</em> is extremely specific and holds only one object, in this case, whichever object is referred to by <code>db</code>
</li>
<li>usually such types are to specific to be useful, which is why the compiler is reluctant to insert them automatically</li>
</ul>
</blockquote>

<h2>
<a name="object-equality" class="anchor" href="#object-equality"><span class="octicon octicon-link"></span></a>Object Equality</h2>

<h3>
<a name="684---equality-in-scala" class="anchor" href="#684---equality-in-scala"><span class="octicon octicon-link"></span></a><strong>684 - Equality in Scala</strong>
</h3>

<blockquote>
<ul>
<li>the definition of equality is different in Scala and Java</li>
<li>Java has two equality comparisons, the <code>==</code> operator, which is the natural equality for value types and object identity for reference types, and the <code>equals</code> method, which is user-defined canonical equality for reference types</li>
<li>this convention is problematic, because the more natural symbol, <code>==</code>, does not always correspond to the natural notion of equality</li>
<li>e.g. comparing two strings <code>x</code> and <code>y</code> using <code>x == y</code> might well yield <code>false</code> in Java, even if <code>x</code> and <code>y</code> have exactly the same characters, in the same order</li>
<li>Scala also has object reference equality method, but it's not used much. That kind of equality, written <code>x eq y</code>, is true only if <code>x</code> and <code>y</code> refer to the same object</li>
<li>the <code>==</code> equality is reserved in Scala for the <em>natural</em> equality of each type. For value types, it is value comparison, just like in Java, but for reference types, it is the same as <code>equals</code>
</li>
<li>that means that you can redefine the behavior of <code>==</code> for new types by overriding the <code>equals</code> method, which is always inherited from class <code>Any</code> (where it represents object reference equality)</li>
<li>it is not possible to override <code>==</code> directly (final in class <code>Any</code>)</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// Scala treats '==' as if it was defined like this in class 'Any':</span>
<span class="k">final</span> <span class="k">def</span> <span class="o">==</span> <span class="o">(</span><span class="n">that</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">noll</span> <span class="n">eq</span> <span class="k">this</span><span class="o">)</span> <span class="o">{</span><span class="kc">null</span> <span class="n">eq</span> <span class="n">that</span><span class="o">}</span>
  <span class="k">else</span> <span class="o">{</span><span class="k">this</span> <span class="n">equals</span> <span class="n">that</span><span class="o">}</span>
</pre></div>

<h3>
<a name="685---writing-an-equality-method" class="anchor" href="#685---writing-an-equality-method"><span class="octicon octicon-link"></span></a><strong>685 - Writing an equality method</strong>
</h3>

<blockquote>
<ul>
<li>common pitfalls when overriding <code>equals</code>:

<ul>
<li>defining <code>equals</code> with the wrong signature</li>
<li>changing <code>equals</code> without also changing <code>hashCode</code>
</li>
<li>defining <code>equals</code> in terms of mutable fields</li>
<li>failing to define <code>equals</code> as an equivalence relation<br>
</li>
</ul>
</li>
</ul>
</blockquote>

<p><em>Defining <code>equals</code> with the wrong signature</em></p>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">){</span> <span class="cm">/*...*/</span> <span class="o">}</span>

<span class="c1">// wrong way to define equals:</span>
<span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Point</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">y</span>

<span class="c1">// the problem is that it doesn't match the signature of 'equals' in class 'Any' </span>
<span class="c1">// simple comparisons work fine, but the trouble starts with Points in collections:</span>
<span class="k">import</span> <span class="nn">scala.collection.mutable._</span>
<span class="k">val</span> <span class="n">p1</span><span class="o">,</span> <span class="n">p2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">coll</span> <span class="k">=</span> <span class="nc">HashSet</span><span class="o">(</span><span class="n">p1</span><span class="o">)</span>  <span class="c1">// mutable.HashSet[Point] = Set(Point@79f23c)</span>
<span class="n">coll</span> <span class="n">contains</span> <span class="n">p2</span>        <span class="c1">// false</span>

<span class="c1">// the problem is that our method 'equals' only overloads 'equals' in class 'Any'</span>
<span class="c1">// overloading in Scala and in Java is resolved by the static type of the argument,</span>
<span class="c1">// not the runtime type</span>
<span class="c1">// So as long as the static type of the argument is 'Point', our 'equals' is called</span>
<span class="c1">// but once a static argument is of type 'Any', the 'equals' in 'Any' is called instead</span>
<span class="c1">// And since this method has not been overridden, it still compares object references</span>
<span class="c1">// This is why 'p1 equals p2a' yields 'false', and why the 'contains' method in</span>
<span class="c1">// 'HashSet' returned 'false', since it operates on generic sets, it calls the generic</span>
<span class="c1">// 'equals' method in 'Object' instead of the overloaded one in 'Point'</span>

<span class="c1">// a better 'equals' (with correct type, but still not perfect):</span>
<span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
  <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span>
  <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
<span class="o">}</span>

<span class="c1">// a related pitfall is to define '==' with a wrong signature</span>
<span class="c1">// normally, if you try to override '==' with the correct signature, the compiler will</span>
<span class="c1">// give you an error because '==' is final</span>

<span class="c1">// the common error (two errors) is to try to override '==' with a wrong signature:</span>
<span class="k">def</span> <span class="o">==(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Point</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="cm">/* ... */</span>
<span class="c1">// in this case, the method is treated as an overloaded '==' so it compiles</span>
</pre></div>

<p><em>Changing <code>equals</code> without also changing <code>hashCode</code></em></p>

<blockquote>
<ul>
<li>for <em>hash-based collections</em>, element of the collection are put in <em>hash buckets</em> determined by their hash code</li>
<li>the <code>contains</code> test first determines a hash bucket to look in and then compares the given element with all elements in that bucket, and if element equal to the one provided is not found, the method returns <code>false</code>
</li>
<li>the original <code>hashCode</code>, in <code>AnyRef</code>, calculates hash code by some transformation of the address of the object, so hash codes of <code>p1</code> and <code>p2</code> are different, even though the fields have the same values</li>
<li>different hash codes result, with high probability, with different buckets in the set</li>
<li>the root of the problem can be described with the contract, that the "better equals" violated:<br><ul>
<li><em>If two objects are equal according to the <code>equals</code> method, then calling the <code>hashCode</code> on each of the two objects must produce the same integer result</em></li>
<li><em><code>hashCode</code> and <code>equals</code> should only be redefined together</em></li>
<li><em><code>hashCode</code> may only depend on fields the <code>equals</code> depends on</em></li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// the suitable definition of 'hashCode':</span>
<span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span><span class="mi">41</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="n">y</span>  <span class="c1">// 41 is prime</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// this 'hashCode' should give reasonable distribution of hash codes at a low cost</span>
</pre></div>

<p><em>Defining <code>equals</code> in terms of mutable fields</em></p>

<div class="highlight highlight-scala"><pre><span class="c1">// the slight variation of class Point:</span>
<span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">var</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>  <span class="c1">// notice 'vars'</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span><span class="mi">41</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="n">y</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>the <code>equals</code> and <code>hashCode</code> are now defined in terms of these mutable fields, so their results change when fields change, which can have strange effects once you put points in collections:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>   <span class="c1">// Point = Point@3c990add</span>
<span class="k">val</span> <span class="n">coll</span> <span class="k">=</span> <span class="nc">HashSet</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>     <span class="c1">// mutable.HashSet[Point] = Set(Point@3c990add)</span>
<span class="n">coll</span> <span class="n">contains</span> <span class="n">p</span>           <span class="c1">// true</span>

<span class="c1">// now we change a field:</span>
<span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="n">coll</span> <span class="n">contains</span> <span class="n">p</span>           <span class="c1">// false</span>
<span class="n">coll</span><span class="o">.</span><span class="n">iterator</span> <span class="n">contains</span> <span class="n">p</span>  <span class="c1">// true</span>

<span class="c1">// what happened is that now 'hashCode' evaluates to different value, so 'contains'</span>
<span class="c1">// looks for provided element in a wrong bucket</span>
</pre></div>

<blockquote>
<ul>
<li>if you need a comparison that takes the current state of an object into account, you should name the method differently, something other than <code>equals</code>, e.g. <code>equalContents</code><br>
</li>
</ul>
</blockquote>

<p><em>Failing to define <code>equals</code> as an equivalence relation (same as Java)</em></p>

<blockquote>
<ul>
<li>
<p>the contract of the <code>equals</code> method in <code>scala.Any</code>:  </p>

<ul>
<li>
<strong>reflexive</strong>: <em>for any non-null value <code>x</code>, the expression <code>x.equals(x)</code> should return <code>true</code></em>
</li>
<li>
<strong>symmetric</strong>: <em>for any non-null values <code>x</code> and <code>y</code>, the expression <code>x.equals(y)</code> should return <code>true</code> if and only if <code>y.equals(x)</code> returns <code>true</code></em>
</li>
<li>
<strong>transitive</strong>: <em>for any non-null values <code>x</code>, <code>y</code> and <code>z</code>, if <code>x.equals(y)</code> returns <code>true</code> and <code>y.equals(z)</code> returns <code>true</code>, then <code>x.equals(z)</code> should return <code>true</code></em>
</li>
<li>
<strong>consistent</strong>: <em>for any non-null values <code>x</code> and <code>y</code>, multiple invocations of <code>x.equals(y)</code> should consistently return <code>true</code> or consistently return <code>false</code>, provided no information used in equals comparisons is modified</em>
</li>
<li><em>for any non-null value <code>x</code>, the expression <code>x.equals(null)</code> should return <code>false</code></em></li>
<li>the "better equals" definition conforms to <em>the contract</em>, but things become more complicated when inheritance is introduced:</li>
</ul>
</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">object</span> <span class="nc">Color</span> <span class="k">extends</span> <span class="nc">Enumeration</span> <span class="o">{</span>
  <span class="k">val</span> <span class="nc">Red</span><span class="o">,</span> <span class="nc">Orange</span><span class="o">,</span> <span class="nc">Yellow</span><span class="o">,</span> <span class="nc">Green</span><span class="o">,</span> <span class="nc">Blue</span><span class="o">,</span> <span class="nc">Indigo</span><span class="o">,</span> <span class="nc">Violet</span> <span class="k">=</span> <span class="nc">Value</span>
<span class="o">}</span>

<span class="c1">// non-symmetric equals:</span>
<span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.Value</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span> <span class="o">&amp;&amp;</span> <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="c1">// doesn't need to override 'hashCode', since this 'equals' is stricter than point's</span>
<span class="c1">// so the contract for 'hashCode' is satisfied</span>
<span class="c1">// If two colored points are equal, they must have the same coordinates, so their hash</span>
<span class="c1">// codes are guaranteed to be equal as well</span>
<span class="o">}</span>

<span class="c1">// the 'equals' contract becomes broken once points and color points are mixed:</span>
<span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>                     <span class="c1">// Point = Point@6aeee</span>
<span class="k">val</span> <span class="n">cp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Red</span><span class="o">)</span>  <span class="c1">// ColoredPoint = ColoredPoint@6aeee</span>
<span class="n">p</span> <span class="n">equals</span> <span class="n">cp</span>    <span class="c1">// true  - invokes p's equals (from class 'Point')</span>
<span class="n">cp</span> <span class="n">equals</span> <span class="n">p</span>    <span class="c1">// false - invokes cp's equals (from class 'ColoredPoint')</span>

<span class="c1">// so the relation defined by 'equals' is not symmetric, which can have unexpected </span>
<span class="c1">// consequences for collections:</span>
<span class="nc">HashSet</span><span class="o">[</span><span class="kt">Point</span><span class="o">](</span><span class="n">p</span><span class="o">)</span> <span class="n">contains</span> <span class="n">cp</span>  <span class="c1">// true</span>
<span class="nc">HashSet</span><span class="o">[</span><span class="kt">Point</span><span class="o">](</span><span class="n">cp</span><span class="o">)</span> <span class="n">contains</span> <span class="n">p</span>  <span class="c1">// false</span>
</pre></div>

<blockquote>
<ul>
<li>to fix the symmetry problem, you can either make the relation more general or more strict</li>
<li>making it more general means that a pair of two objects, <code>x</code> and <code>y</code>, is taken to be equal if either comparing <code>x</code> with <code>y</code> or comparing <code>y</code> with <code>x</code> yields true:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.Value</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span>  <span class="c1">// special comparison for points</span>
      <span class="n">that</span> <span class="n">equals</span> <span class="k">this</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// Now, both 'cp equals p' and 'p equals cp' result in 'true'</span>
<span class="c1">// However, the contract for equals is still broken. Now the problem is that the new</span>
<span class="c1">// relation is no longer transitive:</span>
<span class="k">val</span> <span class="n">redp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Red</span><span class="o">)</span>
<span class="k">val</span> <span class="n">blup</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Blue</span><span class="o">)</span>

<span class="c1">// taken individually:</span>
<span class="n">redp</span> <span class="o">==</span> <span class="n">p</span>  <span class="c1">// true</span>
<span class="n">p</span> <span class="o">==</span> <span class="n">blup</span>  <span class="c1">// true</span>

<span class="c1">// but:</span>
<span class="n">redp</span> <span class="o">==</span> <span class="n">blup</span>  <span class="c1">// false - OK, but transitivity is messed up</span>
</pre></div>

<blockquote>
<ul>
<li>making relation more general seems to lead to a dead end, so we'll try stricter</li>
<li>one way of making <code>equals</code> stricter is to always treat object of different classes as not equal:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// technically valid, but still not perfect 'equals':</span>
<span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span><span class="mi">41</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="n">y</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span>
      <span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">getClass</span> <span class="k">=</span> <span class="n">that</span><span class="o">.</span><span class="n">getClass</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// revert back to non-symmetric one (which is, with this version of Point, symmetric)</span>
<span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.Value</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// here, an instance of class 'Point' is equal to some other instance of the same class</span>
<span class="c1">// only if the objects have the same field values and same runtime class</span>

<span class="c1">// but still, an anonymous subclass of point, with the same field values:</span>
<span class="k">val</span> <span class="n">anonP</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="k">override</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">}</span>  <span class="c1">// Point = $anon$1@34e0a</span>

<span class="c1">// is 'anonP' equal to 'p'? Logically it is, but technically it isn't, which is what we</span>
<span class="c1">// don't want in Scala</span>
</pre></div>

<blockquote>
<ul>
<li>to redefine equality on several levels of the class hierarchy while keeping its contract, we are required to redefine one more method, <code>canEqual</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// signature:</span>
<span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span>
</pre></div>

<blockquote>
<ul>
<li>
<code>canEqual</code> should return <code>true</code> if the provided object is an instance of the class in which <code>canEqual</code> is (re)defined</li>
<li>as soon as a class redefines <code>equals</code>, it should also explicitly state that objects of this class are never equal to objects of some superclass that implements a different equality method</li>
<li>
<code>canEqual</code> is called from <code>equals</code> to make sure that the objects are comparable both ways</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">class</span> <span class="nc">Point</span><span class="o">(</span><span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span><span class="mi">41</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span> <span class="o">+</span> <span class="n">y</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Point</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">x</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">y</span><span class="o">)</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="kc">false</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Point</span><span class="o">]</span>  <span class="c1">// all points can be equal</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="k">val</span> <span class="n">color</span><span class="k">:</span> <span class="kt">Color.Value</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span> <span class="k">=</span> <span class="mi">41</span> <span class="o">*</span> <span class="k">super</span><span class="o">.</span><span class="n">hashCode</span> <span class="o">+</span> <span class="n">color</span><span class="o">.</span><span class="n">hashCode</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">ColoredPoint</span> <span class="o">=&gt;</span>
      <span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">color</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
      <span class="kc">false</span>
  <span class="o">}</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">ColoredPoint</span><span class="o">]</span>
<span class="o">}</span>

<span class="c1">// now:</span>
<span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
<span class="k">val</span> <span class="n">cp</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">ColoredPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="nc">Indigo</span><span class="o">)</span>
<span class="k">val</span> <span class="n">anonP</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="k">override</span> <span class="k">val</span> <span class="n">y</span> <span class="k">=</span> <span class="mi">2</span> <span class="o">}</span>
<span class="k">val</span> <span class="n">coll</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="n">p</span><span class="o">)</span>   <span class="c1">// List[Point] = List(Point@4aa)</span>
<span class="n">coll</span> <span class="n">contains</span> <span class="n">p</span>      <span class="c1">// true</span>
<span class="n">coll</span> <span class="n">contains</span> <span class="n">cp</span>     <span class="c1">// false</span>
<span class="n">coll</span> <span class="n">contains</span> <span class="n">anonP</span>  <span class="c1">// true</span>
</pre></div>

<blockquote>
<ul>
<li>if superclass <code>equals</code> defines and calls <code>canEqual</code>, then programmers who implement subclasses can decide whether or not their subclasses may be equal to instances of the superclass</li>
</ul>
</blockquote>

<h3>
<a name="698---defining-equality-for-parameterized-types" class="anchor" href="#698---defining-equality-for-parameterized-types"><span class="octicon octicon-link"></span></a><strong>698 - Defining equality for parameterized types</strong>
</h3>

<blockquote>
<ul>
<li>when classes are parameterized, <code>equals</code> pattern matching scheme needs to be adapted</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// binary tree with two implementations</span>
<span class="k">trait</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">+T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span>
  <span class="k">def</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
  <span class="k">def</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">EmptyTree</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">Nothing</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">elem</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"EmptyTree.elem"</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">left</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"EmptyTree.left"</span><span class="o">)</span>
  <span class="k">def</span> <span class="n">right</span> <span class="k">=</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoSuchElementException</span><span class="o">(</span><span class="s">"EmptyTree.Right"</span><span class="o">)</span>
<span class="o">}</span>

<span class="k">class</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">+T</span><span class="o">](</span>
  <span class="k">val</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span>
  <span class="k">val</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">val</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>

<span class="c1">// implementing 'equals' and 'hashCode':</span>
<span class="c1">// no need for class 'Tree' - subclasses redefine them</span>
<span class="c1">// no need for object 'EmptyTree' - AnyRef's implementations are fine, after all,</span>
<span class="c1">// any empty tree is only equal to itself, so reference equality is just what we need</span>

<span class="c1">// a 'Branch' value should only be equal to other 'Branch' values, and only if they</span>
<span class="c1">// have equal 'elem', 'left' and 'right' fields:</span>
<span class="k">class</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">+T</span><span class="o">](</span>
  <span class="k">val</span> <span class="n">elem</span><span class="k">:</span> <span class="kt">T</span><span class="o">,</span>
  <span class="k">val</span> <span class="n">left</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span>
  <span class="k">val</span> <span class="n">right</span><span class="k">:</span> <span class="kt">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
<span class="o">)</span> <span class="k">extends</span> <span class="nc">Tree</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=&gt;</span> 
      <span class="k">this</span><span class="o">.</span><span class="n">elem</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">elem</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">left</span> <span class="o">&amp;&amp;</span>
      <span class="k">this</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">right</span>
    <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
  <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// compiling this code gives 'unchecked' warning:</span>
<span class="c1">//   warning: non variable type-argument T in type pattern is unchecked since it is</span>
<span class="c1">//   eliminated by erasure</span>

<span class="c1">// we saw this before, compiler can only check that the 'other' reference is some kind</span>
<span class="c1">// of 'Branch'. It cannot check that the element type of the tree is 'T'</span>
<span class="c1">// The reason for this is that element types of parameterized types are eliminated by</span>
<span class="c1">// the compiler's erasure phase, so they are not available for inspection at runtime</span>

<span class="c1">// fortunately, we don't even need to check that two branches have the same element</span>
<span class="c1">// types. It's quite possible that, in order to declare two branches as equal, all</span>
<span class="c1">// we need to do is compare their fields:</span>
<span class="k">val</span> <span class="n">b1</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]](</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">EmptyTree</span><span class="o">,</span> <span class="nc">EmptyTree</span><span class="o">)</span>
<span class="k">val</span> <span class="n">b2</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Branch</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]](</span><span class="nc">Nil</span><span class="o">,</span> <span class="nc">EmptyTree</span><span class="o">,</span> <span class="nc">EmptyTree</span><span class="o">)</span>
<span class="n">b1</span> <span class="o">==</span> <span class="n">b2</span>  <span class="c1">// true</span>
<span class="c1">// the result shows that the element types was not compared (otherwise would be 'false')</span>
</pre></div>

<blockquote>
<ul>
<li>there's only a small change needed in order to formulate <code>equals</code> that does not produce <code>unchecked</code> warning, instead of element type <code>T</code>, use a lower case letter, such as <code>t</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">t</span><span class="o">]</span> <span class="k">=&gt;</span> 
  <span class="k">this</span><span class="o">.</span><span class="n">elem</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">elem</span> <span class="o">&amp;&amp;</span>
  <span class="k">this</span><span class="o">.</span><span class="n">left</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">left</span> <span class="o">&amp;&amp;</span>
  <span class="k">this</span><span class="o">.</span><span class="n">right</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">right</span>

<span class="c1">// the reason this works is that a type parameter in a pattern starting with a lower</span>
<span class="c1">// case letter represents an unknown type, hence the pattern match:</span>
<span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="kt">t</span><span class="o">]</span> <span class="k">=&gt;</span>
<span class="c1">// will succeed for 'Branch' of any type</span>

<span class="c1">// it can also be replaced with the underscore</span>
<span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]</span> <span class="k">=&gt;</span>  <span class="c1">// equivalent to the previous case, with 't'</span>
</pre></div>

<blockquote>
<ul>
<li>the only thing that remains, for class <code>Branch</code>, is to define the other two methods, <code>hashCode</code> and <code>canEqual</code>
</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// the possible implementation of 'hashCode':</span>
<span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span>
    <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span>
      <span class="mi">41</span> <span class="o">+</span> <span class="n">elem</span><span class="o">.</span><span class="n">hashCode</span>
    <span class="o">)</span> <span class="o">+</span> <span class="n">left</span><span class="o">.</span><span class="n">hashCode</span>
  <span class="o">)</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">hashCode</span>

<span class="c1">// canEqual implementation:</span>
<span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span> <span class="k">=</span> <span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Branch</span><span class="o">[</span><span class="k">_</span><span class="o">]]</span>
<span class="c1">// 'Branch[_]' is a shorthand for so-called 'existential type', which is roughly</span>
<span class="c1">// speaking a type with some unknown parts in it (next chapter)</span>
<span class="c1">// so even though technically the underscore stand for two different things in a match</span>
<span class="c1">// pattern and in a type parameter of a method call, in essence the meaning is the same:</span>
<span class="c1">// it lets you label something that is unknown</span>
</pre></div>

<h3>
<a name="703---recipes-for-equals-and-hashcode" class="anchor" href="#703---recipes-for-equals-and-hashcode"><span class="octicon octicon-link"></span></a><strong>703 - Recipes for <code>equals</code> and <code>hashCode</code></strong>
</h3>

<blockquote>
<p><strong>- <code>equals</code> recipe:</strong></p>

<ul>
<li>
<strong>1.</strong>  if you're going to override equals in a non-final class, you should crate a <code>canEqual</code> method. If the inherited definition of <code>equals</code> is from <code>AnyRef</code> (not redefined higher up the class hierarchy), the definition of <code>canEqual</code> will be new, otherwise it will override a previous definition of a method with the same signature. The only exception to this requirement is for final classes that redefine the <code>equals</code> method inherited from <code>AnyRef</code>. For them, the subclass anomalies cannot arise. Consequently, they need not define <code>canEqual</code>. The type of the object passed to <code>canEqual</code> should be <code>Any</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">def</span> <span class="n">canEqual</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="cm">/* ... */</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>2.</strong>  the <code>canEqual</code> method should yield <code>true</code> if the argument object is an instance of the current class (i.e. the class in which <code>canEqual</code> is defined), <code>false</code> otherwise:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="n">other</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">Rational</span><span class="o">]</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>3.</strong>  in the <code>equals</code> method, make sure you declare the type of the object passed as <code>Any</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">equals</span><span class="o">(</span><span class="n">other</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="cm">/* ... */</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>4.</strong>  write the body of the <code>equals</code> method as a single <code>match</code> expression. The selector of the <code>match</code> should be the object passed to <code>equals</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="n">other</span> <span class="k">match</span> <span class="o">{</span>
  <span class="c1">// ...</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>5.</strong>  the <code>match</code> expression should have two cases, the first should declare a typed pattern for the type of the class on which you're defining <code>equals</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">case</span> <span class="n">that</span><span class="k">:</span> <span class="kt">Rational</span> <span class="o">=&gt;</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>6.</strong>  in the body of this, first <em>case</em>, write an expression that logical-ands together the individual expressions that must be <code>true</code> for the objects to be equal. If the <code>equals</code> you're overriding is not that of <code>AnyRef</code>, you'll most likely want to include an invocation of the superclass's <code>equals</code>
</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">super</span><span class="o">.</span><span class="n">equals</span><span class="o">(</span><span class="n">that</span><span class="o">)</span> <span class="o">&amp;&amp;</span>  <span class="c1">// ...</span>
</pre></div>

<blockquote>
<p>if you're defining <code>equals</code> for a class that first introduced <code>canEqual</code>, you should invoke <code>canEqual</code> on the argument to the equality method, passing <code>this</code> as the argument:</p>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="o">(</span><span class="n">that</span> <span class="n">canEqual</span> <span class="k">this</span><span class="o">)</span> <span class="o">&amp;&amp;</span>  <span class="c1">// ...</span>
</pre></div>

<blockquote>
<p>overriding definitions of <code>equals</code> should also include the <code>canEqual</code> invocation, unless they contain a call to <code>super.equals</code>. In the latter case, the <code>canEqual</code> test will already be done by the superclass call. For each field, relevant to equality, verify that the field in this object is equal to the corresponding field in the passed object:</p>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="n">numer</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">numer</span> <span class="o">&amp;&amp;</span> <span class="n">denom</span> <span class="o">==</span> <span class="n">that</span><span class="o">.</span><span class="n">denom</span>
</pre></div>

<blockquote>
<ul>
<li>
<strong>7.</strong>  for the second <em>case</em>, use a wildcard pattern that yields false:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="kc">false</span>
</pre></div>

<blockquote>
<p><strong>- <code>hashCode</code> recipe:</strong></p>

<ul>
<li>include in the calculation each field in your object that is used to determine equality in the <code>equals</code> method (_the relevant fields_)</li>
<li>for each relevant field, no matter its type, you can calculate a hash code by invoking <code>hashCode</code> on it</li>
<li>to calculate hash code for the entire object, add <strong>41</strong> to the first field's hash code, multiply that by 41, add the second field's hash code, multiply that by 41, add the third field's hash code, multiply that by 41, and continue until you've done this for all relevant fields:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// hash code calculation for object with 5 relevant fields:</span>
<span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span>
    <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span>
      <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span>
        <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span>
          <span class="mi">41</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">hashCode</span>
        <span class="o">)</span> <span class="o">+</span> <span class="n">b</span><span class="o">.</span><span class="n">hashCode</span>
      <span class="o">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">.</span><span class="n">hashCode</span>
    <span class="o">)</span> <span class="o">+</span> <span class="n">d</span><span class="o">.</span> <span class="n">hashCode</span>
  <span class="o">)</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="n">hashCode</span>
</pre></div>

<blockquote>
<ul>
<li>you can leave off the <code>hashCode</code> invocation on fields of type <code>Int</code>, <code>Short</code>, <code>Byte</code> and <code>Char</code> (their hash codes are their values):</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span>
    <span class="mi">41</span> <span class="o">+</span> <span class="n">numer</span>
  <span class="o">)</span> <span class="o">+</span> <span class="n">denom</span>
</pre></div>

<blockquote>
<ul>
<li>the number 41 was selected because it is an odd prime (you could use another number, but it should be an odd prime to minimize the potential for information loss on overflow).  The reason we add 41 to the innermost value is to reduce the likelihood that the first multiplication will result in zero, under the assumption that it is more likely the first field will be zero than -41 (there, in addition part, it could be any other non-zero integer, 41 was chosen just because of other 41s)</li>
<li>if the <code>equals</code> invokes <code>super.equals(that)</code>, you should start your <code>hashCode</code> with an invocation of <code>super.hashCode</code>. For example, had <code>Rational</code>'s <code>equals</code> method invoked <code>super.equals(that)</code>, its <code>hashCode</code> would have been:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">override</span> <span class="k">def</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span>
    <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span>
      <span class="k">super</span><span class="o">.</span><span class="n">hashCode</span>
    <span class="o">)</span> <span class="o">+</span> <span class="n">numer</span>
  <span class="o">)</span> <span class="o">+</span> <span class="n">denom</span>
</pre></div>

<blockquote>
<ul>
<li>one thing to keep in mind when defining <code>hashCode</code> like this is that your hash code will only be as good as the hash codes you build it out of, namely the hash codes you obtain by calling <code>hashCode</code> on the relevant fields. Sometimes you may need to do something extra besides just calling <code>hashCode</code> on the field to get a useful hash code for that field. For example, if one of your fields is a collection, you probably want a hash code for that field that is base on all the elements contained in the collection. If the field is a <code>List</code>, <code>Set</code>, <code>Map</code> or <em>tuple</em>, you can simply call <code>hashCode</code> on the field, since <code>equals</code> and <code>hashCode</code> are overridden in those classes to take into account the contained elements. However, the same is not true for arrays, which do not take their elements into account when calculating <code>hashCode</code>. Thus for an array, you should treat each element of the array like an individual field of your object, calling <code>hashCode</code> on each element explicitly, or passing the array to one of the <code>hashCode</code> methods in singleton object <code>java.util.Arrays</code>
</li>
<li>if you find that particular hash code calculation is harming the performance of your program, you can consider caching the hash code. If the object is immutable, you can calculate the hash code when the object is created and store it in a field. You can easily do this by overriding <code>hashCode</code> with a <code>val</code> instead of a <code>def</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">override</span> <span class="k">val</span> <span class="n">hashCode</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span>
  <span class="mi">41</span> <span class="o">*</span> <span class="o">(</span>
    <span class="mi">41</span> <span class="o">+</span> <span class="n">numer</span>
  <span class="o">)</span> <span class="o">+</span> <span class="n">denom</span>

<span class="c1">// trades off memory for computation time, since now each instance will have one more</span>
<span class="c1">// field to hold</span>
</pre></div>

<blockquote>
<ul>
<li>given how difficult is to correctly implement an equality method, you might opt out to define your classes of comparable objects as case classes. That way, the Scala compiler will add <code>equals</code> and <code>hashCode</code> with the right properties automatically</li>
</ul>
</blockquote>

<h2>
<a name="combining-scala-and-java" class="anchor" href="#combining-scala-and-java"><span class="octicon octicon-link"></span></a>Combining Scala and Java</h2>

<blockquote>
<ul>
<li>Scala code is often used in tandem with large Java programs and frameworks, which, from time to time, runs into a few common problems</li>
</ul>
</blockquote>

<h3>
<a name="710---using-scala-from-java" class="anchor" href="#710---using-scala-from-java"><span class="octicon octicon-link"></span></a><strong>710 - Using Scala from Java</strong>
</h3>

<blockquote>
<ul>
<li>if you call Scala code from Java, it's useful to understand how the whole system works and how Scala code looks from a Java point of view</li>
</ul>
</blockquote>

<p><em>General rules</em></p>

<blockquote>
<ul>
<li>Scala is implemented as a translation to standard Java bytecode</li>
<li>as much as possible, Scala features map directly onto the equivalent Java features (e.g. classes, methods, strings, exceptions, method overloading all map directly to Java)</li>
<li>there are Scala features that has its own design. Traits, for example, have no equivalent in Java. Generic types are handled completely differently. Scala encodes language features like these using some combination of structures Java does have</li>
<li>for features that are mapped indirectly, encoding is not fixed and there is an ongoing effort to make translations as simple as possible</li>
</ul>
</blockquote>

<p><em>Value types</em></p>

<blockquote>
<ul>
<li>a value type, like <code>Int</code> can be translated in two different ways. Whenever possible, compiler translates a Scala <code>Int</code> to a Java <code>int</code> to get better performance</li>
<li>sometimes this is not possible, because the compiler is not sure whether it is translating an <code>Int</code> or some other data type (e.g. a <code>List[Any]</code> might hold only integers, but the compiler cannot be sure that's the case)</li>
<li>in cases like this the compiler uses objects and relies on wrapper classes and autoboxing</li>
</ul>
</blockquote>

<p><em>Singleton objects</em></p>

<blockquote>
<ul>
<li>translation of singleton objects uses a combination of static and instance methods</li>
<li>for every singleton object, the compiler creates a Java class with a dollar sign added to the end (e.g. for singleton <code>App</code>, compiler produces <code>App$</code>), which has all the methods and fields of the singleton object</li>
<li>the Java class also has a single static field named <code>MODULE$</code> which holds the one instance of the class that is created at runtime</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// for Scala singleton:</span>
<span class="k">object</span> <span class="nc">App</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
    <span class="n">println</span><span class="o">(</span><span class="s">"Hello, universe!"</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

</pre></div>

<div class="highlight highlight-java"><pre><span class="c1">// compiler generates Java code:</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">App</span><span class="n">$</span> <span class="kd">extends</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span> <span class="kd">implements</span> <span class="n">scala</span><span class="o">.</span><span class="na">ScalaObject</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">App$</span> <span class="n">MODULE$</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="o">{};</span>
  <span class="kd">public</span> <span class="n">App$</span><span class="o">();</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">[]);</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="n">$tag</span><span class="o">();</span>
<span class="o">}</span>

<span class="c1">// an important special case is if you have a standalone singleton object, one which does</span>
<span class="c1">// not come with a class of the same name</span>
<span class="c1">// in that case, compiler creates a Java class named 'App' that has a static forwarder</span>
<span class="c1">// method for each method of the singleton:</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">App</span> <span class="kd">extends</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span><span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">$tag</span><span class="o">();</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">[]);</span>
<span class="o">}</span>

<span class="c1">// if you, on the other hand, have a class named 'App', Scala would create a</span>
<span class="c1">// corresponding Java 'App' class to hold the members of the 'App' class you defined</span>
<span class="c1">// It would not add any forwarding methods for the same-named singleton object, and</span>
<span class="c1">// Java code would have to access the singleton via the 'MODULE$' field</span>
</pre></div>

<p><em>Traits as interfaces</em></p>

<blockquote>
<ul>
<li>compiling any trait creates a Java interface of the same name, which is usable as a Java type, and it lets you call methods on Scala objects through variables of that type</li>
<li>implementing a trait in Java is not practical, with one special case being important:</li>
<li>if you make a Scala trait that includes only abstract methods, then that trait will be translated directly to a Java interface, with no other code to worry about</li>
</ul>
</blockquote>

<h3>
<a name="713---annotations" class="anchor" href="#713---annotations"><span class="octicon octicon-link"></span></a><strong>713 - Annotations</strong>
</h3>

<blockquote>
<ul>
<li>when the compiler sees an annotation, it first processes it according to the general Scala rules, and then it does something extra for Java</li>
</ul>
</blockquote>

<p><em>Deprecation</em></p>

<blockquote>
<ul>
<li>for any method or class marked <code>@deprecated</code>, the compiler adds Java's own deprecation annotation</li>
<li>because of this, Java compiler can issue deprecation warnings when Java code accesses deprecated Scala methods</li>
</ul>
</blockquote>

<p><em>Volatile fields</em></p>

<blockquote>
<ul>
<li>same as for deprecation, thus volatile fields in Scala behave exactly according to Java's semantics, and accesses to volatile fields are sequenced precisely according to the rules specified for volatile fields in Java memory model</li>
</ul>
</blockquote>

<p><em>Serialization</em></p>

<blockquote>
<ul>
<li>all of the 3 Scala's standard serialization annotations are translated to Java equivalents</li>
<li>a <code>@serializable</code> class has Java's <code>Serializable</code> interface added to it</li>
</ul>
</blockquote>

<div class="highlight highlight-java"><pre><span class="c1">// a '@SerialVersionUID(1234L)' is converted to the following Java definition:</span>
<span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="kt">long</span> <span class="n">SerialVersionUID</span> <span class="o">=</span> <span class="mi">1234L</span>
</pre></div>

<blockquote>
<ul>
<li>any variable marked <code>@transient</code> is given the Java <code>transient</code> modifier</li>
</ul>
</blockquote>

<p><em>Exceptions thrown</em></p>

<blockquote>
<ul>
<li>Scala does not check that thrown exceptions are caught, that is, Scala has no equivalent to Java's <code>throws</code> declaration on methods</li>
<li>all Scala methods are translated to Java methods that declare no thrown exceptions</li>
<li>the reason it all still works is that the Java bytecode verifier does not check the declarations anyway. The Java compiler checks, but not the verifier</li>
<li>the reason this feature is omitted from Scala is that the Java experience with it has not been purely positive, because annotating methods with <code>throws</code> clauses is a heavy burden for developers</li>
<li>the result is that this often makes code less reliable (programmers often, in order to satisfy the compiler, either throw all they can or catch-and-release exceptions)</li>
<li>sometimes, when interfacing with Java, you may need to write Scala code that has Java-friendly annotations describing which exceptions your methods may throw, e.g. each method in Java RMI is required to mention <code>java.io.RemoteException</code> in its <code>throws</code> clause, thus, if you wish to write a RMI interface as a Scala trait with abstract methods, you would need to list <code>RemoteException</code> in the <code>throws</code> clauses for those methods</li>
<li>to accomplish this, all you have to do is mark your methods with <code>@throws</code> annotations:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// a method marked as throwing 'IOException'</span>
<span class="k">import</span> <span class="nn">java.io._</span>
<span class="k">class</span> <span class="nc">Reader</span><span class="o">(</span><span class="n">fname</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">private</span> <span class="k">val</span> <span class="n">in</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">BufferedReader</span><span class="o">(</span><span class="k">new</span> <span class="nc">FileReader</span><span class="o">(</span><span class="n">fname</span><span class="o">))</span>

  <span class="nd">@throws</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">IOException</span><span class="o">])</span>
  <span class="k">def</span> <span class="n">read</span><span class="o">()</span> <span class="k">=</span> <span class="n">in</span><span class="o">.</span><span class="n">read</span><span class="o">()</span>
<span class="o">}</span>
</pre></div>

<div class="highlight highlight-java"><pre><span class="c1">// and here is how it looks in Java:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Reader</span> <span class="kd">extends</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">Object</span> <span class="kd">implements</span>
<span class="n">scala</span><span class="o">.</span><span class="na">ScalaObject</span><span class="o">{</span>
  <span class="kd">public</span> <span class="nf">Reader</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span><span class="o">);</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="nf">read</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">java</span><span class="o">.</span><span class="na">io</span><span class="o">.</span><span class="na">IOException</span><span class="o">;</span>  <span class="c1">// proper Java 'throws'</span>
  <span class="kd">public</span> <span class="kt">int</span> <span class="n">$tag</span><span class="o">();</span>
<span class="o">}</span>
</pre></div>

<p><em>Java annotations</em></p>

<blockquote>
<ul>
<li>existing annotations from Java frameworks can be used directly in Scala code</li>
<li>any Java framework will see the annotations you write just as if you were writing Java</li>
<li>a wide variety of Java packages use annotations, e.g. <code>JUnit</code>, which, from its version 4, allows you to use annotations to indicate which parts of your code are tests</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// annotations required in some Java libraries can be used the same way in Scala:</span>
<span class="k">import</span> <span class="nn">org.junit.Test</span>
<span class="k">import</span> <span class="nn">org.junit.Assert.assertEquals</span>

<span class="k">class</span> <span class="nc">SetTest</span> <span class="o">{</span>
  <span class="nd">@Test</span>  <span class="c1">// this notation may be used instead of '@org.junit.Test', since we did import</span>
  <span class="k">def</span> <span class="n">testMultiAdd</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">set</span> <span class="k">=</span> <span class="nc">Set</span><span class="o">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span>
    <span class="n">assertEquals</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">set</span><span class="o">.</span><span class="n">size</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p><em>Writing your own annotations</em></p>

<blockquote>
<ul>
<li>to make an annotation that is visible by Java reflection, you must use Java notation and compile with <code>javac</code>
</li>
<li>for this use case, writing the annotation in Scala does not seem helpful, so the standard compiler does not support it. The reason is that Scala support would inevitably fall short of the full possibilities of Java annotations, and further, Scala will probably one day have its own reflection, in which case you would want to access Scala annotations with Scala reflection</li>
</ul>
</blockquote>

<div class="highlight highlight-java"><pre><span class="c1">// this is Java</span>
<span class="kn">import</span> <span class="nn">java.lang.annotation.*</span><span class="o">;</span>
<span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
<span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">)</span>
<span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Ignore</span><span class="o">{}</span>
</pre></div>

<div class="highlight highlight-scala"><pre><span class="c1">// after compiling the above with 'javac', we can use the annotations:</span>
<span class="k">object</span> <span class="nc">Tests</span> <span class="o">{</span>
  <span class="nd">@Ignore</span>  <span class="c1">// ignores the method even though its name starts with 'test'</span>
  <span class="k">def</span> <span class="n">testData</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="o">-</span><span class="mi">5</span><span class="o">)</span>

  <span class="c1">// test methods:</span>
  <span class="k">def</span> <span class="n">test1</span> <span class="o">{</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">testData</span> <span class="o">==</span> <span class="o">(</span><span class="n">testData</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">testData</span><span class="o">.</span><span class="n">tail</span><span class="o">))</span>
  <span class="o">}</span>
  <span class="k">def</span> <span class="n">test2</span> <span class="o">{</span>
    <span class="n">assert</span><span class="o">(</span><span class="n">testData</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">testData</span><span class="o">.</span><span class="n">head</span><span class="o">))</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>to see when these annotations are present you can use the Java reflection API:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">for</span> <span class="o">{</span>
  <span class="n">method</span> <span class="k">&lt;-</span> <span class="nc">Tests</span><span class="o">.</span><span class="n">getClass</span><span class="o">.</span><span class="n">getMethods</span>
  <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">getName</span><span class="o">.</span><span class="n">startsWith</span><span class="o">(</span><span class="s">"test"</span><span class="o">)</span>
  <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">getAnnotation</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">Ignore</span><span class="o">])</span> <span class="o">==</span> <span class="kc">null</span>
<span class="o">}</span> <span class="o">{</span>
  <span class="n">println</span><span class="o">(</span><span class="s">"found a test method: "</span> <span class="o">+</span> <span class="n">method</span><span class="o">)</span>
<span class="o">}</span>

<span class="c1">// this code in action:</span>
<span class="n">$</span> <span class="n">javac</span> <span class="nc">Ignore</span><span class="o">.</span><span class="n">java</span>
<span class="n">$</span> <span class="n">scalac</span> <span class="nc">Tests</span><span class="o">.</span><span class="n">scala</span>
<span class="n">$</span> <span class="n">scalac</span> <span class="nc">FindTests</span><span class="o">.</span><span class="n">scala</span>
<span class="n">$</span> <span class="n">scala</span> <span class="nc">FindTests</span>
<span class="c1">//&gt; found a test method: public void Tests$.test2()</span>
<span class="c1">//&gt; found a test method: public void Tests$.test1()</span>
</pre></div>

<h3>
<a name="718---existential-types" class="anchor" href="#718---existential-types"><span class="octicon octicon-link"></span></a><strong>718 - Existential types</strong>
</h3>

<blockquote>
<ul>
<li>all Java types have a Scala equivalent, which is necessary so that Scala code can access any Java class</li>
<li>most of the time the translation is straightforward, <code>Pattern</code> in Java is <code>Pattern</code> in Scala, <code>Iterator&lt;Component&gt;</code> in Java is <code>Iterator[Component]</code> in Scala, but for some cases Scala types we mentioned so far are not enough</li>
<li>for example, what can be done with Java wildcard type parameters such as <code>Iterator&lt;?&gt;</code> or <code>Iterator&lt;? extends Component&gt;</code>?</li>
<li>also, what can be done with raw types like <code>Iterator</code>, where the type parameter is omitted?</li>
<li>for wildcard and raw types Scala uses an extra kind of type called <strong>existential type</strong>
</li>
<li>existential types are fully supported part of the language, but in practice they are mainly used when accessing Java types from Scala (we are covering this mostly so that you can understand error messages when your Scala code accesses Java code)</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// the general form of an existential type:</span>
<span class="cm">/* type */</span> <span class="k">forSome</span> <span class="o">{</span> <span class="cm">/* declarations */</span> <span class="o">}</span>

<span class="c1">// the 'type' part is an arbitrary Scala type</span>
<span class="c1">// the 'declarations' part is a list of abstract 'vals' and types</span>
</pre></div>

<blockquote>
<ul>
<li>the interpretation is that the declared variables and types exist but are unknown, just like abstract members of a class</li>
<li>the 'type' is then allowed to refer to the declared variables and types even though it is unknown what they refer to</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// Java 'Iterator&lt;?&gt;' would be written in Scala as:</span>
<span class="nc">Iterator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">T</span> <span class="o">}</span>  <span class="c1">// an iterator of T's for some type 'T'</span>

<span class="c1">// Java 'Iterator&lt;? extends Component&gt;' would be:</span>
<span class="nc">Iterator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Component</span> <span class="o">}</span>
<span class="c1">// iterator of 'T' for some type 'T' that is a subtype of 'Component'</span>

<span class="c1">// there is a shorter way to write this examples with placeholder notation:</span>
<span class="nc">Iterator</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>
<span class="c1">// means the same as </span>
<span class="nc">Iterator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">T</span> <span class="o">}</span>

<span class="c1">// similarly:</span>
<span class="nc">Iterator</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">forSome</span> <span class="o">{</span> <span class="k">type</span> <span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">Component</span> <span class="o">}</span>
<span class="c1">// is the same as:</span>
<span class="nc">Iterator</span><span class="o">[</span><span class="k">_</span> <span class="k">&lt;:</span> <span class="kt">Component</span><span class="o">]</span>
</pre></div>

<blockquote>
<ul>
<li>
<em>placeholder syntax</em> is similar to the placeholder syntax for function literals, where, if you use an underscore in place of an expression, then Scala creates a function literal for you. Here, when you use an underscore in place of a type, Scala makes an <em>existential type</em> for you, where each underscore becomes one type parameter in a <code>forSome</code> clause</li>
<li>so if you use multiple underscores in the same type, you will get the effect of a <code>forSome</code> clause with multiple types in it</li>
</ul>
</blockquote>

<div class="highlight highlight-java"><pre><span class="c1">// existential types usage example:</span>
<span class="c1">// Java class with wildcards:</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Wild</span> <span class="o">{</span>
  <span class="n">Collection</span><span class="o">&lt;?&gt;</span> <span class="n">contents</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">Collection</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">stuff</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;();</span>
    <span class="n">stuff</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"a"</span><span class="o">);</span>
    <span class="n">stuff</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"b"</span><span class="o">);</span>
    <span class="n">stuff</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">"see"</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">stuff</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<div class="highlight highlight-scala"><pre><span class="c1">// if you access the above class in Scala:</span>
<span class="k">val</span> <span class="n">contents</span> <span class="k">=</span> <span class="o">(</span><span class="k">new</span> <span class="nc">Wild</span><span class="o">).</span><span class="n">contents</span>
<span class="c1">// java.util.Collection[?0] for Some { type ?0 } = [a, b, see]</span>
<span class="n">contents</span><span class="o">.</span><span class="n">size</span><span class="o">()</span>  <span class="c1">// Int = 3</span>
</pre></div>

<h3>
<a name="722---using-synchronized" class="anchor" href="#722---using-synchronized"><span class="octicon octicon-link"></span></a><strong>722 - Using <code>synchronized</code></strong>
</h3>

<blockquote>
<ul>
<li>for compatibility's sake, Scala provides access to Java's concurrent primitives (<code>wait</code>, <code>notify</code> and <code>notifyAll</code> may all be called in Scala and have the same meaning as in Java)</li>
<li>technically, Scala doesn't have the <code>synchronized</code> keyword, instead it has a predefined <code>synchronized</code> method that can be called like this:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">var</span> <span class="n">counter</span> <span class="k">=</span> <span class="mi">0</span>
<span class="n">synchronized</span> <span class="o">{</span>
  <span class="c1">// one thread at a time</span>
  <span class="n">counter</span> <span class="k">=</span> <span class="n">counter</span> <span class="o">+</span> <span class="mi">1</span>
<span class="o">}</span>
</pre></div>

<h3>
<a name="722---compiling-scala-and-java-together" class="anchor" href="#722---compiling-scala-and-java-together"><span class="octicon octicon-link"></span></a><strong>722 - Compiling Scala and Java together</strong>
</h3>

<blockquote>
<ul>
<li>usually, when you compile Scala code that depends on Java code, you first build the java code to class files and then you build the Scala code, putting the Java class files on the classpath</li>
<li>this approach doesn't work if the Java code has references back to Scala code. In that case one side will have unsatisfied external references</li>
<li>to support such builds, Scala allows compiling against Java source code as well as Java class files. All you have to do is put the Java source files on the command line as if they were scala files. Then, Scala compiler won't compile those Java files, but it will scan them to see what they contain</li>
<li>so the right sequence is to first compile Scala using Java source files, and then compile Java code using Scala class files:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="n">$</span> <span class="n">scalac</span> <span class="o">-</span><span class="n">d</span> <span class="n">bin</span> <span class="nc">InventoryAnalysis</span><span class="o">.</span><span class="n">scala</span> <span class="nc">InventoryItem</span><span class="o">.</span><span class="n">java</span> <span class="nc">Inventory</span><span class="o">.</span><span class="n">java</span>
<span class="n">$</span> <span class="n">javac</span> <span class="o">-</span><span class="n">cp</span> <span class="n">bin</span> <span class="o">-</span><span class="n">d</span> <span class="n">bin</span> <span class="nc">Inventory</span><span class="o">.</span><span class="n">java</span> <span class="nc">InventoryItem</span><span class="o">.</span><span class="n">java</span> <span class="nc">InventoryManagement</span><span class="o">.</span><span class="n">java</span>
<span class="n">$</span> <span class="n">scala</span> <span class="o">-</span><span class="n">cp</span> <span class="n">bin</span> <span class="nc">InventoryManagement</span>
<span class="c1">//&gt; Most expensive item = sprocket($4.99)</span>
</pre></div>

<h2>
<a name="actors-and-concurrency" class="anchor" href="#actors-and-concurrency"><span class="octicon octicon-link"></span></a>Actors and Concurrency</h2>

<blockquote>
<ul>
<li>Java's native, thread-based concurrency support is hard to work with and prone for errors, especially when programs get large and complex</li>
<li>Scala augments Java's concurrency by adding <strong>actors</strong>
</li>
<li>actors provide a concurrency model that is easier to work with and can help you avoid many of the difficulties of using Java's native concurrency model</li>
</ul>
</blockquote>

<h2>
<a name="724---java-concurrency-troubles" class="anchor" href="#724---java-concurrency-troubles"><span class="octicon octicon-link"></span></a><strong>724 - Java concurrency troubles</strong>
</h2>

<blockquote>
<ul>
<li>Java's built-in threading model is based on shared data and locks</li>
<li>each object is associated with a logical <em>monitor</em>, which is used to control multi-threaded access to data. In this model, you decide what data will be shared by multiple threads and enclose those, shared sections of the code with <code>sinchronized</code> blocks or methods</li>
<li>the problem with this model is that, in each point in a program, you must reason about what data you're modifying or accessing that might be modified or accessed by other threads. At each method call, you must reason about what locks it will try to hold, and convince yourself that it will not deadlock while trying to obtain those locks</li>
<li>making things even worse, testing is not reliable with multi-threaded code. Since threads are non-deterministic, you might successfully test a program a thousand times, and yet still the program could go wrong</li>
<li>with this model, you must get it right, i.e. avoid deadlocks and race conditions through reason alone</li>
</ul>
</blockquote>

<h2>
<a name="725---actors-and-message-passing" class="anchor" href="#725---actors-and-message-passing"><span class="octicon octicon-link"></span></a><strong>725 - Actors and message passing</strong>
</h2>

<blockquote>
<ul>
<li>Scala's actors library addresses the fundamental problem by providing an alternative, <strong>share-nothing</strong>, message-passing model</li>
<li>an <strong>actor</strong> is a thread-like entity that has a <strong>mailbox</strong> for receiving messages</li>
<li>to implement an actor, you subclass <code>scala.actors.Actor</code> and implement the <code>act</code> method:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">import</span> <span class="nn">scala.actors._</span>
<span class="k">object</span> <span class="nc">Shakespeare</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">act</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"To be or not to be. Is that a question?"</span><span class="o">)</span>
      <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">3000</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// you start an actor by invoking its 'start' method</span>
<span class="nc">Shakespeare</span><span class="o">.</span><span class="n">start</span><span class="o">()</span>
<span class="c1">// To be or not to be. Is that a question?</span>
<span class="c1">// To be or not to be. Is that a question?</span>
</pre></div>

<blockquote>
<ul>
<li>actors run completely independently from one another:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">import</span> <span class="nn">scala.actors._</span>
<span class="k">object</span> <span class="nc">Hamlet</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">act</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">println</span><span class="o">(</span><span class="s">"Yes, that was a question."</span><span class="o">)</span>
      <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">3000</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="nc">Shakespeare</span><span class="o">.</span><span class="n">start</span><span class="o">()</span>
<span class="nc">Hamlet</span><span class="o">.</span><span class="n">start</span><span class="o">()</span>
<span class="c1">// To be or not to be. Is that a question?</span>
<span class="c1">// Yes, that was a question.</span>
<span class="c1">// To be or not to be. Is that a question?</span>
<span class="c1">// To be or not to be. Is that a question?</span>
<span class="c1">// Yes, that was a question.</span>
<span class="c1">// Yes, that was a question.</span>
</pre></div>

<blockquote>
<ul>
<li>you can also create an actor using a utility method named <code>actor</code> in object <code>scala.actors.Actor</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">import</span> <span class="nn">scala.actors.Actor._</span>
<span class="c1">// this actor starts immediately when it's defined (no need to call 'start()' method)</span>
<span class="k">val</span> <span class="n">desdemona</span> <span class="k">=</span> <span class="n">actor</span> <span class="o">{</span>
  <span class="k">for</span> <span class="o">(</span><span class="n">i</span> <span class="k">&lt;-</span> <span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">print</span><span class="o">(</span><span class="s">"I rule! "</span><span class="o">)</span>
    <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
  <span class="o">}</span>  
<span class="o">}</span>

<span class="c1">// I rule! I rule! I rule! </span>
</pre></div>

<blockquote>
<ul>
<li>actors communicate by sending each other <strong>messages</strong>
</li>
<li>message is sent using <code>!</code> method:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="nc">Hamlet</span> <span class="o">!</span> <span class="s">"hi there"</span>
</pre></div>

<blockquote>
<ul>
<li>nothing happens in this case, because <code>Hamlet</code> is too busy acting to process its messages, and so the <code>"hi there"</code> message sits in its mailbox unread</li>
<li>an actor can wait for new messages in its mailbox:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">val</span> <span class="n">parrot</span> <span class="k">=</span> <span class="n">actor</span> <span class="o">{</span>
  <span class="k">while</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">receive</span> <span class="o">{</span>
      <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<blockquote>
<ul>
<li>when an actor sends a message, it does not block, and when an actor receives a message, it is not interrupted. The message waits in the receiving actor's mailbox until the actor calls <code>receive</code>, passing in a partial function </li>
<li>remember? <em>Partial function</em>  is not a full function, i.e. it might not be defined over all input values. <em>Partial function literal</em> is expressed as a series of <code>match</code> cases, so it looks like a <code>match</code> expression without the <code>match</code> keyword. It is actually an instance of the <code>PartialFunction</code> trait)</li>
<li>in addition to <code>apply</code> method that takes one argument, a partial function offers <code>isDefinedAt</code> method (which also takes one argument) that returns <code>true</code> if the partial function can <em>"handle"</em> the passed value, which then means that the value is safe to pass to <code>apply</code>. If <code>isDefinedAt</code> returns <code>false</code> and that value is passed to <code>apply</code>, then <code>apply</code> throws an exception</li>
<li>an actor will only process messages matching one of the cases in the partial function passed to <code>receive</code>
</li>
<li>for each message in the mailbox, <code>receive</code> first invokes <code>isDefinedAt</code> on the passed partial function to determine whether it has a case that will match and handle the message. The <code>receive</code> method then chooses the first message in the mailbox for which <code>isDefinedAt</code> returns <code>true</code>, and pass that message to the partial function's <code>apply</code> method, which then handles the message. If the mailbox contains no message for which <code>isDefinedAt</code> returns <code>true</code>, the actor on which <code>receive</code> was invoked will block until a matching message arrives</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// actor that only handles ints:</span>
<span class="k">val</span> <span class="n">intParrot</span> <span class="k">=</span> <span class="n">actor</span> <span class="o">{</span>
  <span class="n">receive</span> <span class="o">{</span>
    <span class="k">case</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="n">println</span><span class="o">(</span><span class="s">"got int: "</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="n">intParrot</span> <span class="o">!</span> <span class="s">"hello"</span>  <span class="c1">// silently ignores it</span>
<span class="n">intParrot</span> <span class="o">!</span> <span class="n">math</span><span class="o">.</span><span class="nc">Pi</span>  <span class="c1">// silently ignores it</span>
<span class="n">intParrot</span> <span class="o">!</span> <span class="mi">8</span>        <span class="c1">// got int: 8</span>
</pre></div>

<h3>
<a name="729---treating-native-threads-as-actors" class="anchor" href="#729---treating-native-threads-as-actors"><span class="octicon octicon-link"></span></a><strong>729 - Treating native threads as actors</strong>
</h3>

<blockquote>
<ul>
<li>the actor subsystem manages one or more native threads for its own use. So long as you work with an explicit actor that you define, you don't need to think much about how they map to threads</li>
<li>the other direction is also supported, every native thread is also usable as an actor, however, you cannot use <code>Thread.currentThread</code> directly, because it does not have the necessary methods. Instead, you should use <code>Actor.self</code> if you want to view the current thread as an actor</li>
<li>this facility is especially useful for debugging actors from the interactive shell:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">import</span> <span class="nn">scala.actors.Actor._</span>
<span class="n">self</span> <span class="o">!</span> <span class="s">"hello"</span>
<span class="n">self</span><span class="o">.</span><span class="n">receive</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">}</span>  <span class="c1">// Any = hello</span>
<span class="c1">// the `receive` method returns the value computed by the partial function passed to it,</span>
<span class="c1">// and in this case, the partial function returns the message itself, so the received</span>
<span class="c1">// message ends up being printed out by the interpreter</span>
</pre></div>

<blockquote>
<ul>
<li>if you use <code>receive</code> in the interpreter, the <code>receive</code> will block the shell until a message arrives (in case of <code>self.receive</code> this could mean waiting forever), thus, when using this technique, it's better to use a variant called <code>receiveWithin</code>, which allows you to specify a timeout in milliseconds:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="n">self</span><span class="o">.</span><span class="n">receiveWithin</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">}</span>  <span class="c1">// wait for 1s</span>
<span class="c1">// Any = TIMEOUT</span>

<span class="c1">// 'receiveWithin' processes mailbox message or waits until for new messages for </span>
<span class="c1">// specified number of millis</span>
</pre></div>

<h3>
<a name="730---better-performance-through-thread-reuse-react" class="anchor" href="#730---better-performance-through-thread-reuse-react"><span class="octicon octicon-link"></span></a><strong>730 - Better performance through thread reuse: <code>react</code></strong>
</h3>

<blockquote>
<ul>
<li>threads are not cheap! They consume enough memory that typical Java VMs, which normally hosts millions of objects, can have only thousands of threads. Moreover, switching threads often takes hundreds if not thousands of processor cycles</li>
<li>to help you conserve threads, Scala provides an alternative the the usual <code>receive</code> method called <code>react</code>. Like <code>receive</code>, <code>react</code> takes a partial function, but unlike <code>receive</code> it does not return after it finds and processes a message. Its result type is <code>Nothing</code>. It evaluates the message handler and that's it (throws an exception that's caught behind the scenes)</li>
<li>since <code>react</code> doesn't need to return, the implementation doesn't need to preserve the call stack of the current thread. Instead, the library can reuse the current thread for the next actor that wakes up. This approach is so effective that if every actor in a program used <code>react</code>, only a single thread would be used (Scala utilizes all processor cores that it can)</li>
</ul>
</blockquote>

<p><em>In practice, programs need at least a few <code>receive</code>s, but you should try to use <code>react</code> whenever possible</em>  </p>

<blockquote>
<ul>
<li>because <code>react</code> does not return, the message handler you pass it must now both, process that message and arrange to do all of the actor's remaining work. A common way to do this is to have a top-level work method (such as <code>act</code> itself), that the message handler calls when it finishes</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">object</span> <span class="nc">NameResolver</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
  <span class="k">import</span> <span class="nn">java.net.</span><span class="o">{</span><span class="nc">InetAddress</span><span class="o">,</span> <span class="nc">UnknownHostException</span><span class="o">}</span>

  <span class="k">def</span> <span class="n">act</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">react</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">actor</span><span class="k">:</span> <span class="kt">Actor</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">actor</span> <span class="o">!</span> <span class="n">getIp</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>
        <span class="n">act</span><span class="o">()</span>
      <span class="k">case</span> <span class="s">"EXIT"</span> <span class="k">=&gt;</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"Name resolver over and out."</span><span class="o">)</span>
        <span class="c1">// quit</span>
      <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"Unhandled message: "</span> <span class="o">+</span> <span class="n">msg</span><span class="o">)</span>
        <span class="n">act</span><span class="o">()</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="k">def</span> <span class="n">getIp</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">InetAddress</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="nc">Some</span><span class="o">(</span><span class="nc">InetAddress</span><span class="o">.</span><span class="n">getByName</span><span class="o">(</span><span class="n">name</span><span class="o">))</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">{</span>
      <span class="k">case</span> <span class="k">_:</span> <span class="kt">UnknownHostException</span> <span class="o">=&gt;</span> <span class="nc">None</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="nc">NameResolver</span><span class="o">.</span><span class="n">start</span><span class="o">()</span>  <span class="c1">// scala.actors.Actor = NameResolver$@2d325da0</span>
<span class="nc">NameResolver</span> <span class="o">!</span> <span class="o">(</span><span class="s">"www.scala-lang.org"</span><span class="o">,</span> <span class="n">self</span><span class="o">)</span>
<span class="n">self</span><span class="o">.</span><span class="n">receiveWithin</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">}</span> <span class="c1">// Any = Some(www.google.com/83.139.106.223)</span>
</pre></div>

<blockquote>
<ul>
<li>this coding pattern is so common with event-base actors, that there's a special support in the library for it. The <code>Actor.loop</code> executes a block of code repeatedly, even if the code calls <code>react</code>:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="k">def</span> <span class="n">act</span><span class="o">()</span> <span class="o">{</span>
  <span class="n">loop</span> <span class="o">{</span>
    <span class="n">react</span> <span class="o">{</span>
      <span class="k">case</span> <span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">,</span> <span class="n">actor</span><span class="k">:</span> <span class="kt">Actor</span><span class="o">)</span> <span class="k">=&gt;</span>
        <span class="n">actor</span> <span class="o">!</span> <span class="n">getIp</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>
      <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"Unhandled message: "</span> <span class="o">+</span> <span class="n">msg</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<h3>
<a name="734---how-react-works" class="anchor" href="#734---how-react-works"><span class="octicon octicon-link"></span></a><strong>734 - How <code>react</code> works</strong>
</h3>

<blockquote>
<ul>
<li>it has a return type of <code>Nothing</code> and it never returns normally, i.e. always ends with an exception</li>
<li>conceptually, when you call <code>start</code> on an actor, the <code>start</code> method will in some way arrange things so that some thread will eventually call <code>act</code> on that actor. If the <code>act</code> method invokes <code>react</code>, the <code>react</code> method looks in the actor's mailbox for a message that the passed partial function can handle</li>
<li>
<code>receive</code> does this the same way, passes candidate messages to the partial function's <code>isDefinedAt</code> method</li>
<li>if it finds a message that can be handled, <code>react</code> will schedule the handling of that message for later execution and throw an exception</li>
<li>if it doesn't find one, it will place the actor in <em>cold storage</em> to be resurrected if and when it gets more messages in its mailbox, and then throw an exception</li>
<li>in either case, <code>react</code> will complete abruptly with this exception and so will <code>act</code>
</li>
<li>the thread that invoked <code>act</code> will catch the exception, forget about the actor, and move on to do other things</li>
<li>this explains why, if you want <code>react</code> to handle more than the first message, you have to call <code>act</code> again from inside your partial function, or use some other means to get <code>react</code> invoked again</li>
</ul>
</blockquote>

<h3>
<a name="733---good-actors-style" class="anchor" href="#733---good-actors-style"><span class="octicon octicon-link"></span></a><strong>733 - Good actors style</strong>
</h3>

<p><em>Actors should not block</em></p>

<blockquote>
<ul>
<li>while an actor blocks, some other actor might make a request on it, and since it's blocked, it won't even notice the request. In the worst case, even a deadlock may happen, with multiple actors blocked as they each wait for some other blocked actor to respond</li>
<li>instead of blocking, an actor should arrange for some message to arrive, designating that an action is ready to be taken. This rearrangement will often require help of other actors. E.g. instead of calling <code>Thread.sleep(time)</code>, you could create a helper actor that sleeps and then sends a message back when enough time has elapsed:</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="n">actor</span> <span class="o">{</span>
  <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="n">time</span><span class="o">)</span>
  <span class="n">mainActor</span> <span class="o">!</span> <span class="s">"wakeup!"</span>
<span class="o">}</span>
<span class="c1">// this actor blocks, but since it'll never receive a message that's OK</span>
</pre></div>

<blockquote>
<ul>
<li>the main actor remains available to answer new requests</li>
<li>the <code>emoteLater</code> method demonstrates the use of this idiom. It creates a new actor that will do the <code>sleep</code> so that the main actor does not block</li>
<li>to ensure that the actor will send the <code>Emote</code> message to the correct actor, it is prudent to evaluate <code>self</code> in the scope of the main actor instead of the scope of the helper actor</li>
<li>because this actor does not block in <code>sleep</code>, it can continue to do other work while waiting for its next time to emote</li>
</ul>
</blockquote>

<div class="highlight highlight-scala"><pre><span class="c1">// actor that uses helper actor to avoid blocking itself (echoes messages while waiting)</span>
<span class="k">val</span> <span class="n">sillyActor2</span> <span class="k">=</span> <span class="n">actor</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">emoteLater</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">mainActor</span> <span class="k">=</span> <span class="n">self</span>
    <span class="n">actor</span> <span class="o">{</span>
      <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>
      <span class="n">mainActor</span> <span class="o">!</span> <span class="s">"Emote"</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="k">var</span> <span class="n">emoted</span> <span class="k">=</span> <span class="mi">0</span>
  <span class="n">emoteLater</span><span class="o">()</span>

  <span class="n">loop</span> <span class="o">{</span>
    <span class="n">react</span> <span class="o">{</span>
      <span class="k">case</span> <span class="s">"Emote"</span> <span class="k">=&gt;</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"I'm really acting!"</span><span class="o">)</span>
        <span class="n">emoted</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">emoted</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="o">)</span>
          <span class="n">emoteLater</span><span class="o">()</span>
      <span class="k">case</span> <span class="n">msg</span> <span class="k">=&gt;</span>
        <span class="n">println</span><span class="o">(</span><span class="s">"Received: "</span> <span class="o">+</span> <span class="n">msg</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></div>

<p><em>Communicate with actors only via messages</em></p>

<blockquote>
<ul>
<li>the key way the actors model addresses the difficulties of the shared data and locks is by providing a safe space, the actor's <code>act</code> method, where you can think sequentially, i.e. actors allow you to write a multi-threaded program as a bunch of independent single-threaded programs that communicate with each other via asynchronous messages. So, all this works only if you abide by this simple rule, that the messages are the only way you let your actors communicate</li>
<li>nevertheless, Scala actors library gives you the choice of using both message passing and shared data &amp; locks in the same program. A good example is multiple actors to share a reference to <code>ConcurrentHashMap</code> (instead of using a single map owner actor and sending async messages to it) and alter the map synchronously - given that CHM is already implemented in Java concurrency library, thus it's safe</li>
</ul>
</blockquote>
        </section>

        <aside id="sidebar">

          <a href="https://github.com/mbonaci/scala/zipball/master" class="button">
            <small>Bring it home as</small>
            .zip file
          </a>
          <a href="https://github.com/mbonaci/scala/tarball/master" class="button">
            <small>Bring it home as</small>
            .tar.gz file
          </a>

          <p class="repo-owner">Maintained by <a href="https://github.com/mbonaci">mbonaci</a>.</p>
          
          <!-- twitter follow -->
          <a href="https://twitter.com/markobonaci" class="twitter-follow-button" data-show-count="true">Follow @markobonaci</a>
          <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>

          
          <p class="page-built"><small>This page was built on <a href="pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>, customized by <a href="http://twitter.com/markobonaci">mbonaci</a>.</small></p>
          
          <p class="index-title">index</p>
          <p class="index">
            <a href="#scala-type-hierarchy">/// Scala type hierarchy</a><br>
            <a href="#basic-types-and-operations">/// Basic Types and Operations</a><br>
            <a href="#functional-objects">/// Functional Objects</a><br>
            <a href="#built-in-control-structures">/// Built-in Control Structures</a><br>
            <a href="#functions-and-closures">/// Functions and Closures</a><br>
            <a href="#control-abstractions">/// Control Abstractions</a><br>
            <a href="#composition-and-inheritance">/// Composition and Inheritance</a><br>
            <a href="#scalas-hierarchy">/// Scala's Hierarchy</a><br>
            <a href="#traits">/// Traits</a><br>
            <a href="#packages-and-imports">/// Packages and Imports</a><br>
            <a href="#assertions-and-unit-testing">/// Assertions and Unit Testing</a><br>
            <a href="#case-classes-and-pattern-matching">/// Case Classes and Pattern Matching</a><br>
            <a href="#working-with-lists">/// Working with Lists</a><br>
            <a href="#collections">/// Collections</a><br>
            <a href="#stateful-objects">/// Stateful Objects</a><br>
            <a href="#type-parameterization">/// Type Parameterization</a><br>
            <a href="#abstract-members">/// Abstract Members</a><br>
            <a href="#implicit-conversions-and-parameters">/// Implicit Conversions and Parameters</a><br>
            <a href="#implementing-lists">/// Implementing Lists</a><br>
            <a href="#for-expressions-revisited">/// For Expressions Revisited</a><br>
            <a href="#the-scala-collections-api">/// The Scala Collections API</a><br>
            <a href="#the-architecture-of-scala-collections">/// The architecture of Scala collections</a><br>
            <a href="#extractors">/// Extractors</a><br>
            <a href="#annotations">/// Annotations</a><br>
            <a href="#working-with-xml">/// Working with XML</a><br>
            <a href="#modular-programming-using-objects">/// Modular programming using objects</a><br>
            <a href="#object-equality">/// Object equality</a><br>
            <a href="#combining-scala-and-java">/// Combining Scala and Java</a><br>
            <a href="#actors-and-concurrency">/// Actors and Concurrency</a><br>
             
          
          
        </aside>
      </div>
    </div>

          <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-43640202-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
          

  </body>
</html>