{"name":"Java developer's Scala cheatsheet","tagline":"Scala reference","body":"Shamelessly ripped of from [Programming in Scala, second edition](http://www.artima.com/shop/programming_in_scala_2ed). I did ask for permission, though.  \r\nBasically, while I'm going through the book, I'm taking notes and pushing them here, so I can later use this page as a Scala quick reference.\r\nIf you, by any incredible chance, find any of this useful, please do buy the book (no, I don't get the kick back. As you can see, the book link is clean :)  \r\n\r\n### Scala type hierarchy\r\n![Scala class hierarchy image](https://github.com/mbonaci/scala/blob/master/resources/Scala-class-hierarchy.png?raw=true)\r\n\r\n### Basic Types and Operations\r\n**127 -** The convention is to include empty parentheses when invoking a method only if that method has side effects\r\n\r\n> - **Pure methods** are methods that don't have any side effects and don't depend on mutable state (226) \r\n> - if the function you're calling performs an operation, use the parentheses, but if it merely provides access to a property, leave out the parentheses\r\n\r\n**127 - Postfix operator:** A method that takes no arguments can be called like this: `\"some String\" toLowerCase`  \r\n**127 - Integral types:** `Int`, `Long`, `Byte`, `Short`, `Char`  \r\n**135 - Operator precedence:**\r\n\r\n>  `(all other special characters)`  \r\n>  `*` `/` `%`  \r\n>  `+` `-`  \r\n>  `:`  \r\n>  `=` `!`  \r\n>  `<` `>`  \r\n>  `&`  \r\n>  `ˆ`   - binary xor  \r\n>  `|`  \r\n>  `(all letters)`  \r\n>  `(all assignment operators)`  \r\n\r\n**136 - Operator precedence** is based on the first character of the method used in operator notation, with one exception: If an operator ends with a `=`, and the operator is not one of the comparison operators `<=`, `>=`, `==`, or `!=`, then the precedence of the operator is the same as that of simple assignment `=`, which is last in the list. E.g. `+=`  \r\n**136 - Associativity**: any method that ends in a `:` character is invoked on its right operand, passing in the left operand. Methods that end in any other character are invoked on their left operand, passing in the right operand. So `a * b` yields `a.*(b)`, but `a ::: b` yields `b.:::(a)`  \r\n**137 -** `a ::: b ::: c` is treated as `a ::: (b ::: c)` (list concatenation)\r\n\r\n### Functional Objects\r\n**141 - Class parameters**: Any code placed in the class body (outside methods) will be placed in the *primary constructor*. When declaring a class you can drop empty `{}`  \r\n**143 - Precondition** is a constraint on values passed into a method or constructor (E.g. `require(d != 0)` in the class body will throw `IllegalArgumentException: requirement failed` when `0` is passed as `d`)  \r\n**144 -** If **Class parameters** are only used inside constructors, the Scala compiler will not create corresponding fields for them  \r\n**146 - Auxiliary constructors** - constructors other than the primary constructor\r\n\r\n> - every *auxiliary constructor* must invoke another constructor **of the same class** (like Java, only Java can also call superclass's constructor instead) as its first action. That other constructor must textually come before the calling constructor\r\n\r\n**152 -** The convention is to use camel case for constants, such as `XOffset`  \r\n**153 -** The Scala compiler will internally “mangle” operator identifiers to turn them into legal Java identifiers with embedded `$` characters. For instance, the identifier `:->` would be represented internally as `$colon$minus$greater`. If you ever wanted to access this identifier from Java code, you'd need to use this internal representation  \r\n**153 - Mixed identifier** consists of an alphanumeric identifier, which is followed by an underscore and an operator identifier, e.g. `unary_+` (used to support _properties_)  \r\n**153 - Literal identifier** is an arbitrary string enclosed in back ticks. Used to tell Scala to treat a keyword as an ordinary identifier, e.g., writing `Thread.'yield'()` treats `yield` as an identifier rather than a keyword  \r\n**156 - Implicit conversion** definition:\r\n\r\n```scala\r\nimplicit def intToRational(x: Int) = new Rational(x)\r\n```\r\n> - for an implicit conversion to work, it needs to be in scope. If you place the implicit method definition inside the class `Rational`, it won't be in scope\r\n\r\n### Built-in Control Structures\r\n**163 - Assignment** always results with the **unit value**, `()`  \r\n**164 -** In `for (file <- files)` the `<-` is called a **generator**. In each iteration, a new `val` named `file` is initialized with an element value  \r\n**164 -** The `Range` type: `4 to 8`. If you don't want upper bound: `4 until 8`  \r\n**166 - Filter:** `for (file <- files if file.getName.endsWith(\".scala\"))`\r\n\r\n```scala\r\n// multiple filters example:\r\nfor (\r\n  file <- files  // files is a previously defined method that returns array of files\r\n  if file.isFile\r\n  if file.getName.endsWith(\".scala\")\r\n) println(file)\r\n```\r\n\r\n**167 - Nested loops** and **mid-stream variable binding** example with _generators_ and _filters_\r\n\r\n```scala\r\n// curly braces may be used instead of parentheses\r\n// the compiler does not infer semicolons inside regular parentheses\r\ndef grep(pattern: String) =\r\n  for {\r\n    file <- files if file.getName.endsWith(\".scala\")  // semicolons inferred\r\n    line <- fileLines(file)\r\n    trimmed = line.trim  // mid-stream variable\r\n    if trimmed.matches(pattern)\r\n  } println(file + \": \" + trimmed)\r\n```\r\n\r\n**168 - `yield`** keyword makes `for` clauses produce a value (of the same type as the expression iterated over). Syntax: `for clauses yield body`  \r\n**174 - `match case`**\r\n\r\n> - unlike Java's `select case`, there is no fall through, `break` is implicit and `case` expression can contain any type of value\r\n> - `_` is a placeholder for *completely unknown value*\r\n\r\n```scala\r\nval target = firstArg match {  // firstArg is a previously initialized val\r\n  case \"salt\" => println(\"pepper\")\r\n  case \"chips\" => println(\"salsa\")\r\n  case \"eggs\" => println(\"bacon\")\r\n  case _ => println(\"waat?\")\r\n}\r\n```\r\n\r\n**175 -** Scala doesn't have `break`, nor does it have `continue` statement  \r\n**180 -** Unlike Java, Scala supports *inner scope variable shadowing*\r\n\r\n### Functions and Closures\r\n**186 - Local functions** are functions inside other functions. They are visible only in their enclosing block  \r\n**188 - Function literal** example: `(x: Int) => x + 1`  \r\n**188 -** Every function value is an instance of some class that extends one of `FunctionN` traits that has an `apply` method used to invoke the function (`Function0` for functions with no params, `Function1` for functions with 1 param, ...)  \r\n**189 - `foreach`** is a method of `Traversable` trait (supertrait of `List`, `Set`, `Array` and `Map`) which takes a function as an argument and applies it to all elements  \r\n**190 - `filter`** method takes a function that maps each element to true or false, e.g. `someNums.filter((x: Int) => x > 0)`  \r\n**190 - Target typing** - Scala infers type by examining the way the expression is used, e.g. `filter` example can be written: `someNums.filter(x => x > 0)`  \r\n**191 - Placeholder** allows you to write: `someNums.filter(_ > 0)`\r\n\r\n> - only if each function parameter appears in function literal only once (one placeholder for each param, sequentially)\r\n> - sometimes the compiler might not have enough info to infer missing param types:\r\n\r\n```scala\r\nval f = _ + _  // error: missing parameter type for expanded function...\r\nval f = (_: Int) + (_: Int)  // OK: f(5, 10) = 15\r\n```\r\n\r\n**192 - Partially applied function (PAF)** is an expression in which you don't supply all of the arguments needed by the function. Instead, you supply some, or none:\r\n\r\n```scala\r\nsomeNums.foreach(println _)  \r\n// is equivalent to:\r\nsomeNums.foreach(x => println(x))\r\n// if a function value is required in that place you can omit the placeholder:\r\nsomeNums.foreach(println)\r\n```\r\n\r\n```scala\r\ndef sum(a: Int, b: Int, c: Int) = a + b + c\r\n\r\nval a = sum _  // '_' is a placeholder for the entire param list\r\na: (Int, Int, Int) => Int = <function3>\r\n\r\n// they are called partially applied functions because you can do this:\r\nval b = sum(1, _: Int, 3)\r\nb(2)  // Int = 6\r\n```\r\n\r\n**197 - Closures** see the changes to **free variables** and _vice versa_, changes to *free variables* made by *closure* are seen outside of *closure*  \r\n**199 - Repeated parameters** Scala allows you to indicate that the last param to a function may be repeated:\r\n\r\n```scala\r\ndef echo(args: String*) = for(arg <- args) println(arg)\r\n// Now `echo` may be called with zero or more params\r\n\r\n// to pass in an `Array[String]` instead, you need to\r\n// append the arg with a colon and an `_*` symbol:\r\necho(Array(\"arr\", \"of\", \"strings\"): _*)\r\n```\r\n\r\n**200 - Named arguments** allow you to pass args to a function in a different order:\r\n\r\n```scala\r\n// The syntax is to precede each argument with a param name and an equals sign:\r\nspeed(distance = 100, time = 10)\r\n\r\n// it is also possible to mix positional and named args\r\n// in which case the positional arguments, understandably, must come first\r\n```\r\n\r\n**201 - Default parameter values** allows you to omit such a param when calling a function, in which case the param will be filled with its default value:\r\n\r\n```scala\r\ndef printTime(out: java.io.PrintStream = Console.out) = \r\n  out.println(\"time = \" +  System.currentTimeMillis())\r\n\r\n// now, you can call the function like this: \r\nprintTime()\r\n// or like this: \r\nprintTime(Console.err)\r\n```\r\n\r\n**202 - Tail recursion (Tail call optimization)**\r\n\r\n> - if the recursive call is the last action in the function body, compiler is able to replace the call with a jump back to the beginning of the function, after updating param values\r\n> - because of the JVM instruction set, tail call optimization cannot be applied for two mutually recursive functions nor if the final call goes to a function value (function wraps the recursive call):\r\n\r\n```scala\r\nval funValue = nestedFun _\r\ndef nestedFun(x: Int) {\r\n  if (x != 0) {println(x); funValue(x - 1)}  // won't be optimized\r\n}\r\n```\r\n\r\n### Control Abstractions\r\n**207 - Higher order functions** - functions that take other functions as parameters:\r\n\r\n```scala\r\n/** \r\n * refactoring imperative code:\r\n * demonstrates control abstraction (higher order function)\r\n * that reduces code duplication and significantly simplifies the code\r\n*/\r\n// function receives a String and a function that maps (String, String) => Boolean\r\ndef filesMatching(query: String, matcher: (String, String) => Boolean) = {\r\n  for (\r\n    file <- filesHere;  // filesHere is a function that returns an Array of files\r\n    if matcher(file.getName, query)\r\n  ) yield file\r\n}\r\n\r\ndef filesEnding(query: String) =\r\n  filesMatching(query, (fileName: String, query: String) => fileName.endsWith(query))\r\n\r\ndef filesContaining(query: String) =\r\n  filesMatching(query, (fileName, query) => fileName.contains(query)) // OK to omit types\r\n\r\ndef filesRegex(query: String) =\r\n  filesMatching(query, _.matches(_))  // since each 'matcher' param is used only once\r\n\r\n\r\n// since the query is unnecessarily passed around,\r\n// we can further simplify the code by introducing a closure\r\ndef filesMatching(matcher: String => Boolean) = {\r\n  for(\r\n    file <- filesHere;\r\n    if matcher(file.getName)\r\n  ) yield file\r\n}\r\n    \r\ndef filesRegex(query: String) =\r\n  filesMatching(_.matches(query))  // 'matches' closes over free variable 'query'\r\n```\r\n\r\n**213 - Currying**: A curried function is applied to multiple argument lists, instead of just one:\r\n\r\n```scala\r\ndef curriedSum(x: Int)(y: Int) = x + y\r\n// curriedSum: (x: Int)(y: Int)Int\r\n\r\ncurriedSum(1)(2)\r\n// Int = 3\r\n\r\n/*\r\n * Curried f produces two traditional function invocations. The first function invocation\r\n * takes a single 'Int' parameter named 'x', and returns a function value for the second\r\n * function, which takes the 'Int' parameter 'y'\r\n*/\r\n\r\n// This is what the first function actually does:\r\ndef first(x: Int) = (y: Int) => x + y  // returns function value\r\n// (x: Int)Int => Int\r\n\r\nval second = first(1)  // applying 1 to the first fn yields the second fn\r\n// (x: Int)Int => Int\r\n\r\nsecond(2)  // applying 2 to the second fn yields the final result\r\n// Int = 3\r\n\r\n/*\r\n * You can use the placeholder notation to use curriedSum in a partially applied function\r\n * expression which returns the second function:\r\n*/\r\nval onePlus = curriedSum(1)_  // '_' is a placeholder for the second param list\r\n// onePlus: (Int) => Int = <function1>  // 'onePlus' does the same thing as 'second'\r\n\r\n/*\r\nwhen using placeholder notation with Scala identifiers you need to put a space between\r\nidentifier and underscore, which is why we didn't need space in 'curriedSum(1)_' and we\r\ndid need space for 'println _'\r\n*/\r\n\r\n// another example of higher order function, that repeats an operation two times\r\n// and returns the result:\r\ndef twice(op: Double => Double, x: Double) = op(op(x))\r\ntwice(_ + 1, 5)  // f(f(x)) = x + 1 + 1, where x = 5\r\n// Double = 7.0\r\n```\r\n\r\n**216 - Loan pattern**\r\n\r\n> - some control abstraction function opens a resource and *loans* it to a function:\r\n\r\n```scala\r\n// opening a resource and loaning it to 'op'\r\ndef withPrintWriter(file: File, op: PrintWriter => Unit) {\r\n  val writer = new PrintWriter(file)\r\n  try {\r\n    op(writer)  // loan the resource to the 'op' function\r\n  } finally {   // this way we're sure that the resource is closed in the end\r\n    writer.close()\r\n  }\r\n}\r\n// to call the method:\r\nwithPrintWriter(\r\n  new File(\"date.txt\"),\r\n  writer => writer.println(new java.util.Date)\r\n)\r\n\r\n/*\r\n * In any method invocation in which you're passing in 'exactly one argument'\r\n * you can opt to use curly braces instead of parentheses to surround the argument\r\n */\r\n\r\n// using 'currying', you can redefine 'withPrintWriter' signature like this:\r\ndef withPrintWriter(file: File)(op: PrintWriter => Unit)\r\n\r\n// which now enables you to call the function with a more pleasing syntax:\r\nval file = new File(\"date.txt\")\r\nwithPrintWriter(file) { // this curly brace is the second parameter\r\n    writer => writer.println(new java.util.Date)\r\n}\r\n```\r\n\r\n**218 - By-name parameters**\r\n\r\n> - typically, parameters to functions are *by-value* parameters, meaning, the value of the parameter is determined before it is passed to the function\r\n> - to write a function that accepts an expression that is not evaluated until it's called within a function, you use *call-by-name* mechanism, which passes a code block to the callee and each time the callee accesses the parameter, the code block is executed and the value is calculated:\r\n\r\n```scala\r\nvar assertionsEnabled = true\r\ndef myAssert(predicate: () => Boolean) =  // without by-name parameter\r\n  if (assertionsEnabled && !predicate())  // call it like this: myAssert(() => 5 > 3)\r\n    throw new AssertionError\r\n\r\n// to make a by-name parameter, you give the parameter a type\r\n// starting with '=>' instead of '() =>'\r\ndef myAssert(predicate: => Boolean) =     // with by-name parameter\r\n  if (assertionsEnabled && !predicate())  // call it like this: myAssert(5 > 3)\r\n    throw new AssertionError              // which looks exactly like built-in structure\r\n\r\n// we could've used a plain-old Boolean, but then the passed expression\r\n// would get executed before the call to 'boolAssert'\r\n```\r\n\r\n### Composition and Inheritance\r\n**222 - Composition** means one class holds a reference to another  \r\n**224 - `abstract` method** does not have an implementation (i.e., no equals sign or body)\r\n\r\n> - unlike Java, no abstract modifier is allowed on method declarations\r\n> - methods that do have an implementation are called **concrete**\r\n\r\n**224 -** Class is said to **declare an abstract method** and that it **defines a concrete method** (i.e. *declaration* is *abstract*, *definition* is *concrete*)  \r\n**225 -** Methods with empty parentheses are called **empty-paren methods**\r\n\r\n> - this convention (see _bullet 127_ on top) supports the __uniform access principle__, which says that the client code should not be affected by a decision to implement an attribute as a field or as a method\r\n> - from the client's code perspective, it should be irrelevant whether `val` or `def` is accessed\r\n> - the only difference is speed, since fields are precomputed when the class is initialized\r\n> - but, on the other hand, fields are carried around with the parent object\r\n\r\n**229 -** Fields and methods belong to the same *namespace*, which makes possible for a\r\nfield to override a parameterless method, but it forbids defining a field and a method with the same name  \r\n**230 -** *Java* has four namespaces: fields, methods, types and packages  \r\n        *Scala* has two namespaces:  \r\n          **values** (fields, methods, packages and singleton objects)  \r\n          **types** (classes and traits)  \r\n**231 - Parametric field** is a shorthand definition for *parameter* and *field*, where *field* gets assigned a *parameter's* value (the parametric field's name mustn't clash with an existing element in the same namespace, like field or method):\r\n\r\n```scala\r\nclass ArrayElement(\r\n  val contents: Array[String]  // could be: 'var', 'private', 'protected', 'override'\r\n)\r\n```\r\n\r\n**232 -** You pass an argument to the superconstructor by placing it in parentheses following the name of the superclass:\r\n\r\n```scala\r\nclass LineElement(s: String) extends ArrayElement(Array(s)) {\r\n  override def width = s.length  // 'override' mandatory for overrides of concrete members\r\n  override def height = 1\r\n}\r\n```\r\n\r\n**238 -** If you want to disallow for a method to be overridden or for a class to be subclassed, use the keyword **final** (e.g. `final class ...` or `final def ...`)  \r\n**240 - `++`** operator is used to concatenate two arrays  \r\n**241 - `zip`** is used to pair two arrays (make `Tuple2`s), dropping the elements from the longer array that don't have corresponding elements in the shorter array, so:\r\n\r\n```scala\r\nArray(1, 2, 3) zip Array(\"a\", \"b\") // will evaluate to\r\nArray((1, \"a\"), (2, \"b\"))\r\n\r\n// 'zip' usage example\r\ndef beside(that: Element): Element =\r\n  new ArrayElement(\r\n    for(\r\n      (line1, line2) <- this.contents zip that.contents  // new Tuple2 for each iteration\r\n    ) yield line1 + line2\r\n  )\r\n```\r\n\r\n**242 - `mkString`** is defined for all sequences (including arrays). `toString` is called on each element of the sequence. Separator is inserted between every two elems:\r\n\r\n```scala\r\noverride def toString = contents mkString \"\\n\"\r\n```\r\n\r\n### Scala's Hierarchy\r\n**250 -** In Scala hierarchy, **scala.Null** and **scala.Nothing** are the subclasses of every class (thus the name **bottom classes**), just as **Any** is the superclass of every other class  \r\n**250 -** `Any` contains methods:\r\n\r\n> `==`...............`final`, same as `equals` (except for Java boxed numeric types)  \r\n> `!=`...............`final`, same as `!equals`  \r\n> `equals`.........used by the subclasses to override equality  \r\n> `##`................same as `hashCode`  \r\n> `hashCode`  \r\n> `toString`  \r\n\r\n**251 -** Class `Any` has two subclasses:\r\n\r\n> `AnyVal`      the parent class of every built-in **value class** in Scala  \r\n> `AnyRef`      the base class of all **reference classes** in Scala\r\n> \r\n> Built-in **value classes**: `Byte`, `Short`, `Char`, `Int`, `Long`, `Float`, `Double`, `Boolean` and `Unit`\r\n>  - represented (except `Unit`) as Java primitives at runtime\r\n>  - both `abstract` and `final`, so you cannot instantiate them with `new`\r\n>  - the instances of these classes are all written as literals (e.g. `5` is `Int`) \r\n>  - `Unit` corresponds to Java's `void` and has a single instance value, `()`\r\n>  - Implicit conversion from `Int` to `RichInt` happens when a method that only exists in `RichInt` is called on `Int`. Similar **Booster classes** exist for other value types\r\n>  \r\n> All **reference classes** inherit from a special marker trait called `ScalaObject`\r\n\r\n**254 -** Scala stores integers the same way as Java, as 32-bit words, but it uses the *backup* class `java.lang.Integer` to be used whenever an int has to be seen as object  \r\n**256 -** For **reference equality**, `AnyRef` class has `eq` method, which cannot be overridden (behaves like `==` in Java for reference types). Opposite of `eq` is `ne`  \r\n**256 - `Null`** is a subclass of every reference class (i.e. class that inherits from `AnyRef`). It's not compatible with *value types* (`val i: Int = Null // type mismatch`)  \r\n**257 - `Nothing`** is a subtype of every other type (of *Null* also). There are no values of this type, it's used primarily to signal abnormal termination:\r\n\r\n```scala\r\ndef error(message: String): Nothing =\r\n  throw new RuntimeException(message)\r\n\r\n// because of its position in type hierarchy, you can use it like this:\r\ndef divide(x: Int, y: Int): Int =     // must return 'Int'\r\n  if(y != 0) x / y                    // Returns 'Int'\r\n  else error(\"can't divide by zero\")  // 'Nothing' is a subtype of 'Int'\r\n```\r\n\r\n### Traits\r\n**258 - Trait** encapsulates method and field definitions, which can then be reused by mixing them into classes\r\n\r\n> - *trait* can be mixed in using keywords `extends` or `with`. The difference is that, by using `extends`, you implicitly inherit the trait's superclass (`AnyRef` if a trait has no explicit superclass)\r\n> - *trait* also defines a type which can be used as a regular class\r\n> - if you want to mix a trait into a class that explicitly extends a superclass, use `extends` to indicate the superclass and `with` to mix in the trait:\r\n> - to mix in multiple traits using `with`:\r\n> - a class can override trait's members (polymorphism works the same way as with regular classes):\r\n\r\n```scala\r\nclass Animal\r\nclass Frog extends Animal with Philosophical with HasLegs {\r\n  override def toString = \"green\"\r\n  override def philosophize() {\r\n    println(\"It ain't easy being \" + toString)\r\n  }\r\n}\r\n```\r\n\r\n**261 -** *Traits* can declare fields and maintain state (unlike Java interfaces). You can do anything in a trait definition that you can do with a class definition, with two exceptions:\r\n\r\n> - traits cannot have *class parameters*\r\n> - traits have dynamically bound `super` (unlike statically bound `super` in classes)\r\n>   - the implementation to invoke is determined each time the trait is mixed into class\r\n>   - key to allowing traits to work as *stackable modifications*\r\n\r\n**266 - Ordered trait** allows you to implement all comparison operations on a class\r\n\r\n> - requires you to specify a *type parameter* when you mix it in (`extends Ordered[TypeYouCompare]`)\r\n> - requires you to implement the `compare` method, which should return `Int`, `0` if the object are the same, negative if receiver is less than the argument and positive if the receiver is greater than the argument\r\n> - does not provide `equals` (because of \"type erasure\")\r\n\r\n**267 - Stackable modifications**\r\n\r\n> - traits let you modify the methods of a class in a way that allows you to stack those modifications together, by mixing in multiple traits\r\n> - when a trait extends a superclass, it means that the trait can only be mixed in in classes that also extend the same superclass\r\n> - traits can have `abstract override` methods because of dynamically bound `super` (the call works if the trait is mixed in after another trait or class has already given a concrete definition to that method)\r\n> - when you instantiate a class with `new` Scala takes the class and all of its inherited classes and traits and puts them in a single, *linear* order, thus the name **linearization**. Then, when you call `super` inside one of those classes, the invoked method is the first implementation up the chain (right in the image bellow)\r\n> - the **order of mixins** is significant. Traits further to the right take effect first\r\n\r\n```scala\r\n// mixing in a trait when instantiating with 'new' (no need to create a new class)\r\nval queue = new BasicIntQueue with Doubling with Filtering  // filtering is applied first\r\n// queue: BasicIntQueue with Doubling with Filtering = $anon$1@5fa12d\r\n\r\nqueue.put(10)  // passes the Filtering and then gets doubled with Doubling trait\r\nqueue.put(-1)  // not placed in the queue (negative number filter trait applied)\r\nqueue.get()  // Int = 20\r\n```\r\n\r\n![Scala Linearization](https://github.com/mbonaci/scala/blob/master/resources/Scala-linearization-example.png?raw=true)\r\n![Linearization order](https://github.com/mbonaci/scala/blob/master/resources/Scala-linearization.png?raw=true)\r\n\r\n**275 - When to use a _trait_ and when an _abstract class_**\r\n\r\n> - if the behavior will not be reused make a concrete class\r\n> - if it might be used in multiple, unrelated classes, use a trait\r\n> - if you want to inherit from it in Java code, use an abstract class\r\n>   - a trait with only abstract members translates to Java `interface`\r\n> - if you plan to distribute it in compiled form and you expect others to write classes that inherit from your code, use an abstract class (when a trait gains or loses a member, any class that inherit from it must be recompiled)\r\n> - if efficiency is very, very important, use a class (in Java, a virtual method invocation of a class member is faster than an interface method invocation)\r\n> - if none of the above fits your case, use trait\r\n\r\n### Packages and Imports\r\n**278 - Packages** can be used like in C#: `package pkg_name { // source... }`, with more packages in a single source file. Also, they can be nested in one another\r\n\r\n> - a package represents a scope, whose contents is accessed relative to current location\r\n> - a top level package that's outside all packages any user can write is called `_root_`\r\n> - all names accessible outside packages can be access from inside the package in the same way\r\n> - if you stick with one package per file then Java package rules apply\r\n\r\n```scala\r\n// this\r\npackage one\r\npackage two\r\n// is just syntactic sugar for this\r\npackage one {\r\n  package two {\r\n\r\n// to import the package (not a specific package member)\r\nimport one.two  // and then use objects like this: `two.Two.method`\r\n\r\n// which is a shorthand for 'Import selector' syntax:\r\nimport one.{two}\r\n\r\n// to access all members of a package (underscore instead of Java's star)\r\nimport one.two.three._  // could also be written as `import one.two.three.{_}`\r\n\r\n// to use import with objects and classes\r\ndef showOne(one: One) {  // imports all members of its parameter `one`, of class `One`\r\n  import one._  // use imports wherever you like\r\n  println(name + \"s are the best\")\r\n}\r\n\r\n// to import more than one specific package member use 'Import selectors'\r\nimport one.{One1, One2}\r\n\r\n// to rename import\r\nimport one.{One1 => First, One2}  // `One1` is accessed as `First` (or `one.One1`)\r\n\r\n// to import all members and rename one of them\r\nimport one.two.{Two => Second, _}  // catch-all must come last in the list\r\n\r\n// to import all members except one (useful for ambiguities)\r\nimport one.two.{Two => _, _}  // excludes `Two`\r\n\r\n// implicit imports (later imports overshadow earlier ones)\r\nimport java.lang._\r\nimport scala._\r\nimport Predef._\r\n```\r\n\r\n**288 - Access modifiers** available in Scala: `Private` and `Protected`\r\n\r\n> - outer class's access to `private` members of its inner class is forbidden\r\n> - Java allows access to `protected` members to classes in the same package even if they don't inherit from the class that declares protected members. Scala don't\r\n\r\n**289 - Access qualifiers**\r\n\r\n> - a modifier in the form `private[X]` or `protected[X]` means that access is applied \"up to X\", where `X` designates some enclosing package, class or a singleton\r\n> - **object-private** `private[this]` means that access is allowed only from within the the object that contains definition itself, not its instances (`ObjName.privMember` will fail in this case)\r\n\r\n**291 - Companion objects** or **Singletons**\r\n\r\n> - a class shares all its access rights with its companion object and vice versa\r\n> - `protected` modifier makes no sense since *Companion objects* cannot be subclassed\r\n\r\n**292 - Package objects**\r\n\r\n> - any kind of definition you can put in a class can go in a *package object*\r\n> - each package is allowed to have one *package object*\r\n> - frequently used to hold package-wide *type aliases* and *implicit conversions*\r\n> - the top level `scala` package has a package object, which is available to all Scala code\r\n> - they are compiled to `package.class` file in that package's directory\r\n> - access is the same as for any other package element:\r\n\r\n```scala\r\n// in file 'one/package.scala'\r\npackage object one {\r\n  def showSomeone(someone: Someone) {\r\n    import someone._\r\n    println(name + \", I am\")\r\n  }\r\n}\r\n\r\n// in file View.scala\r\npackage view\r\nimport one.Someone  // class defined in package 'one'\r\nimport one.showSomeone\r\nobject ViewDialog {\r\n  def main(args: Array[String]) {\r\n    for(someone <- Someone.dialog) {\r\n      showSomeone(someone)\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n### Assertions and Unit Testing\r\n**295 - Assertions**\r\n\r\n> - written as calls of a predefined method `assert` (defined in the `Predef` singleton)\r\n> - assertions and ensuring checks can be enabled/disabled with JVM's `-ea`/`-da` flags\r\n> - `assert` methods and `ensuring` convenience methods:\r\n\r\n```scala\r\nassert(condition) // throws AssertionError\r\nassert(condition, explanation: Any) // AssertionError contains explanation.toString\r\n\r\n// 'ensuring' example\r\ndef widen(w: Int): Element =\r\n  if(w <= width) this\r\n  else {\r\n    val left = elem(' ', (w - width) / 2, height)\r\n    val right = elem(' ', w - width - left.width, height)\r\n    left beside this beside right\r\n  } ensuring(w <= _.width)  // takes a predicate function\r\n                            // when invoked, it passes return type ('Element') to the \r\n                            // predicate function that returns 'Boolean'\r\n// if predicate evaluates to 'true', 'ensuring' results with 'Element' on which it was invoked\r\n// since this is the last expression of the method, 'widen' returns the 'Element'\r\n// throws AssertionError if predicate returns 'false'\r\n```\r\n\r\n**297 - Unit testing**\r\n\r\n> - there are many options for unit testing in Scala, e.g. Java `JUnit` and `TestNG` tools or tools written in Scala, e.g. `ScalaTest`, `specs` and `ScalaCheck`  \r\n\r\n> - [ScalaTest](http://www.scalatest.org)\r\n>   - the simplest way to test with *ScalaTest* is to extend `org.scalatest.Suite` and define test methods in those classes. Methods start with `test`:\r\n\r\n```scala\r\nimport org.scalatest.Suite\r\nimport Element.elem\r\n\r\nclass ElementSuite extends Suite {\r\n  def testUniformElement() {\r\n    val e = elem('x', 2, 3)\r\n    assert(e.width == 2)\r\n  }\r\n}\r\n\r\n// ScalaTest offers a trait 'FunSuite', which overrides 'execute'\r\n// so you can define tests as function values, rather than methods\r\nclass ElementSuite extends FunSuite {\r\n  // test is a method in FunSuite which is invoked by ElementSuite's primary constructor\r\n  test(\"elem result should have passed width\") {  // name of test\r\n    // curly - function passed as by-name param to 'test', which registers it for later execution\r\n    val e = elem('x', 2, 3)\r\n    assert(e.width == 2)  // if fails you see error message with line number\r\n  }\r\n}\r\n\r\n// triple equals, if assert fails, returns nice error msg. e.g. \"3 did not equal 2\":\r\nassert(e.width === 2)\r\n\r\n// alternatively, 'expect' can be used:\r\nexpect(2) {  // yields \"expected 2, but got 3\" in the test failure report\r\n  e.width\r\n}\r\n\r\n// if you want to check whether a method throws expected exception use 'intercept'\r\n// if the code does not throw expected exception or doesn't throw at all\r\n// 'TestFailedException' is thrown, along with a helpful error msg\r\nintercept[IllegalArgumentException] {  // returns caught exception\r\n  elem('x', -2, 3)\r\n}\r\n```\r\n\r\n>   - although ScalaTest includes Runner application, you can also run Suite directly from the Scala interpreter by invoking `execute` on it (trait Suite's `execute` method uses reflection to discover its test methods and invoke them):\r\n\r\n```scala\r\n(new ElementSuite).execute()\r\nTest Starting - ElementSuite.testUniformElement\r\nTest Succeeded - ElementSuite.testUniformElement\r\n```\r\n\r\n>   - in **BDD**, the emphasis is on writing human-readable specifications of the expected code behavior, along with the accompanying tests that verify that behavior\r\n>   - for that purpose, ScalaTest includes several traits: Spec, WordSpec, FlatSpec and FeatureSpec\r\n\r\n```scala\r\nimport org.scalatest.FlatSpec\r\nimport org.scalatest.matchers.ShouldMatchers\r\nimport Element.elem\r\n\r\nclass ElementSpec extends FlatSpec with ShouldMatchers {\r\n  \"A UniformElement\" should \"have a width equal to the passed value\" in {\r\n    val e = elem('x', 2, 3)\r\n    e.width should be (2)\r\n  }\r\n  it should \"have a height equal to the passed value\" in {  // 'specifier clause'\r\n    val e = elem('x', 2, 3)\r\n    e.height should be (3)\r\n  }\r\n  it should \"throw an IAE if passed a negative width\" in {  // or 'must' or 'can'\r\n    evaluating {\r\n      elem('x', -2, 3)\r\n    } should produce [IllegalArgumentException]\r\n  }\r\n}\r\n```\r\n\r\n### Case Classes and Pattern Matching\r\n**310 - Case classes**\r\n\r\n> - for classes with `case` modifier, Scala compiler adds some syntactic sugar:\r\n>   - a factory method with the same name as the class, which allows you to create new object without keyword `new` (`val m = MyCls(\"x\")`)\r\n>   - all class parameters implicitly get a `val` prefix, so they are made into fields\r\n>   - compiler adds \"natural\" implementations of methods `toString`, `hashCode` and `equals`, which will print, hash and compare a whole tree of the class and its arguments\r\n>   - `copy` method is added to the class (used to create modified copies). To use it, you specify the changes by using *named parameters* and for any param you don't specify, the original value is used:\r\n\r\n```scala\r\nabstract class Expr\r\ncase class Var(name: String) extends Expr\r\ncase class Number(num: Double) extends Expr\r\ncase class UnOp(operator: String, arg: Expr) extends Expr\r\ncase class BinOp(operator: String, left: Expr, right: Expr) extends Expr\r\nval op = BinOp(\"+\", Number(1), Var(\"x\"))\r\nop: BinOp = BinOp(+,Number(1.0),Var(x))\r\n\r\n// copy method example\r\nop.copy(operator = \"-\")\r\n// BinOp = BinOp(-,Number(1.0),Var(x))\r\n```\r\n\r\n**312 - Pattern matching**\r\n\r\n> - the biggest advantage of *case classes* is that they support *pattern matching*\r\n\r\n```scala\r\n// written in the form of 'selector match {alternatives}'\r\ndef simplifyTop(expr: Expr): Expr = expr match {\r\n  case UnOp(\"-\", UnOp(\"-\", e))  => e\r\n  case BinOp(\"+\", e, Number(0)) => e\r\n  case BinOp(\"*\", e, Number(1)) => e\r\n  case _ => expr\r\n}\r\n\r\n// the right hand side can be empty (the result is 'Unit'):\r\ncase _ =>\r\n```\r\n\r\n> - `match` expression is evaluated by trying each of the patterns in the order they are written. The first pattern that matches is selected and the part following the fat arrow is executed\r\n> - `match` _is an expression_ in Scala (always results in a value)\r\n> - there is _no *fall through*_ behavior into the next case\r\n> - if _none of the patterns match_, an exception `MatchError` is thrown\r\n\r\n**315 - Constant patterns**\r\n\r\n> - matches only itself (comparison is done using `==`)\r\n> - any literal, `val` or singleton object can be used as a constant\r\n\r\n```scala\r\ndef describe(x: Any) = x match {\r\n  case 5 => \"five\"\r\n  case true => \"truth\"\r\n  case \"hello\" => \"hi\"\r\n  case Nil => \"the empty list\"  // built-in singleton\r\n  case _ => \"something unexpected\"\r\n}\r\n```\r\n\r\n**316 - Variable patterns**\r\n\r\n> - matches any object, like wildcard\r\n> - unlike the wildcard, Scala binds the variable to whatever the object is and then a variable refers to that value in the right hand side of the `case` clause\r\n\r\n```scala\r\nimport math.{E, Pi}\r\n\r\nval pi = math.Pi\r\n\r\nE match {\r\n  case 0 => \"zero\"\r\n  case Pi => \"strange! \" + E + \" cannot be \" + Pi\r\n  case `pi` => \"strange? Pi = \" + pi  // will be treated as constant ('val pi')\r\n  case pi => \"That could be anything: \" + pi  // not constant pattern ('val pi'). Variable pattern!\r\n  case _ => \"What?\"  // Compiler reports \"Unreachable code\" error\r\n}\r\n/*\r\n * How does Scala know whether 'Pi' is a constant from 'scala.math' and not a variable?\r\n * A simple lexical rule is applied:\r\n *   - If a name starts with a lowercase letter Scala treats it as a variable pattern.\r\n *   - All other references are treated as constants\r\n *   - With exception of fields: 'this.pi' and 'obj.pi', and lowercase names in back ticks\r\n */\r\n```\r\n\r\n**314 - Wildcard patterns**\r\n\r\n> - `_` matches every value, but it doesn't result with a variable\r\n\r\n```scala\r\n// in this example, since we don't care about elements of a binary operation\r\n// only whether it's a binary operation or not, we can use wildcard pattern:\r\nexpr match {\r\n  case BinOp(_, _, _) => println(expr + \"is a binary operation\")\r\n  case _ => println(\"It's something entirely different\")\r\n}\r\n```\r\n\r\n**318 - Constructor patterns**\r\n \r\n> - Scala first checks whether the object is a member of the named *case class* and then checks that the constructor params of the object match the patterns in parentheses\r\n> - **Deep matching** means that it looks for patterns arbitrarily deep\r\n\r\n```scala\r\n// first checks that the top level object is a 'BinOp', then whether the third\r\n// constructor param is a 'Number' and finally that the value of that number is '0'\r\nexpr match {\r\n  case BinOp(\"+\", e, Number(0)) => println(\"a deep match\")  // checks 3 levels deep\r\n  case _ =>\r\n}\r\n```\r\n\r\n**318 - Sequence patterns**\r\n \r\n> - `List` and `Array` can be matched against, just like *case classes*\r\n\r\n```scala\r\n// checks for 3 element list that starts with zero:\r\nexpr match {\r\n  case List(0, _, _) => println(\"zero starting list of three elements\")\r\n}\r\n\r\n// to check against the sequence without specifying how long it must be:\r\nexpr match {\r\n  case List(0, _*) => println(\"zero starting list\")\r\n  case List(_*) => println(\"any list\")\r\n}\r\n```\r\n\r\n**319 - Tuple patterns**\r\n\r\n```scala\r\n(\"a \", 3, \"-tuple\") match {\r\n    case (a, b, c) => println(\"matched \" + a + b + c)  // matched a 3-tuple\r\n    case _ =>\r\n  }\r\n```\r\n\r\n**319 - Typed patterns**\r\n\r\n> - used for convenient type checks and type casts\r\n\r\n```scala\r\n  def generalSize(x: Any) = x match {\r\n    case s: String => s.length  // type check + type cast - 's' can only be a 'String'\r\n    case m: Map[_, _] => m.size\r\n    case _ => -1\r\n  }                                               //> generalSize: (x: Any)Int\r\n\r\n  generalSize(\"aeiou\")                            //> Int = 5\r\n  generalSize(Map(1 -> 'a', 2 -> 'b'))            //> Int = 2\r\n  generalSize(math.Pi)                            //> Int = -1\r\n\r\n// generally, to test whether expression is an instance of a type:\r\nexpr.isInstanceOf[String]  // member of class 'Any'\r\n// to cast\r\nexpr.asInstanceOf[String]  // member of class 'Any'\r\n\r\ndef isIntToIntMap(x: Any) = x match {\r\n  // non-variable type Int is unchecked since it's eliminated by erasure\r\n  case m: Map[Int, Int] => true\r\n  case _ => false\r\n}\r\n\r\nisIntToIntMap(Map(1 -> 2, 2 -> 3))              //> Boolean = true\r\nisIntToIntMap(Map(\"aei\" -> \"aei\"))              //> Boolean = true !!!\r\n\r\n// the same thing works fine with arrays since their type is preserved with their value\r\n```\r\n\r\n> - **Type erasure**\r\n>   - erasure model of generics, like in Java, means that no information about type arguments is maintained at runtime. Consequently, there is no way to determine at runtime whether a given Map object has been created with two Int arguments, rather than with arguments of any other type. All the system can do is determine that a value is a Map of some arbitrary type parameters\r\n\r\n**323 - Variable binding**\r\n\r\n> - allows you to, if the pattern matches, assign a variable to a matched object\r\n> - the syntax is `var_name @ some_pattern'\r\n\r\n```scala\r\ncase UnOp(\"abs\", e @ UnOp(\"abs\", _)) => e  // if matched, 'e' will be 'UnOp(\"abs\", _)'\r\n```\r\n\r\n**324 - Pattern guards**\r\n\r\n> - in some circumstances, syntactic pattern matching is not precise enough\r\n> - a pattern guard comes after a pattern and starts with an `if`\r\n> - can be arbitrary boolean expression and typically refers to pattern variables\r\n> - the pattern matches only if the guard evaluates to `true`\r\n\r\n```scala\r\n// match only positive integers\r\ncase n: Int if 0 < n => n + \" is positive\"\r\n// match only strings starting with the letter ‘a’\r\ncase s: String if s(0) == 'a' => s + \" starts with letter 'a'\"\r\n```\r\n\r\n> - e.g. if you'd like to transform `x + x` to `2 * x` with patterns:\r\n\r\n```scala\r\n// this won't work, since a pattern variable may only appear once in a pattern:\r\ndef simplifyAdd(e: Expr) = e match {\r\n    case BinOp(\"+\", x, x) => BinOp(\"*\", x, Number(2))  // x is already defined as value x\r\n    case _ => e\r\n}\r\n\r\n// so instead:\r\n  def simplifyAdd(e: Expr) = e match {\r\n    // matches only a binary expression with two equal operands\r\n    case BinOp(\"+\", x, y) if x == y => BinOp(\"*\", x, Number(2))\r\n    case _ => e\r\n  }                     //> simplifyAdd: (e: Expr)Expr\r\n\r\n  val add = BinOp(\"+\", Number(24), Number(24))\r\n                        //> add  : BinOp = BinOp(+,Number(24.0),Number(24.0))\r\n  val timesTwo = simplifyAdd(add)\r\n                        //> timesTwo  : Expr = BinOp(*,Number(24.0),Number(2.0))\r\n```\r\n\r\n**325 - Pattern overlaps**\r\n\r\n> - patterns are tried in the order in which they are written\r\n\r\n```scala\r\n// recursively call itself until no more simplifications are possible\r\ndef simplifyAll(expr: Expr): Expr = expr match {\r\n  case UnOp(\"-\", UnOp(\"-\", e)) =>\r\n    simplifyAll(e) // '-' is its own inverse\r\n  case BinOp(\"+\", e, Number(0)) =>\r\n    simplifyAll(e) // '0' is a neutral element for '+'\r\n  case BinOp(\"*\", e, Number(1)) =>\r\n    simplifyAll(e) // '1' is a neutral element for '*'\r\n  case UnOp(op, e) =>\r\n    UnOp(op, simplifyAll(e))\r\n  case BinOp(op, l, r) =>\r\n    BinOp(op, simplifyAll(l), simplifyAll(r))\r\n  case _ => expr\r\n}\r\n\r\nimplicit def intToNumber(x: Int) = new Number(x)\r\nimplicit def numberToInt(x: Number) = x.num.toInt\r\n\r\nval allMin = UnOp(\"-\", UnOp(\"-\", 4))\r\nval allAdd = BinOp(\"+\", 244, 0 + Number(0))\r\nval allMul = BinOp(\"*\", 24, 1)\r\n\r\nsimplifyAll(allMin)   //> Expr = Number(4.0)\r\nsimplifyAll(allAdd)   //> Expr = Number(244.0)\r\nsimplifyAll(allMul)   //> Expr = Number(24.0)\r\n```\r\n\r\n**326 - Sealed classes**\r\n\r\n> - how can you be sure you covered all the cases when using pattern matching, since a new `case class` may be created in any time, in another compilation unit?\r\n> - you make the _superclass_ of your _case class_ `sealed`, which then means that a class cannot have any new subclasses added except the ones in the same file\r\n> - this way, when using pattern matching, you only need to worry about the subclasses you know of\r\n> - also, when you match against subclasses of a sealed class, you get the compiler support, which will flag missing combinations of patterns with a warning message:\r\n\r\n```scala\r\n// if you make 'Expr' class sealed\r\nsealed abstract class Expr\r\n\r\n// and leave out some patterns when matching\r\ndef describe(e: Expr): String = e match {\r\n  case Number(_) => \"a num\"\r\n  case Var(_) => \"a var\"\r\n}\r\n\r\n/* you'll get a compiler warning:\r\n * warning: match is not exhaustive\r\n * missing combination  UnOp\r\n * missing combination  BinOp\r\n *\r\n * which is telling you that you might get 'MatchError'\r\n * because some possible patterns are not handled\r\n */\r\n// \r\n// \r\n\r\n// to get rid of the warning, in situations where you're sure that no such pattern\r\n// will ever appear, throw in the last catch-all case:\r\ncase _ => throw new RuntimeException  // should never happen\r\n\r\n// the same problem can be solved with more elegant solution, without any dead code\r\n// using 'unchecked' annotation:\r\ndef describe(e: Expr): String = (e: @unchecked) match {\r\n  case Number(_) ...\r\n}\r\n```\r\n\r\n**328 - The Option type**\r\n\r\n> - `Option` is type for optional values, which can be of two forms:\r\n>   - `Some(x)`, where `x` is the actual value\r\n>   - `None` object, which represents non-existent value\r\n> - optional values are produced by some of the standard operations on collections, e.g. the `Map`'s `get` method produces `Some(value)` or `None` if there was no given key\r\n> - the common way to distinguish between optional objects is through pattern matching:\r\n\r\n```scala\r\ndef show(x: Option[String]) = x match {\r\n  case Some(s) => s\r\n  case None => \"?\"\r\n}\r\n```\r\n\r\n**330 - Patterns in variable definitions**\r\n\r\n> - patterns could be used for `Tuple` destructuring:\r\n\r\n```scala\r\nval myTuple = (123, \"abc\")\r\nval (number, string) = myTuple  // multiple variables in one assignment\r\n```\r\n\r\n> - you can deconstruct a _case class_ with a pattern:\r\n\r\n```scala\r\nval exp = new BinOp(\"*\", Number(5), Number(10))\r\nval BinOp(op, left, right) = exp\r\n/*\r\n * op: String = *\r\n * left: Expr = Number(5.0)\r\n * right: Expr = Number(10.0)\r\n*/\r\n```\r\n\r\n**331 - Case sequences as partial functions**\r\n\r\n> - a sequence of cases can be used anywhere a function literal can\r\n> - essentially, a case sequence is a function literal, only more general\r\n> - instead of having a single entry point and list of params, a case sequence has multiple entry points, each with their own list of params\r\n\r\n```scala\r\nval withDefault: Option[Int] => Int = {\r\n  case Some(x) => x\r\n  case None => 0\r\n}\r\n```\r\n\r\n> - a sequence of cases gives you a *partial function*\r\n\r\n```scala\r\n// this will work for list of 3 elements, but not for empty list\r\nval second: List[Int] => Int = {\r\n  case x :: y :: _ => y\r\n}  // warning: match is not exhaustive! missing combination     Nil\r\n\r\nsecond(List(1, 2, 3))  // returns 2\r\nsecond(List())         // throws MatchError\r\n\r\n/*\r\n * type 'List[Int] => Int' includes all functions from list of integers to integers\r\n * type 'PartialFunction[List[Int], Int]' includes only partial functions\r\n */\r\n\r\n// to tell the compiler that you know you're working with partial functions:\r\nval second: PartialFunction[List[Int], Int] = {\r\n  case x :: y :: _ => y\r\n}\r\n\r\n// partial functions have a method 'isDefinedAt':\r\nsecond.isDefinedAt(List(5, 6, 7))  // true\r\nsecond.isDefinedAt(List())  // false\r\n\r\n/* \r\n * these expressions above get translated by the compiler to a partial function\r\n * by translating the patterns twice, once for the implementation of the real function\r\n * and once to test whether the function is defined or not\r\n */\r\n\r\n// e.g. the function literal\r\n{ case x :: y :: _ => y }\r\n\r\n// gets translated to the following partial function value:\r\nnew PartialFunction[List[Int], Int] {\r\n  def apply(xs: List[Int]) = xs match {\r\n    case x :: y :: _ => y\r\n  }\r\n  def isDefinedAt(xs: List[Int]) = xs match {\r\n    case x :: y :: _ => true\r\n    case _ => false\r\n  }\r\n}\r\n\r\n// the translation takes place whenever the declared type of a function literal is 'PartialFunction'\r\n// if the declared type is just 'Function1', or is missing, the function literal gets \r\n// translated to a complete function\r\n\r\n// if you can, use a complete function, because partial functions allow for runtime errors\r\n// that the compiler cannot spot\r\n\r\n// if you happen to e.g. use a framework that expects partial function, you should\r\n// always check 'isDefinedAt' before calling the function\r\n```\r\n\r\n**334 - Patterns in `for` expressions**\r\n\r\n```scala\r\nfor((country, city) <- capitals)\r\n  println(\"The capital of \" + country + \" is \" + city)\r\n\r\n// in the above example, 'for' retrieves all key/value pairs from the map\r\n// each pair is then matched against the '(country, city)' pattern\r\n\r\n// to pick elements from a list that match a pattern:\r\nval results = List(Some(\"apple\"), None, Some(\"orange\"))\r\nfor(Some(fruit) <- results) println(fruit)\r\n// apple\r\n// orange\r\n\r\n// 'None' does not match pattern 'Some(fruit)'\r\n```\r\n\r\n### Working with Lists\r\n**344 - List literals**\r\n\r\n> - lists are _immutable_ (list elements cannot be changed by assignment)\r\n> - lists are _homogeneous_ (all list elements have the same type)\r\n> - list type is _covariant_ (if `S` is subtype of `T`, then `List[S]` is a subtype of `List[T]`)\r\n>   - `List[Nothing]` is a subtype of any other `List[T]`\r\n>   - that is why it's possible to write `val xs: List[String] = List()`\r\n> - they have two fundamental building blocks, `Nil` and `::` (cons), where `Nil` represents an empty list  \r\n```val nums = 1 :: 2 :: 3 :: 4 :: Nil```\r\n\r\n**346 - Basic operations on lists**\r\n\r\n> - all operations on lists can be expressed in terms of the following three methods:\r\n>   - `head`    - returns the first list element (defined for non-empty lists)\r\n>   - `tail`    - returns all elements except the first one (defined for non-empty lists)\r\n>   - `isEmpty` - returns `true` if the list is empty\r\n> - these operations take constant time, `O(1)`\r\n\r\n```scala\r\n// insertion sort implementation:\r\ndef isort(xs: List[Int]): List[Int] =\r\n  if (xs.isEmpty) Nil\r\n  else insert(xs.head, isort(xs.tail))\r\n\r\ndef insert(x: Int, xs: List[Int]): List[Int] =\r\n  if (xs.isEmpty || x <= xs.head) x :: xs\r\n  else xs.head :: insert(x, xs.tail)\r\n```\r\n\r\n**347 - List patterns**\r\n\r\n> - lists can be deconstructed with pattern matching, instead of with `head`, `tail` and `isEmpty`\r\n\r\n```scala\r\nval fruit = \"apples\" :: \"oranges\" :: \"pears\"\r\nval List(a, b, c) = fruit  // matches any list of 3, and binds them to pattern elements\r\n// a: String = apples\r\n// b: String = oranges\r\n// c: String = pears\r\n\r\n// if you don't know the number of list elements:\r\nval a :: b :: rest = fruit  // matches list with 2 or more elements\r\n// a: String = apples\r\n// b: String = oranges\r\n// rest: List[String] = List(pears)\r\n\r\n// pattern that matches any list:\r\nList(...)  // instance of library-defined 'extractor' pattern\r\n```\r\n\r\n> - normally, infix notation (e.g. `x :: y`) is equivalent to a method call, but with patterns, rules are different. When seen as a pattern, an infix operator is treated as a constructor:\r\n>   - `x :: y` is equivalent to `::(x, y)` (not `x.::(y)`)\r\n>   - there is a class named `::`, `scala.::` (builds non-empty lists)\r\n>   - there is also a method `::` in class `List` (instantiates class `scala.::`)\r\n\r\n```scala\r\n// insertion sort implementation, written using pattern matching:\r\ndef isort(xs: List[Int]): List[Int] = xs match {\r\n  case List() => List()\r\n  case x :: xs1 => insert(x, isort(xs1))\r\n}\r\n\r\ndef insert(x: Int, xs: List[Int]): List[Int] = xs match {\r\n  case List() => List(x)\r\n  case y :: ys =>\r\n    if(x <= y) x :: xs\r\n    else y :: insert(x, ys)\r\n}\r\n```\r\n\r\n**349 - First-order methods on class List**\r\n\r\n> - a method is _first order_ if it doesn't take any functions as arguments\r\n> - **Concatenating two lists**\r\n>   - `xs ::: ys` returns a new list that contains all the elements of `xs`, followed by all the elements of `ys`\r\n>   - `:::` is implemented as a method in class `List`\r\n>   - like `cons`, list concatenation associates to the right:\r\n\r\n```scala\r\n// expression like this:\r\nxs ::: ys ::: zs\r\n// is interpreted as:\r\nxs ::: (ys ::: zs)\r\n```\r\n\r\n> - **Divide and Conquer principle**\r\n>   - design recursive list manipulation algorithms by pattern matching and deconstruction:\r\n\r\n```scala\r\n// my implementation of list concatenation\r\ndef append[T](xs: List[T], ys: List[T]): List[T] = xs match {\r\n  case List() => ys\r\n  case x :: rest => x :: append(rest, ys)\r\n}\r\n```\r\n\r\n> - **List length**\r\n>   - `length` on lists is a relatively expensive operation, when compared to arrays (`O(n)`)\r\n\r\n> - **Accessing the end: `init` and `last`**\r\n>   - `last` returns the last element of a list\r\n>   - `init` returns a list consisting of all elements but the last one\r\n>   - same as `head` and `tail`, they throw an exception when invoked on an empty list\r\n>   - slow when compared to `head` and `tail` since they take linear time, `O(n)`\r\n\r\n> - **Reversing lists: `reverse`**\r\n>   - it's better to organize your data structure so that most accesses are at the head of a list\r\n>   - if an algorithm demands frequent access to the end of a list, it's better to reverse the list first\r\n\r\n```scala\r\n// 'reverse' implemented using concatenation\r\ndef rev[T](xs: List[T]): List[T] = xs match {\r\n  case List() => xs\r\n  case x :: rest => rev(rest) ::: List(x)  // slow: n-1 recursive calls to concatenation \r\n  // alt. with my concatenation\r\n  // case x :: rest => append(rev(rest), List(x))\r\n}\r\n```\r\n\r\n> - **Prefixes and suffixes: `drop`, `take` and `splitAt`**\r\n>   - `xs take n` returns the first `n` elements of the list `xs` (if `n > xs.length` the whole `xs` is returned)\r\n>   - `xs drop n` returns all elements of the list `xs` except the first `n` ones (if `n > xs.length` the empty list is returned)\r\n>   - `xs splitAt n` will return two lists, the same as `(xs take n, xs drop n)`, only it traverses the list just once\r\n\r\n> - **Element selection: `apply` and `indices`**\r\n>   - `xs apply n` returns _n-th_ element\r\n>     - as for all other types, `apply` is implicitly inserted when an object appears in the function position in a method call, so the example from the line above can be written as `xs(n)`\r\n>     - `apply` is implemented as `(xs drop n).head`, thus it's slow (`O(n)`) and rarely used on lists, unlike with arrays\r\n>   - `List(1, 2, 3).indices` returns `scala.collection.immutable.Range(0, 1, 2)`\r\n\r\n> - **Flattening a list of lists: `flatten`**\r\n>   - takes a list of lists and flattens it out to a single list\r\n>   - it can only be used on lists whose elements are all lists (compilation error otherwise)\r\n\r\n```scala\r\nfruit.map(_.toCharArray).flatten\r\n// List(a, p, p, l, e, s, o, r, a, n, g, e, s, p, e, a, r, s)\r\n```\r\n\r\n> - **Zipping lists: `zip` and `unzip`**\r\n>   - `zip` takes two lists and pairs the elements together, dropping any unmatched elements\r\n>   - a useful method is also `zipWithIndex`, which pairs every element with its index\r\n>   - `unzip` converts list of tuples to tuple of lists\r\n\r\n```scala\r\nList('a', 'b') zip List(1, 2, 3)\r\n// List[(Char, Int)] = List((a,1), (b,2))\r\n\r\nval zipped = List('a', 'b').zipWithIndex\r\n// zipped: List[(Char, Int)] = List((a,0), (b,1))\r\n\r\nzipped.unzip\r\n// (List[Char], List[Int]) = (List(a, b), List(1, 2))\r\n```\r\n\r\n> - **Displaying lists: `toString` and `mkString`**\r\n>   - members of the `Traversable` trait, which makes them applicable to all other collections\r\n\r\n```scala\r\n// 'toString' returns canonical representation of a list:\r\nval abc = List(\"a\", \"b\", \"c\")\r\nabc.toString  // List(a, b, c)\r\n\r\n// 'mkString' is more suitable for human consumption:\r\nmkString(pre, sep, post)  // returns:\r\npre + xs(0) + sep + xs(1) + sep + ... + sep + xs(xs.length - 1) + post\r\n\r\n// also:\r\nxs mkString sep  // equals\r\nxs mkString(\"\", sep, \"\")  // also, you can omit all arguments (default to empty string)\r\n\r\n// a variant of 'mkString' which appends string to a 'scala.StringBuilder' object:\r\nval buf = new StringBuilder\r\nabc addString(buf, \"(\", \"; \", \")\")  // StringBuilder = (a; b; c)\r\n```\r\n\r\n> - **Converting lists: `iterator`, `toArray` and `copyToArray`**\r\n>   - `toArray` converts a list to an array and `toList` does the opposite\r\n\r\n```scala\r\nval arr = abc.toArray  // Array(a, b, c)\r\nval xs = arr.toList  // List(a, b, c)\r\n\r\n// to copy all elements of the list to an array, beginning with position 'start':\r\nxs copyToArray (arr, start)\r\n\r\n// before copying, you must ensure that the array is large enough:\r\nval arr2 = new Array[String](7)\r\nxs copyToArray (arr2, 3)  // produces 'Array(null, null, null, a, b, c, null)'\r\n\r\n// to use an iterator to access list elements:\r\nval it = abc.iterator  // it: Iterator[String] = non-empty iterator\r\nit.next  // String = \"a\"\r\nit.next  // String = \"b\"\r\n```\r\n\r\n> - **Merge sort example**\r\n>   - faster than _insertion sort_ for lists - `O(n log(n))`\r\n\r\n```scala\r\n  def msort[T](less: (T, T) => Boolean)(xs: List[T]): List[T] = {\r\n    def merge(xs: List[T], ys: List[T]): List[T] = (xs, ys) match {\r\n      case (Nil, _) => ys\r\n      case (_, Nil) => xs\r\n      case (x :: xs1, y :: ys1) =>\r\n        if(less(x, y)) x :: merge(xs1, ys)\r\n        else y :: merge(xs, ys1)\r\n    }\r\n    \r\n    val n = xs.length / 2\r\n    if(n == 0) xs\r\n    else {\r\n      val (ys, zs) = xs splitAt n\r\n      merge(msort(less)(ys), msort(less)(zs))\r\n    }\r\n  }\r\n\r\n// call it like this:\r\nval res = msort((x: Int, y: Int) => x < y)(9 :: 1 :: 8 :: 3 :: 2 :: Nil)\r\n```\r\n\r\n>   - _currying_ helps us to create specialized functions, predetermined for a particular comparison operation:\r\n\r\n```scala\r\n// reverse sort (underscore stands for missing arguments list, in this case, a list that should be sorted)\r\nval reverseIntSort = msort((x: Int, y: Int) => x > y) _\r\n// reverseIntSort: (List[Int]) => List[Int] = <function>\r\n\r\nreverseIntSort(9 :: 1 :: 8 :: 3 :: 2 :: Nil)\r\n```\r\n\r\n**361 - Higher-order methods on class List**\r\n\r\n> - allow you to express useful list operation patterns in a more concise way\r\n\r\n> - **Mapping over lists: `map`, `flatMap` and `foreach`**\r\n>   - `xs map f`, where `xs` is some `List[T]` and `f` is a function of type `T => U`, applies the function `f` to each list element and returns the resulting list\r\n\r\n```scala\r\nList(1, 2, 3) map (_ + 1)  // returns 'List(2, 3, 4)'\r\n\r\nval words = List(\"the\", \"quick\", \"brown\", \"fox\")\r\nwords map (_.length)  // 'List(3, 5, 5, 3)'\r\nwords map (_.toList.reverse.mkString) // 'List(eht, kciuq, nworb, xof)'\r\n\r\n// 'flatMap' takes a function returning a list of elements as its right operand,\r\n// which it then applies to each list element and flattens the function results\r\nwords flatMap (_.toList)  // 'List(t, h, e, q, u, i, c, k, b, r, o, w, n, f, o, x)'\r\n\r\n// 'map' and 'flatMap' together:\r\nList.range(1, 5) flatMap (i => List.range(1, i) map (j => (i, j)))\r\n// List[(Int, Int)] = List((2,1), (3,1), (3,2), (4,1), (4,2), (4,3))\r\n// 'range' creates a list of all integers in some range, excluding second operand\r\n\r\n// equivalent to:\r\nfor(i <- List.range(1, 5);\r\n    j <- List.range(1, i)) yield (i, j)\r\n\r\n// difference between 'map' and 'flatMap':\r\nList(1, 2, 3, 4) map (_ :: 8 :: Nil)  // List(List(1,8), List(2,8), List(3,8), List(4,8))\r\nList(1, 2, 3, 4) flatMap (_ :: 8 :: Nil)  // List(1, 8, 2, 8, 3, 8, 4, 8)\r\n\r\n// 'foreach' takes a procedure (a function resulting with Unit) as its right operand,\r\n// and applies the procedure to each list element. The result is Unit, not a new list\r\nvar sum = 0\r\nList(1, 2, 3, 4, 5) foreach (sum += _) // sum: Int = 15\r\n```\r\n\r\n> - **Filtering lists: `filter`, `partition`, `find`, `takeWhile`, `dropWhile` and `span`**\r\n\r\n```scala\r\n// 'filter' takes a list and a predicate function and returns the new list containing \r\n// the elements that satisfy the predicate\r\nval xs = List(1, 2, 3, 4, 5)\r\nxs filter (_ % 2 == 0)  // List(2, 4)\r\n\r\n// 'partition' returns a pair of lists, one with elements that satisfy the predicate\r\n// and the other with ones that don't: '(xs filter p, xs filter (!p(_)))'\r\nxs partition (_ % 2 == 0)  // (List(2, 4), List(1, 3, 5))\r\n\r\n// 'find' is similar to 'filter', but returns only the first element, or 'None'\r\nxs find (_ % 2 == 0)  // Some(2)\r\nxs find (_ <= 0)  // None\r\n\r\n// 'takeWhile' returns the longest prefix that satisfy the predicate\r\nval ys = List(1, 2, 3, 4, 3, 2)\r\nys takeWhile (_ <= 3)  // List(1, 2, 3)\r\n\r\n// 'dropWhile' is similar to 'takeWhile', but it drops the elements and returns the rest\r\nys dropWhile (_ <= 3)  // List(4, 3, 2)\r\n\r\n// 'span' returns a pair of lists, the first 'takeWhile' and the second 'dropWhile'\r\n// like 'splitAt', 'span' traverses the list only once\r\nys span (_ <= 3)  // (List(1, 2, 3), List(4, 3, 2))\r\n```\r\n\r\n> - **Predicates over lists: `forall` and `exists`**\r\n\r\n```scala\r\n// 'forall' takes a list and a predicate and returns 'true' if all elements satisfy the predicate\r\n// 'exists' is similar to 'forall', but it returns 'true' if there's at least one element\r\n// that satisfies the predicate\r\ndef hasZeroRow(m: List[List[Int]]) =\r\n  m exists (row => row forall (_ == 0))\r\n\r\nval y = List(0, -1)\r\nval z = List(0, 0, 0)\r\nval zz = List(y, y, z)  //> List(List(0, -1), List(0, -1), List(0, 0, 0))\r\n  \r\nhasZeroRow(zz)          //> Boolean = true\r\n```\r\n\r\n> - **Folding lists: `/:` and `:\\`**\r\n>   - _folding_ combines the elements of a list with some operator\r\n>   - there are equivalent methods named `foldLeft` and `foldRight` defined in class `List`\r\n\r\n```scala\r\nsum(List(1, 2, 3))  // equals 0 + 1 + 2 + 3\r\n// which is a special instance of a fold operation:\r\ndef sum(xs: List[Int]): Int = (0 /: xs) (_ + _)  // equals 0 + el1 + el2 + ...\r\n\r\ndef product(xs: List[Int]): Int = (1 /: xs) (_ * _)  // equals 1 * el1 * el2 * ...\r\n```\r\n\r\n>   - **fold left** operation `(z /: xs)(op)` involves 3 objects:\r\n>     - start value `z`\r\n>     - list `xs`\r\n>     - binary operation `op`\r\n>   - `(z /: List(a, b, c))(op)` equals `op(op(op(z, a), b), c)`\r\n\r\n![List fold left image](https://github.com/mbonaci/scala/blob/master/resources/Scala-fold-left.png?raw=true)\r\n\r\n>   - **fold right** operation `(z \\: xs)(op)` is the reflection of _fold left_\r\n>   - consists of the same 3 operands, but the first two are reversed, list comes first\r\n>   - `(List(a, b, c) :\\ z)(op)` equals `op(a, op(b, op(c, z)))`\r\n\r\n![List fold right image](https://github.com/mbonaci/scala/blob/master/resources/Scala-fold-right.png?raw=true)\r\n\r\n```scala\r\n// implementation of the 'flatten' methods with folding:\r\ndef flattenLeft[T](xss: List[List[T]]) =\r\n  (List[T]() /: xss) (_ ::: _)  // less efficient, since it copies 'xss' 'n - 1' times\r\n\r\ndef flattenRight[T](xss: List[List[T]]) =\r\n  (xss :\\ List[T]()) (_ ::: _)\r\n\r\n// '(xs ::: ys)' takes linear time 'xs.length'\r\n// '[T]' is required due to a limitation in type inferencer\r\n\r\n// list reversal implemented using fold left (takes linear time):\r\ndef reverseLeft[T](xs: List[T]) =\r\n  (List[T]() /: xs) {(ys, y) => y :: ys}  // \"snoc\" (\"cons\" reversed)\r\n\r\n// how we implemented the function:\r\n\r\n/* First we took smallest possible list, 'List()':\r\n  equals (by the properties of reverseLeft)\r\n    reverseLeft(List())\r\n  equals (by the template for reverseLeft)\r\n    (startvalue /: List())(operation)\r\n  equals (by the definition of /:)\r\n    startvalue\r\n*/\r\n\r\n/* Then we took the next smallest list, 'List(x)':\r\n  equals (by the properties of reverseLeft)\r\n    reverseLeft(List(x))\r\n  equals (by the template for reverseLeft)\r\n    (List() /: List(x)) (operation)\r\n  equals (by the definition of /:)\r\n    operation(List(), x)\r\n*/\r\n```\r\n\r\n> - **Sorting lists: `sortWith`**\r\n>   - `xs sortWith before`, where `before` is a function that compares two elements\r\n>   - `x before y` should return `true` if `x` should come before `y` in a sort order\r\n>   - uses _merge sort_ algorithm\r\n\r\n```scala\r\nlist(1, -2, 8, 3, 6) sortWith (_ < _)\r\n// List(-2, 1, 3, 6, 8)\r\n\r\nwords sortWith (_.length > _.length)\r\n// List(quick, brown, the, fox)\r\n```\r\n\r\n**369 - Methods of the `List` object**\r\n\r\n> - all the methods above are implemented in class `List`, whereas the following ones are defined in globally accessible, `List` class's companion object `scala.List`\r\n\r\n> - **Creating lists from their elements: `List.apply`**\r\n>   - `List(1, 2)` is in fact `List.apply(1, 2)`\r\n\r\n> - **Creating a range of numbers: `List.range`**\r\n\r\n```scala\r\n// simplest form\r\nList.range(1, 4)      // List(1, 2, 3)\r\nList.range(1, 7, 2)   // List(1, 3, 5)\r\nList.range(9, 1, -3)  // List(9, 6, 3)\r\n```\r\n\r\n> - **Creating uniform lists: `List.fill`**\r\n>   - creates a list consisting of zero or more copies of the same element\r\n\r\n```scala\r\n// use currying when invoking it:\r\nList.fill(3)('a')  // List(a, a, a)\r\nList.fill(2)(\"oy\")  // List(oy, oy)\r\n\r\n// with more than one argument in the first arg list, it'll make multi-dimensional list\r\nList.fill(2, 3)('b')  // List(List(b, b, b), List(b, b, b))\r\n```\r\n\r\n> - **Tabulating a function: `List.tabulate`**\r\n>   - similar to `fill`, only element isn't fixed, but computed using supplied function\r\n\r\n```scala\r\nval squares = List.tabulate(5)(n => n * n)  // one list with 5 elements\r\n// List(0, 1, 4, 9, 16)\r\n\r\nval multiplication = List.tabulate(3, 4)(_ * _)  // 3 lists with 4 elements\r\n// List[List[Int]] = List(List(0, 0, 0, 0), List(0, 1, 2, 3), List(0, 2, 4, 6))\r\n/*\r\n    0  1  2  3\r\n\r\n0   0  0  0  0\r\n1   0  1  2  3\r\n2   0  2  4  6\r\n*/\r\n```\r\n\r\n> - **Concatenating multiple lists: `List.concat`**\r\n\r\n```scala\r\nList.concat(List(), List('b'), List('c'))  // List(b, c)\r\nList.concat()  // List()\r\n```\r\n\r\n**371 - Processing multiple lists together**\r\n\r\n> - `zipped`, `map`, `forall`, `exists`\r\n> - `zipped` method (defined on tuples) combines the tuple elements sequentially, same as `zip`, first with first, second with second, ...\r\n> - it is used with other (multiple list) methods to apply an operation to combined elements\r\n\r\n```scala\r\n(List(4, 6, 1), List(5, 8)).zipped.map(_ * _)   // List(20, 48)\r\n\r\n(List(\"on\", \"mali\", \"debeli\"), List(2, 4, 5)).zipped\r\n    .forall(_.length == _)                      //> false (two matches)\r\n(List(\"on\", \"mali\", \"debeli\"), List(1, 4, 9)).zipped\r\n    .exists(_.length == _)                      // true (one matches)\r\n(List(\"on\", \"mali\", \"debeli\"), List(2, 4, 6)).zipped\r\n    .exists(_.length != _)                      // false (all matches)\r\n```\r\n\r\n**372 - Understanding Scala's type inference algorithm**\r\n\r\n> - the goal of type inference is to enable users of your method to give as less type information possible, so that function literals are written in more concise way\r\n> - type inference is flow based\r\n> - in a method application `m(args)`, the inferencer:\r\n> \r\n>   - first checks whether the method `m` has a known type\r\n> \r\n>   - if it has, that type is used to infer the expected type of arguments\r\n>     - e.g. in `abcde.sortWith(_ > _)` the type of `abcde` is `List[Char]`\r\n>     - so it knows `sortWith` takes `(Char, Char) => Boolean` and produces `List[Char]`\r\n>     - thus, it expands `(_ > _)` to `((x: Char, y: Char) => x > y)`\r\n> \r\n>   - if the type is not know\r\n>     - e.g. in `msort(_ > _)(abcde)`, `msort` is curried, polymorphic method that takes an argument of type `(T, T) => Boolean` to a function from `List[T]` to `List[T]` where `T` is some as-yet unknown type\r\n>     - the `msort` needs to be instantiated with a specific type parameter before it can be applied to its arguments\r\n>     - inferencer changes its strategy and type-checks method arguments to determine the proper instance type of the method, but it fails, since all it has is `(_ > _)`\r\n>     - one way to solve the problem is to supply `msort` with explicit type parameter\r\n>       - `msort[Char](_ > _)(abcde)  // List(e, d, c, b, a)`\r\n>     - another solution is to rewrite `msort` so that its parameters are swapped:\r\n\r\n```scala\r\ndef msortSwapped[T](xs: List[T])(less: \r\n  (T, T) => Boolean): List[T] = {\r\n  // impl\r\n}\r\n\r\nmsortSwapped(abcde)(_ > _)  // succeeds to compile\r\n// List(e, d, c, b, a)\r\n```\r\n\r\n>   - generally, when tasked to infer type parameters of a polymorphic method, the inferencer consults the types of all value arguments in the first parameter list, but it doesn't go beyond that\r\n>   - so, when we swapped the arguments, it used the known type of the first parameter `abcde` to deduce the type parameter of `msortSwapped`, so it did not need to consult the second argument list in order to determine the type parameter of the method\r\n>   - **suggested library design principle:**\r\n>     - when designing a polymorphic method that takes a non-function and function arguments, place the function argument last in a curried parameter list by its own\r\n>     - that way, the method's correct instance type can be inferred from the non-function arguments, and then that type can be used to type-check the function argument\r\n\r\n### Collections\r\n**377 - Sequences**\r\n\r\n> - groups of data lined up in order, which allows you to get the 'n-th' element\r\n> - **Lists** (immutable linked list)\r\n>   - support fast addition and removal of items to the beginning of the list\r\n>   - slow in manipulating the end of a sequence (add to front and reverse in the end)\r\n>   - do not provide fast access to arbitrary indexes (must iterate through the list)\r\n> - **Arrays**\r\n>   - fast access of an item in an arbitrary position (both, get and update)\r\n>   - represented in the same way as Java arrays (use Java methods that return arrays)\r\n\r\n```scala\r\n// to create an array whose size you know, but you don't know element values\r\nval fiveInts = new Array[Int](5)  // Array(0, 0, 0, 0, 0)\r\n\r\n// to initialize an array when you know the element values:\r\nval fiveToOne = Array(5, 4, 3, 2 , 1)\r\n\r\n// read and update:\r\nfiveInts(0) = fiveToOne(4)\r\nfiveInts  // Array(1, 0, 0, 0, 0)\r\n```\r\n\r\n> - **List buffers** (mutable)\r\n>   - used when you need to build a list by appending to the end\r\n>   - constant time append and prepend operations\r\n>   - `+=` to append, and `+=:` to prepend\r\n>   - when you're done, you can obtain a list with the `toList` method of `ListBuffer`\r\n>   - if your `List` algorithm is not tail recursive, you can use `ListBuffer` with `for` or `while` to avoid the potential stack overflow\r\n\r\n```scala\r\nimport scala.collection.mutable.ListBuffer\r\nval buf = new ListBuffer[Int]\r\n\r\nbuf += 22   // ListBuffer(22)\r\n11 +=: buf  // ListBuffer(11, 22)\r\nbuf.toList  // List(11, 22)\r\n```\r\n\r\n> - **Array buffers** (mutable)\r\n>   - like an array, but you can add and remove elements from the beginning and the end\r\n>   - all `Array` operations are available, though little slower, due to wrapping layer in the implementation\r\n>   - addition and removal take constant time on average, but require linear time if the array needs to be expanded\r\n\r\n```scala\r\nimport scala.collection.mutable.ArrayBuffer\r\nval abuf = new ArrayBuffer[Int]()\r\n\r\n// append using '+='\r\nabuf += 8                   // ArrayBuffer(8)\r\nabuf += 4                   // ArrayBuffer(8, 4)\r\n\r\nabuf.length                 // Int = 2\r\nabuf(1)                     // Int = 4\r\n```\r\n\r\n> - **Strings** (via **StringOps**)\r\n>   - since `Predef` has an implicit conversion from `String` to `StringOps`, you can use any string like a sequence\r\n\r\n```scala\r\ndef hasUpperCaseLetter(s: String) = s.exists(_.isUpper)  // String doesn't have 'exists'\r\n\r\nhasUpperCaseLetter(\"glupson 1\")  // false\r\nhasUpperCaseLetter(\"glupsoN 1\")  // true\r\n```\r\n\r\n**381 - Sets and maps**\r\n\r\n> - by default, when you write `Set` or `Map`, you get an immutable object\r\n> - for mutable objects, you need explicit import\r\n\r\n```scala\r\nobject Predef {\r\n  type Map[A, +B] = collection.immutable.Map[A, B]\r\n  type Set[A] = collection.immutable.Set[A]\r\n  val Map = collection.immutable.Map\r\n  val Set = collection.immutable.Set\r\n  // ...\r\n}\r\n// the 'type' keyword is used in 'Predef' to define aliases for fully qualified names\r\n// the 'vals' are initialized to refer to the singleton objects\r\n// so 'Map' == 'Predef.Map' == 'scala.collection.immutable.Map'\r\n\r\n// to use the immutable and mutable in the same source file:\r\nimport scala.collection.mutable\r\nval mutaSet = mutable.Set(1, 2)  // scala.collection.mutable.Set[Int]\r\nval set = Set(1, 2)              // scala.collection.immutable.Set[Int]\r\n```\r\n\r\n> - **Using sets**\r\n>   - the key characteristic is that they maintain uniqueness of their elements, as defined by `==`\r\n\r\n```scala\r\nval text = \"run Forest, run. That's it Forest! Run!\"\r\nval wordsArray = text.split(\"[ !,.]+\")  // Array(run, Forest, Run, That's, it, Forest, Run)\r\nimport scala.collection.mutable\r\nval set = mutable.Set.empty[String]  // Set()\r\n\r\nfor(word <- wordsArray)\r\n  set += word.toLowerCase\r\n  \r\nset  // Set(it, run, that's, forest)\r\n```\r\n\r\n![Set hierarchy](https://github.com/mbonaci/scala/blob/master/resources/Scala-sets-hierarchy.png?raw=true)\r\n\r\n```scala\r\n/********************************************************************************/\r\n/*********************      Common operations for sets      *********************/\r\n/********************************************************************************/\r\n\r\nval nums = Set(1, 2, 3)          // crates an immutable set\r\nnums.toString                    // returns Set(1, 2, 3)\r\nnums + 5                         // adds an element (returns Set(1, 2, 3, 5))\r\nnums - 3                         // removes the element (returns Set(1, 2))\r\nnums ++ List(5, 6)               // adds multiple elements (returns Set(1, 2, 3, 5, 6))\r\nnums -- List(1, 2)               // removes multiple elements\r\nnums & Set(1, 3, 5, 7)           // returns the intersection of two sets (Set(1, 3))\r\nnums.size                        // returns the size of the set\r\nnums.contains(3)                 // checks for inclusion\r\n\r\nimport scala.collection.mutable  // makes the mutable collections easy to access\r\nval words = mutable.Set.empty[String]  // creates an empty, mutable set (HashSet)\r\nwords.toString                   // returns Set()\r\nwords += \"the\"                   // adds an element (Set(the))\r\nwords -= \"the\"                   // removes an element (Set())\r\nwords ++= List(\"do\", \"re\", \"mi\") // adds multiple elements\r\nwords --= List(\"do\", \"re\")       // removes multiple elements\r\nwords.clear                      // removes all elements\r\n```\r\n\r\n> - **Using maps**\r\n>   - when creating a map, you must specify two types (key, value)\r\n\r\n```scala\r\n// word count using a map\r\ndef main(args: Array[String]): Unit = {\r\n  val count = countWords(\"run forest, run fast! run forest!\")\r\n  println(count.toString)  // Map(fast -> 1, run -> 3, forest -> 2)\r\n}\r\n\r\nimport scala.collection.mutable\r\ndef countWords(text: String): mutable.Map[String, Int] = {\r\n  val wordsArray = text.split(\"[ !,.]+\")\r\n  val map = mutable.Map.empty[String, Int]\r\n  \r\n  for(w <- wordsArray)\r\n    if(map.contains(w))\r\n      map(w) = map(w) + 1\r\n    else\r\n      map += (w -> 1)\r\n      \r\n  map\r\n}\r\n```\r\n\r\n![Map hierarchy](https://github.com/mbonaci/scala/blob/master/resources/Scala-maps-hierarchy.png?raw=true)\r\n\r\n```scala\r\n/********************************************************************************/\r\n/*********************      Common operations for maps      *********************/\r\n/********************************************************************************/\r\n\r\nval m = Map(\"i\" -> 1, \"ii\" -> 2)  // crates an immutable map\r\nm.toString                        // returns Map(i->1, ii->2)\r\nm + (\"vi\" -> 6)                   // adds an entry (returns Map(i->1, ii->2, vi->6)\r\nm - \"ii\"                          // removes the entry (returns Map(i->1, vi->6))\r\nm ++ List(\"iii\" -> 5, \"v\" -> 5)   // adds multiple entries\r\nm -- List(\"i\", \"ii\")              // removes multiple entries\r\nm.size                            // returns the size of the map\r\nm.contains(\"ii\")                  // checks for inclusion\r\nm(\"ii\")                           // returns 2\r\nm.keys                            // returns Iterable over keys (\"i\" and \"ii\")\r\nm.keySet                          // returns keys as a set (Set(i, ii))\r\nm.values                          // returns Iterable over values (1, 2)\r\nm.isEmpty                         // indicates whether the map is empty\r\n\r\nimport scala.collection.mutable   // makes the mutable collections easy to access\r\nval w = mutable.Map.empty[String, Int]  // creates an empty, mutable map (HashMap)\r\nw.toString                        // returns Map()\r\nw += (\"one\" -> 1)                 // adds an entry (Map(one->1))\r\nw -= \"one\"                        // removes an entry (Map())\r\nw ++= List(\"st\" -> 1, \"nd\" -> 2, \"rd\" - 3)  // adds multiple entries\r\nw --= List(\"st\", \"nd\")            // removes multiple entries\r\nw.clear                           // removes all entries\r\n```\r\n\r\n> - **Default sets and maps**\r\n>   - `mutable.Map()` factory method returns `mutable.HashMap` (analogous for mutable set)\r\n>   - for immutable sets and maps, it depends on how many elements you pass to it:\r\n\r\n```scala\r\n// rules for sets (the same applies for maps)\r\nNumber of elements  Implementation (used to maximize performance)\r\n0                   scala.collection.immutable.EmptySet\r\n1                   scala.collection.immutable.Set1\r\n2                   scala.collection.immutable.Set2\r\n3                   scala.collection.immutable.Set3\r\n4                   scala.collection.immutable.Set4\r\n5 or more           scala.collection.immutable.HashSet (implemented as trie)\r\n```\r\n\r\n> - **Sorted sets and maps**\r\n>   - a set or map whose iterator returns elements in a particular order\r\n>   - for this purpose, `collections` library provides traits `SortedSet` and `SortedMap`, which are implemented using `TreeSet` and `TreeMap`, and which use a **red-black tree** to keep `TreeSet` elements and `TreeMap` keys in order\r\n>   - the order is determined by the `Ordered` trait, which the element type of set, or key type of map must either mix in or be implicitly convertible to\r\n\r\n```scala\r\nimport scala.collection.immutable.TreeSet\r\nval ts = TreeSet(9, 2, 5, 1, 8, 6, 4, 3)  // TreeSet(1, 2, 3, 4, 5, 6, 8, 9)\r\n\r\nimport scala.collection.immutable.TreeMap\r\nval tm = TreeMap(8 -> 'e', 7 -> 'a', 1 -> 'w')  // Map(1 -> w, 7 -> a, 8 -> e)\r\nval otm = tm + (2 -> 'u')  // Map(1 -> w, 2 -> u, 7 -> a, 8 -> e)\r\n```\r\n\r\n**390 - Selecting mutable versus immutable collections**\r\n\r\n> - immutable collections can usually be stored more compactly, especially small maps and sets, e.g. empty mutable map, in its default representation, HashMap, takes around 80 bytes, with 16 bytes for every new element, while immutable Map1 takes only 16 bytes, and Map4 around 40 bytes\r\n> - immutable map is a single object that's shared between all references, so referring to it costs just a single pointer field\r\n> - to make the switch between mutable and immutable, Scala provides some syntactic sugar:\r\n\r\n```scala\r\n// if you declare immutable set or map as 'var':\r\nvar toys = Set(\"bear\", \"car\")  // scala.collection.immutable.Set[String] = Set(bear, car)\r\ntoys += \"doll\"  // a new set is created and then 'toys' is reassigned to it\r\ntoys  // scala.collection.immutable.Set[String] = Set(bear, car, doll)\r\n\r\ntoys -= \"bear\"  // works with any other operator method ending with '='\r\ntoys  // scala.collection.immutable.Set[String] = Set(car, doll)\r\n\r\n// then, if you want to switch to mutable the only thing you need is:\r\nimport scala.collection.mutable.Set\r\n\r\n// this works with any type, not just collections\r\n```\r\n\r\n**392 - Initializing collections**\r\n\r\n> - the common way to create and initialize a collection is to pass the initial elements to a factory method on the companion object (invokes `apply`)\r\n> - when an inferred type is not what you need, explicitly set type of your collection:\r\n\r\n```scala\r\nval stuff = mutable.Set[Any](42)\r\nstuff += \"green\"  // scala.collection.mutable.Set[Any] = Set(42, green)\r\n```\r\n\r\n**394 - Converting to array or list**\r\n\r\n> - to convert a collection to array, simply call `toArray`\r\n> - to convert a collection to list, simply call `toList`\r\n> - there is a speed penalty, since all the elements need to be copied during the conversion process, which may be problematic for large collections\r\n> - the order of elements in the resulting list or array will be the order produced by an iterator obtained by invoking `elements` on the source collection\r\n> - in case of sorted collections, the resulting list or array will also be sorted:\r\n\r\n```scala\r\nval ts = TreeSet(8, 3, 4, 1)\r\nval a = ts.toArray  // Array(1, 3, 4, 8)\r\nval l = ts.toList   // List(1, 3, 4, 8)\r\n```\r\n\r\n**395 - Converting between mutable and immutable sets and maps**\r\n\r\n> - create a collection of the new type using the `empty` method and then add the new elements using method for adding multiple entries (`++` for mutable and `++=` for immutable)\r\n\r\n```scala\r\n// converting immutable TreeSet to a mutable set and back\r\nval ts = TreeSet(9, 2, 5, 1, 8, 6, 4, 3)\r\nval ms = mutable.Set.empty ++= ts  // mutable.Set[Int] = Set(9, 1, 5, 2, 6, 3, 4, 8)\r\nval is = Set.empty ++ mts        // immutable.Set[Int] = Set(5, 1, 6, 9, 2, 3, 8, 4)\r\n```\r\n\r\n**396 - Tuples**\r\n\r\n> - a tuple combines a fixed number of items together so they can be passed around as a whole\r\n> - unlike arrays and lists, tuple can hold objects of different types\r\n> - tuples save you the effort of defining simplistic, data-heavy (as opposed to logic-heavy) classes\r\n> - since they can contain objects of different types, they don't inherit from `Traversable`\r\n> - a common usage pattern of tuples is returning multiple values from a method\r\n> - to access elements of a tuple you can use methods `_1`, `_2`, ...\r\n> - you can deconstruct a tuple like this: `val (word, idx) = someTuple2` (if you leave off the parentheses, both `word` and `idx` vals are assigned with a whole tuple)\r\n\r\n```scala\r\ndef findLongest(words: Array[String]): Tuple2[String, Int] = {\r\n  var len = -1\r\n  var index = -1\r\n  \r\n  for(word <- words) {\r\n    if(word.length > len) {\r\n      index = words.indexOf(word)\r\n      len = word.length\r\n    }\r\n  }\r\n  (words(index), index)\r\n\r\n}  // findLongest: (words: Array[String])(String, Int)\r\n\r\nvar toys = Set(\"bear\", \"car\", \"doll\", \"loading truck\")\r\nval tup = findLongest(toys.toArray)  // tup: (String, Int) = (loading truck,3)\r\n```\r\n\r\n### Stateful Objects\r\n**402 - Reassignable variables and properties**\r\n\r\n> - every non-private `var x` member of an object implicitly defines getter and setter\r\n> - getter is named `x` and setter is named `x_=`\r\n> - getter and setter inherit access from their `var`\r\n\r\n```scala\r\nvar hour = 6\r\n// generates\r\nprivate[this] var h = 6\r\n// and getter\r\nhour\r\n// and setter\r\nhour_=\r\n\r\n// the following two class definitions are identical:\r\nclass Time {\r\n  var hour = 6\r\n  var minute = 30\r\n}\r\n\r\nclass Time {\r\n  private[this] var h = 6  // access qualifier: private up to this (invisible outside)\r\n  private[this] var m = 30\r\n\r\n  def hour: Int = h\r\n  def hour_=(x: Int) { h = x }\r\n\r\n  def minute: Int = m\r\n  def minute_=(x: Int) { m = x }\r\n}\r\n\r\n// you can define getters and setters explicitly\r\nclass Time {\r\n  private[this] var h = 6\r\n  private[this] var m = 30\r\n\r\n  def hour: Int = h\r\n  def hour_=(x: Int) {\r\n    require(0 <= x && x < 24)\r\n    h = x\r\n  }\r\n}\r\n\r\n// getters and setters can be defined without the accompanying field:\r\nclass Thermometer {\r\n  var celsius: Float = _  // initialized to default value (0)\r\n\r\n  def fahrenheit = celsius * 9 / 5 + 32\r\n\r\n  def fahrenheit_= (f: Float) {\r\n    celsius = (f - 32) * 5 / 9\r\n  }\r\n\r\n  override def toString = fahrenheit + \"F/\" + celsius + \"C\"\r\n}\r\n```\r\n\r\n> - initializer sets a variable to default value of that type:\r\n>   - `0`       - for numeric types\r\n>   - `false`   - for booleans\r\n>   - `null`    - for reference types\r\n> - works the same way as uninitialized variables in Java\r\n\r\n**405 - Case study: Discrete event simulation**\r\n\r\n> - internal DSL is a DSL implemented as a library inside another language, rather than being implemented on its own\r\n\r\n### Type Parameterization\r\n**422 - Information hiding**\r\n\r\n> - to hide a primary constructor add `private` modifier in front of the class parameter list\r\n> - private constructor can only be accessed from withing the class itself or its companion object\r\n\r\n```scala\r\nclass ImmutableQueue[T] private (\r\n  private val leading: List[T]\r\n  private val trailing: List[T]\r\n)\r\n\r\nnew Queue(List(1, 2), List(3))  // error: ImmutableQueue cannot be accessed in object $iw\r\n\r\n// now one possibility is to add auxiliary constructor, e.g.:\r\ndef this() = this(Nil, Nil)  // takes empty lists\r\n\r\n// auxiliary constructor that takes 'n' parameters of type 'T':\r\ndef this(elems: T*) = this(elems.toList, Nil)  // 'T*' - repeated parameters\r\n\r\n// another possibility is to add a factory method\r\n// convenient way of doing that is to define an ImmutableQueue object\r\n// that contains 'apply' method\r\n// by placing this object in the same source file with the ImmutableQueue class\r\n// it becomes its companion object\r\nobject ImmutableQueue {\r\n  // creates a queue with initial elements 'xs'\r\n  def apply[T](xs: T*) = new ImmutableQueue[T](xs.toList, Nil)\r\n}\r\n\r\n// since a companion object contains method 'apply', clients can create queues with:\r\nImmutableQueue(1, 2, 3)  // expands to ImmutableQueue.apply(1, 2, 3)\r\n```\r\n\r\n**428 - Private classes**\r\n\r\n> - more radical way of information hiding that hides a class itself\r\n> - then, you export a trait that reveals the public interface of a class:\r\n\r\n```scala\r\ntrait Queue[T] {\r\n  def head: T                  // public\r\n  def tail: Queue[T]\r\n  def enqueue(x: T): Queue[T]\r\n}\r\n\r\n\r\nobject Queue {\r\n  def apply[T](xs: T*): Queue[T] =\r\n    new QueueImpl[T](xs.toList, Nil)\r\n    \r\n  private class QueueImpl[T](  // private inner class\r\n    private val leading: List[T],\r\n    private val trailing: List[T]\r\n  ) extends Queue[T] {         // mixes in the trait, which has access to private class\r\n    \r\n    def mirror =\r\n      if (leading.isEmpty)\r\n        new QueueImpl(trailing.reverse, Nil)\r\n      else\r\n        this\r\n        \r\n    def head: T = mirror.leading.head\r\n    \r\n    def tail: QueueImpl[T] = {\r\n      val q = mirror\r\n      new QueueImpl(q.leading.tail, q.trailing)\r\n    }\r\n    \r\n    def enqueue(x: T) =\r\n      new QueueImpl(leading, x :: trailing)\r\n  }\r\n  \r\n}\r\n```\r\n\r\n**429 - Variance annotations**\r\n\r\n> - `Queue`, as defined in previous listing is a trait, not a type, so you cannot create variables of type `Queue`\r\n> - instead, trait `Queue` enables you to specify parameterized types, such as `Queue[String]`, `Queue[AnyRef]`\r\n> - thus, `Queue` is a trait, and `Queue[String]` is a type\r\n> - this kind of traits are called **type constructors** (you can construct a type by specifying a type parameter, which is analogous to plain-old constructor with specified value parameter)\r\n> - _type constructors_ generate a family of types\r\n> - it is also said that the `Queue` is a **generic trait**\r\n> - in Scala, **generic types have _nonvariant_ (rigid) subtyping**\r\n> - consequently, `Queue[String]` is not a subtype of `Queue[AnyRef]`\r\n> - however, you can demand **covariant** (flexible) subtyping by prefixing a type parameter with `+`:  \r\n\r\n`trait Queue[+T] { ... }`\r\n\r\n> - besides `+` **parameter's variance annotation**, there's also a `-`, which indicates **contravariant** subtyping:  \r\n\r\n`trait Queue[-T] { ... }`\r\n\r\n> - then, if `T` is a subtype of `S`, this would imply that `Queue[S]` is a subtype of `Queue[T]`\r\n\r\n**432 - Variance and arrays**\r\n\r\n> - arrays in Java are treated as covariants:\r\n\r\n```java\r\n// Java\r\nString[] a1 = { \"abc\" };\r\nObject[] a2 = a1;\r\na2[0] = new Integer(8);  // ArrayStroreException (Integer placed in String[])\r\nString s = a1[0];\r\n```\r\n\r\n> - because of that, arrays in Scala are nonvariant:\r\n\r\n```scala\r\nval a1 = Array(\"abc\")\r\nval a2 = Array[Any] = a1  // error: type mismatch, found Array[String], required Array[Any]\r\n```\r\n\r\n> - to interact with legacy methods in Java that use an `Object` array as a means to emulate generic array, Scala lets you cast an array of `T`s to an array of any supertype of T:\r\n\r\n```scala\r\nval a2: Array[Object] = a1.asInstanceOf[Array[Object]]\r\n```\r\n\r\n**433 - Checking variance annotations**\r\n\r\n> - to verify the correctness of variance annotations, the compiler classifies all positions in a class or trait body as **positive**, **negative** or **neutral**\r\n> - a _position_ is any location in the class (or trait) body where a type parameter may be used\r\n> - e.g. every method value parameter is a position, because it has a type and therefore a type parameter could appear in that position\r\n> type parameters annotated with `+` can only be used in _positive_ positions, `-` in negative, and a type parameter without variance annotation may be used in any position (so it's the only one that can be used in _neutral_ positions)\r\n> - compiler classifies positions like this:\r\n>   - the positions at the top level of the class are classified as positive\r\n>   - positions at deeper nesting levels are classified the same as their enclosing level, but with exceptions where the classifications changes (flips):\r\n>     - method value parameter positions are classified to the flipped classification relative to positions outside the method (when flipped, neutral stays the same, negative position becomes positive, and vice versa)\r\n>     - classification is also flipped at the type parameters of methods\r\n>     - it is sometimes flipped at the type argument position of a type (e.g. `Arg` in `C[Arg]`), depending on the variance of the corresponding type parameter (if C's type param is annotated with `+`, then the classification stays the same, and if it's `-`, then it flips, and if has no variance then it's changed to neutral)\r\n> - because it's hard to keep track of variance position, it's good to know that the compiler does all the work for you\r\n\r\n```scala\r\n// variance checks by the compiler (postfix signs represent position classification):\r\nabstract class Cat[-T, +U] {\r\n  def meow[W-](volume: T-, listener: Cat[U+, T-]-): Cat[Cat[U+, T-]-, U+]+\r\n}\r\n// since T is always used in negative position and U in positive, the class is type correct\r\n```\r\n\r\n**437 - Lower bounds**\r\n\r\n> - `Queue[T]` cannot be made covariant in `T` because `T` appears as a type of a parameter of the `enqueue` method, and that's a negative position\r\n> - there's still a way to solve that problem by generalizing `enqueue` by making it polymorphic (i.e. giving the method itself a type parameter) and using a **lower bound** for its type parameter:\r\n\r\n```scala\r\nclass Queue[+T](private val leading: List[T]), private val trailing: List[T]) {\r\n  // defines T as the lower bound for U (U is required to be a supertype of T)\r\n  def enqueue[U >: T](x: U) = // U is negative (flip) and T is positive (two flips)\r\n    new Queue[U](leading, x :: trailing)\r\n    // ...\r\n}\r\n// the param to 'enqueue' is now of type 'U'\r\n// the method's return type is now 'Queue[U]', instead of 'Queue[T]'\r\n// imagine e.g. class Fruit with two subclasses, Apple and Orange\r\n// With the new definition of class Queue, it is possible to append an Orange to a \r\n// Queue[Apple] and the result will be of type Queue[Fruit]\r\n```\r\n\r\n**438 - Contravariance**\r\n\r\n> - **Liskov Substitution Principle** says that it is safe to assume that a type `T` is a subtype of a type `U` if you can substitute a value of type `T` wherever a value of type `U` is required\r\n> - the principle holds if `T` supports the same operations as `U` and all of `T's` operations require less and provide more than the corresponding operations in `U`\r\n\r\n```scala\r\n// example of Contravariance of a function parameter\r\nclass Publication(val title: String)\r\nclass Book(title: String) extends Publication(title)\r\n\r\nobject Library {\r\n  val books: Set[Book] =\r\n    Set(\r\n      new Book(\"Programming in Scala\"),\r\n      new Book(\"Walden\")\r\n    )\r\n\r\n  def printBookList(info: Book => AnyRef) {  // requires function from Book to AnyRef\r\n    for (book <- books) println(info(book))  // always passes a Book to a function\r\n  }\r\n}\r\n\r\nobject Customer extends Application {\r\n  def getTitle(p: Publication): String = p.title  // accesses only Publication\r\n  Library.printBookList(getTitle)  // provides function from Publication to String\r\n}\r\n// any method declared in Publication is also available on its subclass Book\r\n// Publication => String is a subtype of Book => AnyRef\r\n```\r\n\r\n![Map hierarchy](https://github.com/mbonaci/scala/blob/master/resources/Scala-covariance-contravariance.png?raw=true)\r\n\r\n> - because the result type of a `Function1` is defined as _covariant_, the inheritance\r\nrelationship of the two result types, shown at the right of the image, is in the same direction as that of the two functions shown in the center\r\n> - because the parameter type of a `Function1` is defined as _contravariant_, the inheritance relationship of the two parameter types, shown at the left of the image, is in the opposite direction as that of the two functions\r\n\r\n**441 - Object private data**\r\n\r\n> - object or class components that are declared as `private[this]`\r\n> - may be accessed only from within their containing object, in which they are defined\r\n> - accesses to vars from the same object do not cause problems with variance\r\n> - variance rules can be broken by having a reference to a containing object that has a statically weaker type than the type the object was defined with\r\n> - for object private values, this is not possible\r\n> - variance checking has a special case for object private definitions, which is that such definitions are omitted when checking correctness of variance positions\r\n\r\n```scala\r\n/*\r\n * Purely functional Queue that performs at most one trailing\r\n * to leading adjustment for any sequence of head operations\r\n * Yes, it has reassignable fields, but they are private,\r\n * thus invisible to any client using the class\r\n */\r\nclass CovariantQueue[+T] private (\r\n    private[this] var leading: List[T],  // object private vars\r\n    private[this] var trailing: List[T]\r\n    // without [this]:\r\n    // error: covariant type T occurs in contravariant position\r\n    // in type List[T] of parameter of setter leading_=\r\n  ) {\r\n  private def mirror() =\r\n    if (leading.isEmpty) {\r\n      while (!trailing.isEmpty) {\r\n        leading = trailing.head :: leading\r\n        trailing = trailing.tail\r\n      }\r\n    }\r\n  \r\n  def head: T = {\r\n    mirror()\r\n    leading.head\r\n  }\r\n  \r\n  def tail: CovariantQueue[T] = {\r\n    mirror()\r\n    new CovariantQueue(leading.tail, trailing)\r\n  }\r\n  \r\n  def enqueue[U >: T](x: U) =\r\n    new CovariantQueue[U](leading, x :: trailing)\r\n\r\n}\r\n```\r\n\r\n**443 - Upper bounds**\r\n\r\n> - with the `T <: Ordered[T]` you indicate that the type parameter `T` has an upper bound `Ordered[T]`, which means that the passed element's type must be a subtype of `Ordered`\r\n> - used e.g. to require that the passed type mixes in a trait (i.e. is a subtype of trait)\r\n\r\n```scala\r\n// requires that passed list type mixes in Ordered trait\r\ndef orderedMergeSort[T <: Ordered[T]](xs: List[T]): List[T] = {\r\n  def merge(xs: List[T], ys: List[T]): List[T] =\r\n    (xs, ys) match {\r\n      case (Nil, _) => ys\r\n      case (_, Nil) => xs\r\n      case (x :: xs1, y :: ys1) =>\r\n        if (x < y) x :: merge(xs1, ys)\r\n        else y :: merge(xs, ys1)\r\n    }\r\n  val n = xs.length / 2\r\n  if (n == 0) xs\r\n  else {\r\n    val (ys, zs) = xs splitAt n\r\n    merge(orderedMergeSort(ys), orderedMergeSort(zs))\r\n  }\r\n}\r\n\r\n// this is not a most general way to implement mergeSort, since you cannot pass e.g. List[Int]\r\n// that's achieved with 'implicit parameters' and 'view bounds' (section 21.6)\r\n```\r\n\r\n### Abstract Members\r\n\r\n> - a member of a class or trait is `abstract` if the member does not have a complete definition in the class\r\n> - abstract members are intended to be implemented by subclasses\r\n> - in Scala, besides methods, you can declare abstract fields and even abstract types as members of classes and traits (vals, vars, methods and types)\r\n> - a concrete implementation needs to fill in definitions for each of its abstract members:\r\n\r\n```scala\r\n// declaration of all four types of abstract members\r\ntrait Abstract {\r\n  type T\r\n  def transform(x: T): T\r\n  val initial: T\r\n  var current: T\r\n}\r\n\r\n// the concrete implementation of four type of abstract members\r\nclass Concrete extends Abstract {\r\n  type T = String  // defines type 'T' as an alias of type 'String'\r\n  def transform(x: String) = x + x\r\n  val initial = \"hi\"\r\n  var current = initial\r\n}\r\n```\r\n\r\n**448 - Type members**\r\n\r\n> - **abstract types** are always members of some class or trait\r\n> - traits are abstract by definition\r\n> - a **non-abstract type member** is a way to define a new name (alias) for a type\r\n> - one reason to use a type member is to define a short, descriptive alias for a type whose real name is more verbose or less obvious in meaning (helps clarify the code)\r\n> - the other main use of type members is to declare abstract types that must be defined in subclasses\r\n\r\n**449 - Abstract vals**\r\n\r\n> - have a form like `val initial: String`\r\n> - `val` is given a name and a type, but not its value\r\n> - use it when you know that each instance of the class will have an unchangeable value, but you don't know what that value will be\r\n> - its concrete implementation must be a `val` (may not be `var` or `def`)\r\n> - guaranteed to return always the same value, unlike methods, which could be implemented by a concrete method that returns a different value every time it's called\r\n> - **abstract method declarations** may be implemented by both, concrete method and concrete `val` definitions\r\n\r\n**450 - Abstract vars**\r\n\r\n> - implicitly declare abstract getters and setters, just like non-abstract `vars` do\r\n> - reassignable field is not created\r\n\r\n```scala\r\ntrait AbstractTime {\r\n  var hour: Int\r\n  var minute: Int\r\n}\r\n\r\n// gets expanded to:\r\ntrait AbstractTime {\r\n  def hour: Int\r\n  def hour_=(x: Int)\r\n  def minute: Int\r\n  def minute_=(x: Int)\r\n}\r\n```\r\n\r\n**451 - Initializing abstract vals**\r\n\r\n> - abstract vals sometimes play a role of superclass parameters, i.e. they let you provide details in a subclass that are missing in a superclass\r\n> - that is particularly important for _traits_, because they don't have a constructor to which you could pass parameters\r\n\r\n```scala\r\n// instead of class with two class parameters\r\ntrait RationalTrait {\r\n  val numerArg: Int  // 0 until mixed in\r\n  val denomArg: Int\r\n}\r\n\r\ndef main(args: Array[String]): Unit = {\r\n  // example implementation of two abstract vals\r\n  // yields an instance of an anonymous class\r\n  // which mixes in the trait and is defined by the body\r\n  new RationalTrait {\r\n    val numerArg = 1  // set to 1 as part of the initialization of the anonymous class\r\n    val denomArg = 2  // but the anonymous class is initialized after the RationalTrait\r\n  }                   // in the meantime, vals are set to their type's default values\r\n}\r\n```\r\n\r\n> - a class parameter argument is evaluated **before** it is passed to the class constructor (unless it's a by-name parameter)\r\n> - an implementing `val` definition in a subclass is evaluated only **after** the superclass has been initialized\r\n> - e.g. class parameters of `Rational(expr1, expr2)` are evaluated just before instantiation of the `Rational` object, but `RationalTrait`'s vals are evaluated as part of the initialization of the **anonymous class**\r\n\r\n```scala\r\ntrait ProblematicRationalTrait {\r\n  val numerArg: Int  // initialized once an anonymous class is created\r\n  val denomArg: Int  // which happens after the trait is initialized\r\n  require(denomArg != 0)  // throws \"requirement failed\" exception\r\n  private val g = gcd(numerArg, denomArg)\r\n  val numer = numerArg / g\r\n  val denom = denomArg / g\r\n  \r\n  private def gcd(a: Int, b: Int): Int =\r\n    if (b == 0) a\r\n    else gcd(b, a % b)\r\n  \r\n  override def toString = numer + \"/\" + denom\r\n}\r\n\r\n// when you execute this, 'require' fails, since Int vals are 0 until \r\nval x = 2\r\nval fun = new ProblematicRationalTrait {\r\n  val numerArg = 1 * x\r\n  val denomArg = 2 * x\r\n}\r\n```\r\n\r\n**453 - Pre-initialized fields**\r\n\r\n> - let you initialize a field of a subclass before the superclass is called\r\n> - achieved by putting field definition in braces before superclass constructor call:\r\n\r\n```scala\r\n// anonymous class creation:\r\nnew {\r\n  val numerArg = 1 * x\r\n  val denomArg = 2 * x\r\n} with ProblematicRationalTrait\r\n\r\n// object definition:\r\nobject twoThirds extends {\r\n  val numerArg = 2\r\n  val denomArg = 3\r\n} with ProblematicRationalTrait\r\n\r\n// subclass definition:\r\nclass RationalClass(n: Int, d: Int) extends {\r\n  val numerArg = n\r\n  val denomArg = d\r\n} with ProblematicRationalTrait {\r\n  def + (that: RationalClass) = new RationalClass(\r\n    numer * that.denom + that.numer * denom,\r\n    denom * that.denom\r\n  )\r\n}\r\n// in all cases initialization section comes before the trait is mentioned\r\n```\r\n\r\n> - because pre-initialized fields are initialized before the superclass constructor is called, their initializers cannot refer to the object that's being constructed\r\n> - so, if such an object refers to `this`, the reference goes to the object containing the class or object that's being constructed, not the constructed object itself:\r\n\r\n```scala\r\nobject AbsRat {\r\n  // ...\r\n  val rat = new {\r\n    val numerArg = 1\r\n    val denomArg = this.numerArg * 2  // value numerArg is not member of object AbsRat\r\n  } with ProblematicRationalTrait\r\n  // ...\r\n```\r\n\r\n**455 - Lazy vals**\r\n\r\n> - evaluated the first time the val is used\r\n> - never evaluated more than once (the result of first time evaluation is stored in val)\r\n> - Scala objects are also initialized on demand, in fact an object definition can be thought of as a shorthand definition of a lazy val with an anonymous class that describes the object's contents\r\n> - since lazy vals get executed on demand, their textual order is not important when determining the order of their initialization\r\n> - in the presence of side effects (i.e. when our code produces or is affected by mutations), initialization order starts to matter and then it can be difficult to determine the actual order, which is why lazy vals are an ideal complement to functional objects\r\n\r\n```scala\r\ntrait LazyRationalTrait {\r\n  val numerArg: Int\r\n  val denomArg: Int\r\n  lazy val numer = numerArg / g\r\n  lazy val denom = denomArg / g\r\n  override def toString = numer + \"/\" + denom\r\n  \r\n  private lazy val g = {\r\n    require(denomArg != 0)\r\n    gcd(numerArg, denomArg)\r\n  }\r\n  \r\n  private def gcd(a: Int, b: Int): Int =\r\n    if (b == 0) a else gcd(b, a % b)\r\n}\r\n\r\n// using LazyRationalTrait from the interpreter:\r\nval x = 2\r\nnew LazyRationalTrait {\r\n  val numerArg = 1 * x\r\n  val denomArg = 2 * x\r\n}\r\n// res2: LazyRationalTrait = 1/2\r\n\r\n// 1. - fresh instance of LazyRationalTrait gets created and the initialization code\r\n//      of LazyRationalTrait is run (fields are not initialized)\r\n// 2. - the primary constructor of the anonymous subclass is executed (expression 'new')\r\n//    - this involves the initialization of 'numerArg' with 2 and 'denomArg' with 4\r\n// 3. - the 'toString' method is invoked on the constructed object (by the interpreter)\r\n// 4. - the 'numer' field is accessed for the first time, by the 'toString' method\r\n// 5. - the initializer of 'numer' accesses the private field 'g', so 'g' is evaluated\r\n//    - the evaluation of 'g' accesses 'numerArg' and 'denomArg' (from step 2)\r\n// 6. - the 'toString' method accesses the value of 'denom', which causes its evaluation\r\n//    - that evaluation accesses the values of 'denomArg' and 'g'\r\n//    - the initializer of the 'g' field is not re-evaluated (it's a 'val', not 'def')\r\n// 7. - finally, the resulting string \"1/2\" is constructed and printed\r\n```\r\n\r\n**459 - Abstract types**\r\n\r\n> - used as a placeholder for a type that will be defined further down the hierarchy\r\n\r\n```scala\r\n// the type of food cannot be determined at the 'Animal' level, every subclass defines it\r\nclass Food\r\nabstract class Animal {\r\n  type SuitableFood <: Food  // upper bound is 'Food' (requires subclass of 'Food')\r\n  def eat(food: SuitableFood)\r\n}\r\n\r\nclass Grass extends Food\r\nclass Cow extends Animal {\r\n  type SuitableFood = Grass  // 'Cow' fixes its 'SuitableFood' to be 'Grass'\r\n                             // 'SuitableFood' becomes alias for class 'Grass'\r\n  override def eat(food: Grass) {}  // concrete method for this kind of 'Food'\r\n}\r\n```\r\n\r\n**461 - Path-dependent types**\r\n\r\n> - objects in Scala can have types as members (e.g. any instance of 'Cow' will have type 'SuitableFood' as its member)\r\n> - e.g. `milka.SuitableFood` means \"the type 'SuitableFood' that is a member of the object referenced from 'milka'\", or \"the type of 'Food' that suitable for 'milka'\"\r\n> - a type like `milka.SuitableFood` is called a **path-dependent type**, where the word \"path\" means \"the reference to an object\"\r\n> - **path** can be a single name, such as 'milka', or a longer access path, like `farm.barn.milka.SuitableFood`, where path components are variables (or singleton object names)that refer to objects\r\n\r\n```scala\r\nclass DogFood extends Food\r\nclass Dog extends Animal {\r\n  type SuitableFood = DogFood\r\n  override def eat(food: DogFood) {}\r\n}\r\n\r\nval milka = new Cow\r\nval lassie = new Dog\r\nlassie eat (new milka.SuitableFood)  // error: type mismatch; found: Grass, required: DogFood\r\n\r\n// 'SuitableFood' types of two 'Dog's both point to the same type, 'DogFood'\r\nval mickey = new Dog\r\nlassie eat (new mickey.SuitableFood)  // OK\r\n```\r\n\r\n> - although path-dependent types resemble Java's inner classes, there is a crucial difference:\r\n>   - a path-dependent type names an outer **object**, whereas an inner class type name an outer class\r\n\r\n```scala\r\nclass Outer {\r\n  class Inner\r\n}\r\n\r\n// the inner class is addressed 'Outer#Inner', instead of Java's 'Outer.Inner'\r\n// in Scala, '.' notation syntax is reserved for objects\r\n\r\nval out1 = new Outer\r\nval out2 = new Outer\r\n\r\nout1.Inner  // path-dependent type\r\nout2.Inner  // path-dependent type (different one)\r\n// both types are subtypes of 'Outer#Inner', which represents the 'Inner' class with an\r\n// arbitrary outer object of type 'Outer'\r\n// by contrast, 'out1.Inner' refers to the 'Inner' class with a specific outer object\r\n// likewise, type 'out2.Inner' refers to the 'Inner' class with a different, specific\r\n// outer object (the one referenced from 'out2')\r\n```\r\n\r\n> - the same as in Java, inner class instances hold a reference to an enclosing outer class instance, which allows an inner class to access members of its outer class\r\n> - thus, you cannot instantiate inner class without in some way specifying outer class instance\r\n>   - one way to do this is to instantiate the inner class inside the body of the outer class (in this case, the current outer class instance is used - 'this')\r\n>   - the other way is to use a path-dependent type:\r\n\r\n```scala\r\nnew out1.Inner  // since 'out1' is a reference to a specific outer object\r\n```\r\n\r\n> - the resulting inner object will contain a reference to its outer object ('out1')\r\n> - by contrast, because the type `Outer#Inner` does not name any specific instance of `Outer`, you can't instantiate it:\r\n\r\n```scala\r\nnew Outer#Inner  // error: Outer is not a legal prefix for a constructor\r\n```\r\n\r\n**464 - Structural subtyping with Refinement types**\r\n\r\n> - when one class inherits from the other, the first one is said to be a **nominal subtype** of the other one (explicit subtype, by name)\r\n> - Scala additionally supports **structural subtyping**, where you get a subtyping relationship simply because two types have the same members\r\n> - _structural subtyping_ is expressed using **refinement types**\r\n> - it is recommended that the _nominal subtyping_ is used wherever it can, because _structural subtyping_ can be more flexible than needed (e.g. a Graph and a Cowboy can `draw()`, but you'd rather get a compilation error than call graphical draw on cowboy)\r\n\r\n```scala\r\n// sometimes there is no more to a type than its members\r\n// e.g. suppose you wanted to define 'Pasture' class that can contain animals that eat 'Grass'\r\n// one could define a trait 'AnimalThatEatsGrass' and mix it in classes, where applicable\r\n// but that would be verbose, since 'Cow' already declares that it's an animal that eats grass\r\n// and with the trait, it again declares that it's an 'AnimalThatEatsGrass'\r\n// instead, you can use a 'refinement type', and to do that\r\n// you write the base type, Animal, followed by a sequence of members in curly braces\r\n// which are used to further refine the types of members from the base class\r\n// so here is how to write the type \"animal that eats grass\":\r\nAnimal { type SuitableFood = Grass }\r\n\r\n// and given this type, you can write the pasture:\r\nclass Pasture {\r\n  var animals: List[Animal { type SuitableFood = Grass }] = Nil\r\n  // ...\r\n}\r\n```\r\n\r\n> - another application of structural subtyping is grouping together a number of classes that were written by someone else\r\n> - for example, to generalize [the loan pattern from page 216](#control-abstractions), which worked for only for type `PrintWriter`, to work with any type with a `close` method:\r\n\r\n```scala\r\n// the first try:\r\ndef using[T, S](obj: T)(operation: T => S) = {  // operation from any to any type\r\n  val result = operation(obj)\r\n  obj.close() // type error: 'T' can be any type and 'AnyRef' doesn't have 'close' method\r\n  result\r\n}\r\n\r\n// the proper implementation:\r\ndef using[T <: { def close(): Unit}, S](obj: T)(operation: T => S) = {\r\n  // upper bound of 'T' is the structural type '{def close(): Unit}'\r\n  // which means: \"any subtype of AnyRef that has a 'close' method\"\r\n  val result = operation(obj)\r\n  obj.close()\r\n  result\r\n}\r\n```\r\n\r\n> - **Structural type** is a refinement type where the refinements are for members that are not in the base type\r\n\r\n**466 - Enumerations**\r\n\r\n> - Scala's _enumerations_ are not a built-in construct\r\n> - defined in `scala.Enumaration`\r\n> - to create a new enumeration, you define an object that extends `scala.Enumeration`\r\n\r\n```scala\r\nobject Color extends Enumeration {\r\n  val Red, Green, Blue = Value  // 'Value' is an inner class of 'Enumeration'\r\n}\r\n// 'Value' is also a method of Enumeration that returns a new instance of 'Value' class\r\n// so 'Color.Red' is of type 'Color.Value' and so is any other enum value in object Color\r\n\r\n// Color object definition provides 3 values: 'Color.Red', 'Color.Green' and 'Color.Blue'\r\n\r\n// to import everything from Color:\r\nimport Color._  // and then just use 'Red', 'Green' and 'Blue', without the object name\r\n```\r\n\r\n> - `Color.Value` is a _path-dependent_ type, with `Color` being the path and `Value` being the dependent type\r\n> - it's a completely new type, different from all other types\r\n> - you can associate names with enumeration values by using a different overloaded variant of the `Value` method:\r\n\r\n```scala\r\nobject Direction extends Enumeration {\r\n  val Left = Value(\"Left\")\r\n  val Right = Value(\"Right\")\r\n}\r\n\r\n// to iterate over values:\r\nfor (d <- Direction.values) print(d + \" \")  // Left Right\r\n\r\n// you can get the number of enumeration value by its 'id' method (zero-based):\r\nDirection.Right.id  // Int = 1\r\n\r\n// also:\r\nDirection(0)  // Direction.Value = Left\r\n```\r\n\r\n### Implicit Conversions and Parameters\r\n\r\n> - used when working with two bodies of code that were developed separately, thus each may have its own way to represent the same concept\r\n> - **implicits** help by reducing the number of explicit conversions one has to write\r\n\r\n```scala\r\n// using Swing without implicit conversions (a lot of boilerplate):\r\nval button = new JButton\r\nbutton.addActionListener(\r\n  new ActionListener {\r\n    def actionPerformed(event: ActionEvent) {\r\n      println(\"pressed!\")\r\n    }\r\n  }\r\n)\r\n\r\n// Scala-friendly version:\r\nbutton.addActionListener(  // type mismatch (passing function instead of ActionListener)\r\n  (_: ActionEvent) => println(\"pressed!\")\r\n)\r\n\r\n// first step is to define implicit conversion from function to action listener:\r\nimplicit def function2ActionListener(f: ActionEvent => Unit) =\r\n  new ActionListener {\r\n    def actionPerformed(event: ActionEvent) = f(event)\r\n  }\r\n\r\n// now we can write:\r\nbutton.addActionListener(\r\n  function2ActionListener(\r\n    (_: ActionEvent) => println(\"pressed!\")\r\n  )\r\n)\r\n\r\n// which is already much better than the inner class version\r\n// because the function 'function2ActionListener' is marked as 'implicit', it can be left out:\r\nbutton.AddActionListener(  // now this works!\r\n  (_: ActionEvent) => println(\"pressed!\")\r\n)\r\n```\r\n\r\n> - how implicits work:\r\n>   - the compiler first tries to compile it as is, but it sees a type error\r\n>   - it looks for an implicit conversion that can repair the problem\r\n>   - it finds 'function2ActionListener'\r\n>   - it tries to use it as a conversion method, sees that it works and moves on\r\n\r\n**482 - Rules for implicits**\r\n\r\n> - **implicit definitions** are definitions that the compiler is allowed to insert into a program in order to fix a type error\r\n> - you can use `implicit` to mark any variable, function or object definition  \r\n> \r\n> _Implicit conversions are governed by the following general rules_\r\n> - **Marking rule:** Only definitions marked `implicit` are used\r\n> - **Scope rule:** An inserted implicit conversion must be in scope as a single identifier, or be associated with the conversion's source or target type\r\n>   - _single identifier_ means that the compiler will not insert a conversion of the form `someVariable.convert`\r\n>   - it is common for libraries to include a `Preamble` object that contains useful implicits, which allows the code that uses a library to do a single `import Preamble._`\r\n>   - there's one exception to single identifier rule: the compiler will also look for implicit definitions in the companion objects of both, source and target types\r\n>   - when implicit is placed in a companion object of some type, it is said that the conversion is **associated** to that type\r\n>   - _modular code reasoning:_ when you read a source file, the only things you need to consider in other source files are those that are either imported or explicitly referenced through a fully qualified name\r\n> - **One-at-a-time rule: Only one implicit is tried**\r\n>   - for sanity's sake, the compiler does not insert further implicits when it's already in the process of trying another implicit, e.g. `convert1(convert2(x)) + y`\r\n>   - that would cause compile time to increase dramatically on erroneous code and would increase the difference between what the programmer writes and what the program does\r\n>   - it is possible to circumvent this rule by having implicits take implicit params\r\n> - **Explicits-First rule:**\r\n>   - the compiler will not change code that already works\r\n>   - a consequence of this rule is that you can make trade offs between verbose (explicits) and terse (implicits) code\r\n\r\n**484 - Naming an implicit conversion**\r\n\r\n> - implicit conversions can have arbitrary names\r\n> - the name matters only in two situations:\r\n>   - if you want to write it explicitly in a method application\r\n>   - for determining which implicits are available in a program\r\n\r\n```scala\r\n// to determine which implicits will be used:\r\nobject MyConversions {\r\n  implicit def stringWrapper(s: String): IndexedSeq[Char] = ...\r\n  implicit def intToString(x: Int): String = ...\r\n}\r\n\r\n// you can achieve that your code uses only 'stringWrapper' and not 'intToString':\r\nimport MyConversions.stringWrapper  // possible only because implicit has a name\r\n// ... code making use of 'stringWrapper'\r\n```\r\n\r\n**485 - Where implicits are tried**\r\n\r\n> - there are 3 places where implicits are used:  \r\n> **1**  conversions to an expected type (use one type where the other is expected)  \r\n> **2**  conversions of the receiver of a selection (adapts receiver of a method call)  \r\n> **3**  implicit parameters\r\n\r\n**485 - Implicit conversion to an expected type**\r\n\r\n> - whenever the compiler sees an `X`, but needs a `Y`, it will look for an implicit function that converts `X` to `Y`\r\n\r\n```scala\r\nval i: Int = 3.5  // type mismatch (loss of precision)\r\n\r\n// however, if you define implicit conversion:\r\nimplicit def doubleToInt(x: Double) = x.toInt\r\n\r\nval i: Int = 3.5  // i: Int = 3\r\n\r\n/*\r\n * 1. the compiler sees a 'Double' 3.5 in a context where it requires an 'Int'\r\n * 2. before giving up and reporting 'type mismatch', it searches for a suitable implicit\r\n * 3. it finds 'doubleToInt', and wraps 3.5 in the 'doubleToInt' function call\r\n */\r\n```\r\n\r\n**486 - Converting the receiver**\r\n\r\n> - implicits are applied on an object on which a method is invoked\r\n> - has 2 main uses: allows smoother integration of a new class into an existing class hierarchy and second, they support writing DSLs withing the Scala language\r\n> - how it works:\r\n>   - you write down `obj.doIt` where `obj` doesn't have a member named `doIt`\r\n>   - before giving up, compiler tries to insert conversions that apply to the `obj`, converting it to a type that has a `doIt` member\r\n\r\n```scala\r\n// use an instance of one type as if it was an instance of some other type\r\nclass Rational(n: Int, d: Int) {  // existing class (from page 155)\r\n  // ...\r\n  def + (that: Rational): Rational = ...\r\n  def + (that: Int): Rational = ...\r\n}\r\n\r\n// the two overloaded methods allow you to:\r\nval oneHalf = new Rational(1, 2)  // Rational = 1/2\r\noneHalf + oneHalf  // Rational = 1/1\r\noneHalf + 1  // Rational = 3/2\r\n\r\n// but:\r\n1 + oneHalf  // error: overloaded method value + (of Int) cannot bi applied to Rational\r\n\r\n// so:\r\nimplicit def intToRational(x: Int) = new Rational(x, 1)\r\n\r\n1 + oneHalf  // Rational = 3/2\r\n\r\n/*\r\n * 1. the compiler first tries to type check the expression '1 + oneHalf' as it is\r\n * 2. this fails because none of Int's '+' methods takes a 'Rational' argument\r\n * 3. compiler searches for an implicit conversion from 'Int' to another type \r\n *    that has a '+' method which can be applied to a 'Rational'\r\n * 4. it finds 'intToRational' and wraps 1 in the 'intToRational' call:\r\n */\r\nintToRational(1) + oneHalf\r\n```\r\n\r\n**489 - Simulating new syntax**\r\n\r\n> - the major use of implicit conversions is to simulate adding new syntax\r\n\r\n```scala\r\n// you can make a map using syntax:\r\nMap(1 -> \"one\", 2 -> \"two\")  // what is '->'\r\n\r\n// '->' is a method of the class 'ArrowAssoc' (defined in 'scala.Predef' preamble)\r\n// preamble also defines an implicit conversion from 'Any' to 'ArrayAssoc' so that the\r\n// '->' method can be found:\r\n\r\npackage scala\r\nobject Predef {\r\n  class ArrowAssoc[A](x: A) {\r\n    def -> [B](y: B): Tuple2[A, B] = Tuple2(x, y)\r\n  }\r\n\r\n  implicit def any2ArrowAssoc[A](x: A): ArrowAssoc[A] = new ArrowAssoc(x)\r\n\r\n  // ...\r\n}\r\n```\r\n\r\n> - that is called a **rich wrapper pattern**, which is common in libraries that provide syntax-like extensions to the language\r\n> - classes named 'RichSomething' (e.g. 'RichInt' or 'RichBoolean') are likely using implicits to add the syntax-like methods to type 'Something'\r\n\r\n**489 - Implicit parameters**\r\n\r\n> - compiler can also insert implicits within argument lists, e.g. replacing `someCall(a)` with `someCall(a)(b)` or `new SomeClass(a)` with `new SomeClass(a)(b)`, thereby adding a missing parameter list to complete a function call\r\n> - it is the entire last curried parameter that's supplied, not just the last parameter, e.g. compiler might replace `aCall(a)` with `aCall(a)(b, c, d)`\r\n> - for this to work, not just that the inserted identifiers (such as b, c and d) must be marked `implicit` where they are defined, but also the last parameter list in `aCall`'s definition must be marked `implicit`:\r\n\r\n```scala\r\n// suppose you have a class which encapsulates a user's preferred shell prompt string:\r\nclass PreferredPrompt(val preference: String)\r\n\r\nobject Greeter {\r\n  def greet\r\n    (name: String)  // first param list\r\n    (implicit prompt: PreferredPrompt) {  // implicit applies to the entire param list\r\n      println(\"Welcome, \" + name)\r\n      println(prompt.preference)\r\n  }\r\n}\r\n\r\nobject Prompt {  // dummy - just hosting 'main'\r\n  def main(args: Array[String]): Unit = {\r\n    val bobsPrompt = new PreferredPrompt(\"relax> \")\r\n    Greeter.greet(\"Bob\")(bobsPrompt)  // explicit prompt\r\n    \r\n    implicit val prompt = new PreferredPrompt(\"Yes, master> \")  // implicit identifier\r\n    Greeter.greet(\"Joe\")  // implicit prompt\r\n  }\r\n}\r\n```\r\n\r\n> - example with multiple parameters in the last parameter list:\r\n\r\n```scala\r\nclass PreferredPrompt(val preference: String)\r\nclass PreferredDrink(val preference: String)\r\n\r\nobject Greeter {\r\n  def greet(name: String)(implicit prompt: PreferredPrompt, drink: PreferredDrink) {\r\n    println(\"Welcome, \" + name + \". The system is ready.\")\r\n    print(\"But while you work, \")\r\n    println(\"why not enjoy a cup of \" + drink.preference + \"?\")\r\n    println(prompt.preference)\r\n  }\r\n}\r\n\r\nobject Prompt {  // dummy - just hosting 'main'\r\n  def main(args: Array[String]): Unit = {\r\n    val bobsPrompt = new PreferredPrompt(\"relax> \")\r\n    val bobsDrink = new PreferredDrink(\"travarica\")\r\n    Greeter.greet(\"Bob\")(bobsPrompt, bobsDrink)  // all explicit\r\n    \r\n    implicit val prompt = new PreferredPrompt(\"Yes, master> \")\r\n    implicit val drink = new PreferredDrink(\"rakija\")\r\n    Greeter.greet(\"Joe\")\r\n  }\r\n}\r\n```\r\n\r\n> - implicit parameters are most often used to provide information about a type mentioned explicitly in the earlier parameter list (like _type classes_ in Haskell):\r\n\r\n```scala\r\n// the weakness of this method is that you cannot use it to sort list of Ints\r\n// because it requires that 'T' is a subtype of 'Ordered[T]', which Int isn't\r\ndef maxListUpBound[T <: Ordered[T]](elements: List[T]): T =\r\n  elements match {\r\n    case List() => throw new IllegalArgumentException(\"empty\")\r\n    case List(x) => x\r\n    case x :: rest =>\r\n      val maxRest = maxListUpBound(rest)\r\n      if (x > maxRest) x\r\n      else maxRest\r\n  }\r\n\r\n// to remedy the weakness, we could add an extra argument\r\n// that converts 'T' to 'Ordered[T]' (i.e. provides info on how to order 'T's)\r\ndef maxListImpParm[T](elements: List[T])(implicit ordered: T => Ordered[T]): T =\r\n  elements match {\r\n    case List() => throw new IllegalArgumentException(\"empty\")\r\n    case List(x) => x\r\n    case x :: rest =>\r\n      val maxRest = maxListImpParm(rest)(ordered)\r\n      if (ordered(x) > maxRest) x\r\n      else maxRest\r\n  }\r\n\r\n// because patter is so common, the standard library provides implicit 'orderer'\r\n// methods for many common types, which is why you can use 'maxListImpParm' with:\r\nmaxListImpParm(List(1, 5, 10, 3))  // compiler inserts 'orderer' function for Ints\r\nmaxListImpParm(List(1.5, 5.2, 10.7, 3.22323))  // for Doubles\r\nmaxListImpParm(List(\"one\", \"two\", \"three\"))    // for String\r\n\r\n/*\r\n * Because elements must always be provided explicitly in any invocation of\r\n * maxListImpParm, the compiler will know T at compile time, and can therefore\r\n * determine whether an implicit definition of type T => Ordered[T] is in\r\n * scope. If so, it can pass in the second parameter list, 'orderer', implicitly.\r\n */\r\n```\r\n\r\n**495 - A style rule for implicit parameters**\r\n\r\n> - it is best to use a custom named type in the types of implicit parameters (e.g. in the `Prompt` example, the type of `prompt` and `drink` was not `String`, but `PreferredPrompt` and `PreferredDrink`)\r\n> - use at least one role-determining name within the type of an implicit parameter (in our case `Ordered`)\r\n\r\n**495 - View bounds**\r\n\r\n> - when you use `implicit` on a parameter, then not only will the compiler try to supply that parameter with an implicit value, but it will also use that parameter as an available implicit in the body of the method:\r\n\r\n```scala\r\ndef maxList[T](elements: List[T])(implicit orderer: T => Ordered[T]): T =\r\n  elements match {\r\n    case List() => throw new IllegalArgumentException(\"empty\")\r\n    case List(x) => x\r\n    case x :: rest =>\r\n      val maxRest = maxList(rest)  // '(orderer)' is implicit\r\n      if (x > maxRest) x           // 'orderer(x)' is implicit\r\n      else maxRest\r\n  }\r\n\r\n/*\r\n * 1. compiler sees that types don't match (e.g. 'x' of type 'T' doesn't have '>' method)\r\n * 2. compiler looks for implicit conversions to repair the code\r\n * 3. it finds 'orderer' in scope and converts the code to 'orderer(x) > maxRest'\r\n * 4. it also converts 'maxList(rest)' to 'maxList(rest)(orderer)'\r\n * 5. after these two implicit insertions the code fully type checks\r\n *\r\n * All that happens without a single mention of the 'orderer' parameter in the body, thus\r\n * all uses of 'orderer' are implicit\r\n */\r\n```\r\n\r\n> - because this pattern is so common, Scala lets you leave out the name of this parameter and shorten the method header by using a **view bound:**\r\n\r\n```scala\r\ndef maxList[T <% Ordered[T]](elements: List[T]): T =\r\n  elements match {\r\n    case List() => throw new IllegalArgumentException(\"empty\")\r\n    case List(x) => x\r\n    case x :: rest =>\r\n      val maxRest = maxList(rest)  // '(orderer)' is implicit\r\n      if (x > maxRest) x           // 'orderer(x)' is implicit\r\n      else maxRest\r\n  }\r\n```\r\n\r\n> - you can think of `T <% Ordered[T]` as saying \"I can use any T, so long as T can be treated as an Ordered[T]\", which is different from \"T is an Ordered[T]\", as **upper bound**, `T <: Ordered[T]`, would say\r\n> - so even though class `Int` is not a subtype of `Ordered[Int]`, we can still pass a `List[Int]` to `maxList`, so long as an implicit conversion from `Int` to `Ordered[Int]` is available\r\n> - if type `T` happens to already be an `Ordered[T]`, you can still pass a `List[T]` to `maxList` because the compiler will use an implicit **identity function**, declared in `Predef`:\r\n\r\n```scala\r\nimplicit def identity[A](x: A): A = x  // simply returns received object\r\n```\r\n\r\n**498 - When multiple conversions apply**\r\n\r\n> - when multiple implicit conversions are in scope, compiler chooses the most specific one (e.g. if one of the conversions takes `String` and the other takes `Any`, the compiler will choose the one that takes a `String`)\r\n> - one implicit conversion is **more specific** than the other if one of the following applies:\r\n>   - the argument type of the former is a subtype of the latter's\r\n>   - both conversions are methods and the enclosing class of the former extends the enclosing class of the latter one\r\n\r\n**501 - Debugging implicits**\r\n\r\n> - when you wonder why the compiler did not find an implicit conversion that you think should have been applied, it helps to write the conversion explicitly, which would possibly produce an error message so you'll know the reason why it was not applied\r\n> - if inserting the conversion explicitly make the error go away, then you know that insertion was prevented by one of the rules (often Scope rule)\r\n> - `-Xprint:typer` option tells the compiler to show what the code looks like after all implicit conversions have been added by the type checker\r\n> - implicits can make code confusing if used too frequently, thus, before writing a new implicit conversion, first try to achieve the same effect using inheritance, mixin composition or method overloading\r\n\r\n### Implementing Lists\r\n**503 - The List class in principle**\r\n\r\n> - lists are not built-in as a language construct in Scala, they are defined by an abstract class `scala.List`, which comes with 2 subclasses, `Nil` and `::`\r\n\r\n![Lists hierarchy](https://github.com/mbonaci/scala/blob/master/resources/Scala-lists-hierarchy.png?raw=true)\r\n\r\n```scala\r\npackage scala\r\nabstract class List[+T] {  // you can assign 'List[Int]' to var of type 'List[Any]'\r\n\r\n  // 3 main methods are abstract in class 'List', and concrete in classes 'Nil' and '::'\r\n  def isEmpty: Boolean\r\n  def head: T\r\n  def tail: List[T]\r\n}\r\n```\r\n\r\n> - **The `Nil` object**\r\n>   - defines an empty list\r\n>   - inherits from type `List[Nothing]`\r\n>   - because of covariance, `Nil` is compatible with every instance of the `List` type\r\n\r\n```scala\r\ncase object Nil extends List[Nothing] {\r\n  override def isEmpty = true\r\n  def head: Nothing = throw new NoSuchElementException(\"head of empty list\")\r\n  def tail: List[Nothing] = throw new NoSuchElementException(\"tail of empty list\")\r\n}\r\n```\r\n\r\n> - **The `::` object**\r\n>   - pronounced **cons**, represents non-empty lists\r\n>   - the pattern `x :: xs` is treated as `::(x, xs)`, which is treated as `xs.::(x)`\r\n\r\n```scala\r\n// idealized implementation (the real deal on page 511)\r\nfinal case class ::[T](hd: T, tl: List[T]) extends List[T] {\r\n  def head = hd\r\n  def tail = tl\r\n  override def isEmpty: Boolean = false\r\n}\r\n\r\n// since definitions of 'head' and 'tail' simply return the corresponding param, we can\r\n// write the code so that it directly uses the parameters as implementations of the\r\n// abstract methods 'head' and 'tail' that were inherited from class 'List'\r\nfinal case class ::[T](head: T, tail: List[T]) extends List[T] {\r\n  override def isEmpty: Boolean = false\r\n}\r\n// this works because every 'case class' param is implicitly also a field\r\n// as if param declaration was prefixed with the 'val' keyword\r\n```\r\n\r\n> - **Some more methods**\r\n> - all other `List` methods can be elegantly written using the basic three, e.g.:\r\n\r\n```scala\r\ndef length: Int =\r\n  if (isEmpty) 0 else 1 + tail.length\r\n\r\ndef drop(n: Int): List[T] =\r\n  if (isEmpty) Nil\r\n  else if (n <= 0) this\r\n  else tail.drop(n - 1)\r\n\r\ndef map[U](f: T => U): List[U] =\r\n  if (isEmpty) Nil\r\n  else f(head) :: tail.map(f)\r\n```\r\n\r\n**507 - List construction**\r\n\r\n> - `::` method should take an element value and yield a new list\r\n\r\n```scala\r\nabstract class Fruit\r\nclass Apple extends Fruit\r\nclass Orange extends Fruit\r\n\r\nval apples = new Apple :: Nil      // apples: List[Apple]\r\nval fruits = new Orange :: apples  // fruits: List[Fruit] - most precise common supertype\r\n\r\n// this flexibility is obtained by defining the 'cons' method as:\r\ndef ::[U >: T](x: U): List[U] = new scala.::(x, this)\r\n\r\n// the method is itself polymorphic:\r\n// 'U' is constrained to be a supertype of the list element type 'T'\r\n```\r\n\r\n> - when the code above is executed the result type is widened as necessary to include the types of all list elements\r\n\r\n![Polymorphic list construction](https://github.com/mbonaci/scala/blob/master/resources/Scala-polymorphic-list-construction.png?raw=true)\r\n\r\n> - first, the type parameter `U` of `::` is instantiated to `Fruit`\r\n> - the lower-bound constraint of `U` is satisfied, because the list `apples` has type `List[Apple]` and `Fruit` is supertype of `Apple`\r\n> - the argument to the `::` is `new Orange`, which conforms to type `Fruit`\r\n> - therefore, the method is type-correct with result type `List[Fruit]`\r\n\r\n```scala\r\ndef :::[U >: T](prefix: MyList[U]): MyList[U] =\r\n  if (prefix.isEmpty) this\r\n  else prefix.head :: prefix.tail ::: this\r\n\r\n// the infix operations can be expanded to equivalent method calls:\r\nprefix.head :: prefix.tail ::: this\r\n  // equals (because '::' and ':::' are right-associative)\r\nprefix.head :: (prefix.tail ::: this)\r\n  // equals (because '::' binds to the right)\r\n(prefix.tail ::: this).::(prefix.head)\r\n  // equals (because ':::' binds to the right)\r\nthis.:::(prefix.tail).::(prefix.head)\r\n```\r\n\r\n**509 - The `ListBuffer` class**\r\n\r\n> - the typical access pattern for a list is recursive, e.g. to increment every element without using `map`:\r\n\r\n```scala\r\ndef incAll(xs: List[Int]): List[Int] = xs match {\r\n  case List() => List()\r\n  case x :: xs1 => x + 1 :: incAll(xs1)  // not tail recursive (call is inside '::')\r\n}\r\n```\r\n\r\n> - since the function is not tail recursive, each call allocates a new stack frame\r\n> - this means that you cannot use `incAll` on list with more than 30k to 50k elements\r\n> - **list buffers** let you accumulate the elements of a list\r\n> - **ListBuffer** is a class in package `scala.collection.mutable`\r\n\r\n```scala\r\n// increment all elements of a list using 'ListBuffer':\r\ndef incAll(xs: List[Int]): List[Int] = {\r\n  val buf = new ListBuffer[Int]\r\n  for (x <- xs) buf += x + 1\r\n  buf.toList\r\n}\r\n// both '+=' and 'toList' take constant time\r\n```\r\n\r\n**511 - The `List` class in practice**\r\n\r\n> - most methods in the real implementation of class `List` avoid recursion (even if it's tail call optimized) and use loops with list buffers instead\r\n\r\n```scala\r\n// the real implementation of 'map' method:\r\nfinal override def map[U](f: T => U): List[U] = {\r\n  val b = new ListBuffer[U]\r\n  var these = this\r\n  while (!these.isEmpty) {  // highly efficient\r\n    b += f(these.head)\r\n    these = these.tail\r\n  }\r\n  b.toList\r\n}\r\n```\r\n\r\n> - a tail recursive implementation would be similarly efficient, but a general recursive implementation would be slower and less scalable\r\n\r\n```scala\r\n// the real implementation of '::' method:\r\nfinal case class ::[U](hd: U, private[scala] var tl: List[U]) extends List[U] {\r\n  def head = hd\r\n  def tail = tl\r\n  override def isEmpty: Boolean = false\r\n}\r\n\r\n// 'tl' is a 'var' - possible to modify the tail of a list after it's constructed\r\n// 'private[scala]' - accessible only from within 'scala' package\r\n// the client code outside 'scala' package can neither read nor write 'tl'\r\n// 'ListBuffer', since it is contained in subpackage of 'scala', can access 'tl' field\r\n```\r\n\r\n> - the elements of a list buffer are represented as a list and appending new elements involves modification of 'tl' field of the last '::' cell in that list\r\n\r\n```scala\r\n// 'ListBuffer' implementation:\r\npackage scala.collection.mutable\r\nfinal class ListBuffer[T] extends Buffer[T] {\r\n  private var start: List[T] = Nil\r\n  private var last0: ::[T] = _\r\n  private var exported: Boolean = false\r\n  // ...\r\n\r\n// start    - points to the list of all elements stored in the buffer\r\n// last0    - points to the last :: cell in that list\r\n// exported - indicates whether the buffer has been turned into a list using 'toList'\r\n\r\noverride def toList: List[T] = {\r\n  exported = !start.isEmpty\r\n  start\r\n}\r\n// very efficient, since it doesn't copy the list which is stored in list buffer\r\n\r\n// once a list is returned from 'toList', it must be immutable, but appending to the\r\n// 'last0' will modify the 'start' list\r\n// to maintain correctness, we work on a fresh list instead:\r\noverride def += (x: T) {\r\n  if (exported) copy()  // maintain correctness\r\n  if (start.isEmpty) {\r\n    last 0 = new scala.::(x, Nil)\r\n    start = last0\r\n  } else {\r\n    val last1 = last0\r\n    last0 = new scala.::(x, Nil)\r\n    last1.tl = last0\r\n  }\r\n}\r\n\r\n// most use cases add elements incrementally and then do one 'toList' call at the end\r\n```\r\n\r\n**513 - Functional on the outside**\r\n\r\n> - lists are purely functional on the outside, but have an imperative implementation using list buffers on the inside\r\n> - a typical strategy in Scala programming is to combine purity with efficiency by carefully delimiting the effects of impure operations\r\n> - Scala opts for pervasive sharing and no mutation for lists\r\n> - `ListBuffer` still allows you to build up lists imperatively and incrementally\r\n\r\n### For Expressions Revisited\r\n> - all `for` expressions that `yield` a result are translated by the compiler into combination of higher-order methods `map`, `flatMap` and `withFilter`\r\n> - all `for` expressions without `yield` are translated into combination of `withFilter` and `foreach`\r\n\r\n**518 - For expressions**\r\n\r\n> - generally, a `for` expression is of the form `for (seq) yield expr`, where `seq` is a sequence of **generators**, **definitions** and **filters** with semicolon between successive elements\r\n\r\n```scala\r\nfor (p <- persons; n = p.name; if (n startsWith \"To\")) yield n\r\n\r\n// if you replace parentheses with curly braces, semicolons become optional:\r\nfor {\r\n  p <- persons            // generator\r\n  n = p.name              // definition (has the same effect as 'val' definition)\r\n  if (n startsWith \"To\")  // filter\r\n} yield n\r\n```\r\n\r\n**519 - The n-queens problem**\r\n\r\n> - a particularly suitable application area of for expressions are combinatorial puzzles\r\n> - an example of such a puzzle is the n-queens problem, where 'n' queens are supposed to be placed on a 'n x n' board, each queen in its own row, such that no two queens check one another\r\n> - the goal is to find all possible solutions that match the given requirements:\r\n\r\n```scala\r\ndef queens(n: Int): List[List[(Int, Int)]] = {\r\n  def placeQueens(k: Int): List[List[(Int, Int)]] =\r\n    if (k == 0)\r\n      List(List())\r\n    else\r\n      for {\r\n        queens <- placeQueens(k - 1)\r\n        column <- 1 to n\r\n        queen = (k, column)\r\n        if isSafe(queen, queens)\r\n      } yield queen :: queens\r\n   \r\n  placeQueens(n)\r\n}\r\n\r\ndef isSafe(queen: (Int, Int), queens: List[(Int, Int)]) =\r\n  queens forall (q => !inCheck(queen, q))\r\n\r\ndef inCheck(q1: (Int, Int), q2: (Int, Int)) =\r\n  q1._2 == q2._2 ||  // in the same column\r\n  (q1._1 - q2._1).abs == (q1._2 - q2._2).abs  // in diagonal\r\n\r\n  \r\ndef printSolutions(tbls: List[List[(Int, Int)]]) = {\r\n  def printSolution(row: List[(Int, Int)]) = {\r\n    val len = row.head._1\r\n    println(\"_\" * (len * 2))\r\n    val tbl = \r\n      for {\r\n        pos <- row.reverse\r\n        col <- 1 to len\r\n        pipe = if (col == 1) \"|\" else \"\"\r\n        mark = if (col == pos._2) \"Q|\" else \"_|\"\r\n        nl = if (col == len) \"\\n\" else \"\"\r\n      } print(pipe + mark + nl)\r\n  }\r\n  for (tbl <- tbls) printSolution(tbl)\r\n}\r\n```\r\n\r\n**522 - Querying with `for` expressions**\r\n\r\n> - the `for` notation is essentially equivalent to common operations of database query languages\r\n\r\n```scala\r\n// a db table 'books' might be represented as a list of books:\r\ncase class Book(title: String, authors: String*)\r\n\r\nval books = List[Book] = \r\n  List(\r\n    Book(\r\n      \"Essential JavaScript design patterns\", \"Addi Osmani\"),\r\n    Book(\r\n      \"Developing backbone.js applications\", \"Addi Osmani\"),\r\n    Book(\r\n      \"Effective JavaScript\", \"Dave Herman\"),\r\n    Book(\r\n      \"JavaScript: The good parts\", \"Douglas Crockford\"),\r\n    Book(\r\n      \"AngularJS\", \"Brad Green\", \"Shyam Seshadri\"),\r\n    Book(\r\n      \"Taming text\", \"Grant S. Ingersoll\", \"Thomas S. Morton\", \"Andrew L. Farris\"),\r\n    Book(\r\n      \"Graph Databases\", \"Ian Robinson\", \"Jim Webber\", \"Emil Eifrem\"),\r\n    Book(\r\n      \"Node.js in action\", \"Mike Cantelon\", \"TJ Holowaychuk\", \"Nathan Rajlich\"),\r\n    Book(\r\n      \"ClojureScript up and running\", \"Stuart Sierra\", \"Luke VanderHart\")\r\n  )\r\n\r\n// to find the titles of all books whose author's first name starts with \"A\":\r\nval aAuthors =\r\n  for (b <- books; a <- b.authors if a startsWith \"A\")\r\n  yield b.title\r\n\r\n// to find the titles of all books that have \"JavaScript\" in title\r\nval js =\r\n  for (b <- books if (b.title indexOf \"JavaScript\") >= 0)\r\n  yield b.title\r\n  \r\n// to find the names of all authors that have written at least 2 books\r\nval two = \r\n  for (b1 <- books; \r\n       b2 <- books if b1 != b2;\r\n       a1 <- b1.authors; a2 <- b2.authors if a1 == a2)\r\n  yield a1\r\n\r\ndef removeDuplicates[A](xs: List[A]): List[A] = {\r\n  if (xs.isEmpty) xs\r\n  else {\r\n    // take head and compare with all in tail\r\n    // then repeat the same thing with tail\r\n    xs.head :: removeDuplicates(\r\n      for (x <- xs.tail if x != xs.head) yield x\r\n    )\r\n    \r\n   // the same thing with filter\r\n   // remove from tail if element equals head\r\n    xs.head :: removeDuplicates(\r\n      xs.tail filter (x => x != xs.head)\r\n    )\r\n  }\r\n}\r\n```\r\n\r\n**524 - Translation of `for` expressions**\r\n\r\n> - how the compiler translates `for` expressions to higher-order function calls\r\n> - **Translating `for` expressions with one generator**\r\n\r\n```scala\r\n// a simple 'for' expression:\r\nfor (x <- expr1) yield expr2\r\n// is translated to:\r\nexpr1.map(x => expr2)\r\n```\r\n\r\n> - **Translating `for` expressions starting with a generator and a filter**\r\n\r\n```scala\r\n// a 'for' expression that combine a leading generator with some other elements:\r\nfor (x <- expr1 if expr2) yield expr3\r\n// is translated to 'for' with one less element:\r\nfor (x <- expr1 withFilter (x => expr2)) yield expr3\r\n// and then to:\r\nexpr1 withFilter (x => expr2) map (x => expr3)\r\n\r\n// the same translation scheme applies if there are further elements following the filter\r\n// if 'seq' is an arbitrary sequence of generators, definitions and filters, then:\r\nfor (x <- expr1 if expr2; seq) yield expr3\r\n// is translated to:\r\nfor (x <- expr1 withFilter expr2; seq) yield expr3\r\n// and then translation continues with the second expression which is shorter by one elem\r\n```\r\n\r\n> - **Translating `for` expressions starting with two generators**\r\n\r\n```scala\r\nfor (x <- expr1; y <- expr2; seq) yield expr3\r\n// is translated to:\r\nexpr1.flatMap(x => for (y <- expr2; seq) yield expr3)\r\n// the inner 'for' expression is also translated with the same rules\r\n\r\n// the previous \"query\" example:\r\nfor (b1 <- books; b2 <- books if b1 != b2;\r\n     a1 <- b1.authors; a2 <- b2.authors if a1 == a1)\r\nyield a1\r\n\r\n// is translated to:\r\nbooks flatMap (b1 =>\r\n  books withFilter (b2 => b1 != b2) flatMap (b2 =>\r\n    b1.authors flatMap (a1 =>\r\n      b2.authors withFilter (a2 => a1 == a2) map (a2 =>\r\n        a1))))\r\n```\r\n\r\n> - these were all examples where generators bind simple variables (as opposed to patterns) and with no definitions\r\n> - **Translating patterns in generators**\r\n> - the translation scheme becomes more complicated if the left hand side of generator is a pattern ('pat')\r\n\r\n```scala\r\n// if instead if simple variable tuple appears:\r\nfor ((x1, ..., xn) <- expr1) yield expr2\r\n// translates to:\r\nexpr1.map { case (x1, ..., xn) => expr2 }\r\n\r\n// if a single pattern is involved:\r\nfor (pat <- expr1) yield expr2\r\n// translates to:\r\nexpr1 withFilter {\r\n  case pat => true\r\n  case _ => false\r\n} map {\r\n  case pat => expr2\r\n}\r\n\r\n// the generated items are first filtered with pattern matching\r\n// and only the remaining ones are mapped\r\n// so it's guaranteed that a pattern-matching generator will never throw a 'MatchError'\r\n```\r\n\r\n> - **Translating definitions**\r\n\r\n```scala\r\n// if a 'for' expression contains embedded definitions:\r\nfor (x <- expr1; y = expr2; seq) yield expr3\r\n// is translated to:\r\nfor ((x, y) <- for (x <- expr1) yield (x, expr2); seq)\r\nyield expr3\r\n\r\n// 'expr2' is evaluated every time a new 'x' value is generated\r\n// which is necessary because 'expr2' might depend on 'x'\r\n// so it's not a good idea to have definitions in 'for' expressions that do not refer\r\n// to variables bound by some preceding generator, because reevaluating such \r\n// expressions is wasteful, e.g. instead of:\r\nfor (x <- 1 to 1000; y = expensiveComputationNotInvolvingX)\r\nyield x * y\r\n// it's better to write:\r\nval y = expensiveComputationNotInvolvingX\r\nfor (x <- 1 to 1000) yield x * y\r\n```\r\n\r\n> - **Translating `for` loops**\r\n> - the translation of `for` loops that perform a side effect without returning anything is similar, but simpler than `for` expressions\r\n\r\n```scala\r\n// wherever the previous translations used 'map' or 'flatMap', we use 'foreach':\r\nfor (x <- expr1) body\r\n// translates to:\r\nexpr1 foreach (x => body)\r\n\r\n// or slightly larger example:\r\nfor (x <- expr1; if expr2; y <- expr3) body\r\n// translates to:\r\nexpr1 withFilter (x => expr2) foreach (x => \r\n  expr3 foreach (y => body))\r\n\r\n// for example, summing up all elements of a matrix represented as list of lists:\r\nvar sum = 0\r\nfor (xs <- xss; x <- xs) sum += x\r\n// is translated into two nested 'foreach' applications:\r\nvar sum = 0\r\nxss foreach (xs => \r\n  xs foreach (x =>\r\n    sum += x))\r\n```\r\n\r\n**528 - Going the other way**\r\n\r\n> - every application of a `map`, `flatMap` and `withFilter` can be represented as a `for` expression\r\n\r\n```scala\r\nobject ReversedTranslationDemo {\r\n\r\n  def map[A, B](xs: List[A], f: A => B): List[B] =\r\n    for (x <- xs) yield f(x)\r\n  \r\n  def flatMap[A, B](xs: List[A], f: A => List[B]): List[B] =\r\n    for (x <- xs; y <- f(x)) yield y\r\n    \r\n  def filter[A](xs: List[A], p: A => Boolean): List[A] =\r\n    for (x <- xs if p(x)) yield x\r\n\r\n  def main(args: Array[String]): Unit = {\r\n    val xs = List(1, 2, 3, 4)\r\n    def f1 = (x: Int) => x + 1\r\n    def f2 = (x: Int) => (x. to (x + 1)).toList\r\n    def f3 = (x: Int) => x % 2 == 0\r\n    \r\n    val mapped = map(xs, f1)\r\n    val flatmapped = flatMap(xs, f2)\r\n    val filtered = filter(xs, f3)\r\n    \r\n    println(mapped)      // List(2, 3, 4, 5)\r\n    println(flatmapped)  // List(1, 2, 2, 3, 3, 4, 4, 5)\r\n    println(filtered)    // List(2, 4)\r\n  }\r\n}\r\n```\r\n\r\n**529 - Generalizing `for`**\r\n\r\n> - it is possible to apply `for` notation to every type that defines `map`, `flatMap`, `withFilter` or `foreach`\r\n> - if a type defines:\r\n>   - just `map`, it allows `for` expressions with a single generator\r\n>   - `map` and `flatMap` - more than one generator\r\n>   - `foreach` - it allows `for loops` (with single and multiple generators)\r\n>   - `withFilter` - it allows filter expressions starting with an `if` inside `for`\r\n> - the translation happens before type checking, which allows maximal flexibility, because it is only required that the result of expansion type checks\r\n> - Scala defines no typing rules for `for` expressions and doesn't require that methods `map`, `flatMap`, `withFilter` and `foreach` to have any particular type signatures\r\n> - nevertheless, there is a typical setup that captures most common intention of the higher order methods to which `for` expressions translate:\r\n\r\n```scala\r\n// a class that would be used for a collection 'C' of elements 'A':\r\nabstract class C[A] {\r\n  def map[B](f: A => B): C[B]\r\n  def flatMap[B](f: A => C[B]): C[B]\r\n  def withFilter(p: A => Boolean): C[A]\r\n  def foreach(b: A => Unit): Unit\r\n}\r\n```\r\n\r\n### The Scala Collections API\r\n**534 - Mutable an immutable collections**\r\n\r\n> - there are 4 packages with collection types:\r\n>   - **scala.collection** - may be changed by other parties in run time\r\n>   - **scala.collection.immutable** - collection changes in place\r\n>   - **scala.collection.mutable** - guaranteed to be immutable for everyone\r\n>   - **scala.collection.generic** - provide building blocks for implementing collections\r\n> - typically, collection classes defer the implementation of some of their operations to classes in `generic`\r\n\r\n**535 - Collections consistency**\r\n\r\n```scala\r\n// the most important collection classes:\r\nTraversable\r\n  Iterable\r\n    Seq\r\n      IndexedSeq\r\n        Vector\r\n        ResizableArray\r\n        GenericArray\r\n      LinearSeq\r\n        MutableList\r\n        List\r\n        Stream\r\n      Buffer\r\n        ListBuffer\r\n        ArrayBuffer\r\n    Set\r\n      SortedSet\r\n        TreeSet\r\n      HashSet (mutable)\r\n      LinkedHashSet\r\n      HashSet (immutable)\r\n      BitSet\r\n      EmptySet, Set1, Set2, Set3, Set4\r\n    Map\r\n      SortedMap\r\n        TreeMap\r\n      HashMap (mutable)\r\n      LinkedHashMap (mutable)\r\n      HashMap (immutable)\r\n      EmptyMap, Map1, Map2, Map3, Map4\r\n```\r\n\r\n> - there is a quite a bit commonality shared by all these classes, e.g. every kind of collection can be created by the same uniform syntax:\r\n\r\n```scala\r\nTraversable(1, 2, 3)\r\nIterable(\"x\", \"y\", \"z\")\r\nMap(\"x\" -> 24, \"y\" -> 25)\r\nSet(Color.Red, Color.Green, Color.Blue)\r\nSortedSet(\"hello\", \"world\")\r\nBuffer(x, y, z)\r\nIndexedSeq(1.0, 2.0)\r\nLinearSeq(a, b, c)\r\n```\r\n\r\n**537 - Trait `Traversable`**\r\n\r\n> - on top of the collection hierarchy\r\n> - its only _abstract_ operation is `foreach`:\r\n\r\n```scala\r\ndef foreach[U](f: Elem => U)  // 'U` - arbitrary result type\r\n```\r\n\r\n> - collection classes that mix in `Traversable`, just need to implement the `foreach` method, all other methods can be inherited from `Traversable`\r\n> - `foreach` is supposed to traverse all elements and apply a given operation, `f`, to each element\r\n> - `f` is invoked only because of its side effects (result of `f` is discarded)\r\n> - the following table lists all concrete methods of `Traversable`:\r\n\r\n - **Abstract method**\r\n\r\n> - `xs foreach f`    Executes function f for every element of xs\r\n\r\n - **Addition**\r\n\r\n> - `xs ++ ys`        A collection consisting of the elements of both xs and ys\r\n\r\n - **Maps**\r\n\r\n> - `xs map f`        The collection obtained from applying f to every element of xs\r\n> - `xs flatMap f`    The collection obtained by applying f to every element of xs and\r\n>                     concatenating the results\r\n> - `xs collect f`    The collection obtained by applying partial function f to every\r\n>                     element in xs for which it is defined and collecting the results\r\n\r\n - **Conversions**\r\n\r\n> - `xs.toArray`      Converts the collection to an array\r\n> - `xs.toList`       Converts the collection to a list\r\n> - `xs.toIterable`   Converts the collection to an iterable\r\n> - `xs.toSeq`        Converts the collection to a sequence\r\n> - `xs.toIndexedSeq` Converts the collection to an indexed sequence\r\n> - `xs.toStream`     Converts the collection to a stream (a lazily computed sequence)\r\n> - `xs.toSet`        Converts the collection to a set\r\n> - `xs.toMap`        Converts the collection of key/value pairs to a map\r\n\r\n - **Copying**\r\n\r\n> - `xs copyToBuffer buf`         Copies all elements to buffer 'buf'\r\n> - `xs copyToArray(arr, s, len)` Copies at most 'len' elements of 'arr', starting at 's'\r\n\r\n - **Element retrieval**\r\n\r\n> - `xs.head`         Retrieves the first element of the collection\r\n> - `xs.headOption`   The first element of xs in an option value, or None if xs is empty\r\n> - `xs.last`         The last element of the collection (or some elem. if no order)\r\n> - `xs.lastOption`   The last element of xs in an option value, or None if xs is empty\r\n> - `xs find p`       An option containing the first element in xs that satisfies p\r\n\r\n - **Subcollections**\r\n\r\n> - `xs.tail`             Returns the rest of the collection (except xs.head)\r\n> - `xs.init`             The rest of the collection except xs.last\r\n> - `xs slice (from, to)` Collection of elements from 'from', up to and excluding 'to'\r\n> - `xs take n`           First n elements (or some elements if no order is defined)\r\n> - `xs drop n`           The rest of collection (except xs take n)\r\n> - `xs takeWhile p`      The longest prefix of elements that satisfy p\r\n> - `xs dropWhile p`      The collection without prefix that satisfies p\r\n> - `xs filter p`         The collection of all elements that satisfy p\r\n> - `xs withFilter p`     A non-strict filter\r\n> - `xs filterNot p`      The collection of all elements that do not satisfy p\r\n\r\n - **Subdivisions**\r\n\r\n> - `xs splitAt n`    Splits xs returning pair of collections (xs take n, xs drop n)\r\n> - `xs span p`       Splits xs returning (xs takeWhile p, xs dropWhile p)\r\n> - `xs partition p`  Splits on (xs filter p, xs filterNot p)\r\n> - `xs groupBy f`    Partitions xs into a map of collections according to function f\r\n\r\n- **Element conditions**\r\n\r\n> - `xs forall p`     A boolean indicating whether all elements satisfy p\r\n> - `xs exists p`     A boolean indicating whether p holds for at least one element\r\n> - `xs count p`      The number of elements in xs that satisfy the predicate p\r\n\r\n- **Folds**\r\n\r\n> - `(z /: xs)(op)`        Applies operation op between successive elements, going\r\n>                          left to right, starting with z\r\n> - `(xs :\\ z)(op)`        Applies operation op between successive elements, going\r\n>                          right to left, starting with z\r\n> - `xs.foldLeft(z)(op)`   Same as (z /: xs)(op)\r\n> - `xs.foldRight(z)(op)`  Same as (xs :\\ z)(op)\r\n> - `xs reduceLeft op`     Applies binary operation op between successive elements of\r\n>                          non-empty collection xs, going left to right\r\n> - `xs reduceRight op`    Applies binary operation op between successive elements of\r\n>                          non-empty collection xs, going right to left\r\n\r\n- **Specific folds**\r\n\r\n> - `xs.sum`          The sum of all numeric element values of xs\r\n> - `xs.product`      The product of all numeric element values of xs\r\n> - `xs.min`          The minimum of the ordered element values of xs\r\n> - `xs.max`          The maximum of the ordered element values of xs\r\n\r\n- **Strings**\r\n\r\n> - `xs addString (b, start, sep, end)` Adds a string to StringBuilder b that allows\r\n>                                       all elems between sep enclosed in strings start\r\n>                                       and end (start, sep and end are all optional)\r\n> - `xs mkString (start, sep, end)`     Converts the collection to a string that shows\r\n>                                       all elems between sep enclosed in strings\r\n>                                       start and end (start, sep and end are optional)\r\n> - `xs.stringPrefix`                   The collection name returned from xs.toString\r\n\r\n- **Views**\r\n\r\n> - `xs.view`                  Produces a view over xs\r\n> - `xs view (from, to)`       Produces a view that represents elems in some index range\r\n\r\n","google":"UA-43640202-1","note":"Don't delete this file! It's used internally to help with page regeneration."}